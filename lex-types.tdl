;; -*- Mode: TDL; Coding: euc-jp -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;        file: lex-types.tdl
;;;      module: Basis
;;;     version: %I%
;;;  written by: Melanie Siegel
;;; last update: 
;;;  updated by: Melanie Siegel/Emily Bender
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; author            | date        | modification
;;; -----------------|--------- ---|------------------------------------------
;;;Melanie Siegel(MS)|             | Emily Bender (ERB), Francis Bond (FCB), 
;;;                  |             | Sanae Fujita (SF), Takaaki Tanaka (TT),
;;;                  |             | Akira Ohtani (AO)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;






;;;;;;;;;;;;;;;;;;;HEADS;;;;;;;;;;;;;;;;;;;;;;;;;


; (ERB 2001-08-06) In order to do Jeff Smith's version of number
; names (i.e., using head-comps and head-spr rules) I need to
; classify all subtypes of head into integer and nonint_head.
; This way I can have a head-initial HCR that only works with
; number names.

; (ERB 2001-08-21) I found another candidate for the head of
; the head-initial HCR, namely symbols like $, ￥, etc. that
; (orthographically) precede the numbers the go with.  So,
; I'm renaming the two subtypes of head to be final_head and
; init_head.


final_head :< j-head.
init_head :< j-head.

utterance_super :=  final_head &
                  [POS utt,
                   MOD null,
                   C-MOD null,
                   J-SPEC null,
                   MARK < >,
                   SMOD marked,
                   COP-ARG -].

utterance_head := utterance_super.
fragment_head := utterance_super.

temp_mod_head :< final_head.

temp_mod_head-avm := temp_mod_head &
                     [POS temp_mod,
                      MARK null,
                      C-MOD null,
                      J-POSTHEAD right,
                      J-SPEC null,
                      COP-ARG -].


; (MS 2003-01-21) adding the MOD none restriction on the modified noun, because I got spurious ambiguity on 日本の経済

temp_nmod_head := temp_mod_head-avm &
                     [ MOD < [LOCAL [CAT.HEAD noun_head & [MOD null],
				     BAR +]] > ].


; (MS 2003-09-11) This seems not to be in use any more.

;temp_vmod_head := temp_mod_head-avm &
;                     [ MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD -,
;								  FORMAL.AHON -],
;                                            BAR +]] >,
;		       COP-ARG -].

noun_mod_head :< final_head.

; (ERB 2002-01-10) Developing an analysis of など as a posthead
; noun-mod-lex.  So, this shouldn't be J-POSTHEAD left.

; (MS 2002-01-16) Moving from LEX + to BAR +, to allow compounds as modifiees.

noun_mod_head-avm :=  noun_mod_head &
                      [POS noun_mod,
                       MARK null,
                       MOD < [LOCAL [CAT [HEAD noun_head,
                                                 VAL saturated],
                                            BAR bool]] >,
                       C-MOD null,
                       J-SPEC null,
                       COP-ARG -].

pp_mod_head :< final_head.



pp_mod_head-avm :=  pp_mod_head &
                      [POS pp_mod,
                       MARK null,
                       MOD < [LOCAL [CAT [HEAD vmod-p_head,
					  VAL saturated],
				     BAR bool]] >,
                       C-MOD null,
                       J-SPEC null,
                       COP-ARG -].

; (MS 2005-11-09) These are all AHON + and modifying BAR +.

hon-prefix_head :=  j-head &
                   [POS prefix,
		    FORMAL.AHON +,
                    MARK null,
                    MOD < [LEX +, LOCAL.BAR +] >,
                    C-MOD null,
                    J-POSTHEAD left,
                    J-SPEC null,
                    COP-ARG -].



punct_head := final_head &
              [MARK null,
               C-MOD null,
               COP-ARG -].

punct_head-avm := punct_head &
                  [J-SPEC  < >].

brackets-or-quotations_head := punct_head.
brackets-or-quotations-end_head :=brackets-or-quotations_head.
brackets-or-quotations-init_head :=brackets-or-quotations_head.

comma-etc_head := punct_head-avm.

; (ERB 2002-01-14) For comma that takes infinitival V as
; complement and gives it a C-MOD value.

; (ERB 2002-02-12) Don't know why I said C-MOD...ADJ -,
; but that obviously needs to come out: 食べ、よい.

punct_head2 := verb_head-super &
               [POS punct,
                MARK null,
                J-SPEC null,
                COP-ARG -,
                J-POSTHEAD coord,
                MOD null,
                C-MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
                             BAR +] ] >].

comma-pmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD p_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-advmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD adv_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-sapmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD sap_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-infvmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD sentence-valid &
                                                [FIN -,
                                                 MAIN-PRD +]],
                                    BAR +]] >,
               J-POSTHEAD right].

; (ERB 2002-01-15) Replacing comma-s_conj with two commas that
; modify verbal things that have nonempty MOD and C-MOD values, respectively.

comma-vmod1_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD verb_head &
                                              [MOD 1-list,
                                               C-MOD null,
                                               MAIN-PRD +],
                                         VAL saturated],
                                    BAR +]] >,
               J-POSTHEAD right].

comma-vmod2_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD verb_head &
                                              [C-MOD 1-list,
                                               MAIN-PRD bool],
                                         VAL saturated],
                                    BAR +]] >,
               J-POSTHEAD right].

comma-interjmod_head  := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD interj_head,
                                    BAR +]] >,
               J-POSTHEAD right].


parent-end_head := punct_head & noun_head & int_head &
              [MOD < [LOCAL [CAT [HEAD noun_head,
				  VAL saturated],
			     BAR +]] > ].

parent-init_head := brackets-or-quotations_head &
              [MOD null,
	       J-SPEC  < >].


quotation-name-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].

quotation-name-end_head  := brackets-or-quotations-end_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head,
                                             BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].


quotation-noun-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].


quotation-noun-end_head  := brackets-or-quotations-end_head & noun_head &
                       [MOD < [LOCAL [CAT [HEAD ordinary_noun_head,
						  VAL saturated],
                                             BAR +]] >,
                        J-POSTHEAD right].

quotation-sentence-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].

quotation-sentence-end_head  := brackets-or-quotations-end_head & sentence-valid &
                       [MOD < [LOCAL [CAT.HEAD sentence-valid,
				      BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].

quotation-sap-init_head := brackets-or-quotations-init_head & 
                      [MOD < [LOCAL [CAT.HEAD sap_head,
                                             BAR +]] >,
		       J-SPEC  < >,
                        J-POSTHEAD left].

quotation-sap-end_head  := brackets-or-quotations-end_head &
                       [MOD < [LOCAL [CAT.HEAD sap_head,
                                             BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].

quotation-definition-end_head := brackets-or-quotations-end_head & nom_head-avm &
                       [MOD null,
			J-SPEC  null].

; (ERB 2001-08-09) I need a supertype to both noun_head and case-p_head to 
; get disjunctive modification possiblities for numeral classifiers w/o
; adding extra lexical entries.

noun-or-case-p_head :< final_head.

noun_head :< noun-or-case-p_head.

; (MS 2005-07-04) I want to get rid of the compound-noun-rule, such that I give a value to MOD here.

noun_head-avm :=  noun_head &
                  [POS n,
		   C-MOD null,
		   MARK null,
		   QUANTIFIABLE bool,
		   COP-ARG -].

; (ERB 2002-01-28) Make supertype to ordinary_noun_head and date_noun_head
; to allow words like TOKI as heads of compounds.


ordinary-or-date-noun_head := noun_head-avm.
ordinary_noun_head := ordinary-or-date-noun_head.

;(MS 2001-12-14) changing J-SPEC in order to make something like GAKUSEI SAMA possible.
; (MS 2005-07-04) I want to get rid of the compound-noun-rule, such that I give a value 
;   to MOD in noun_head-avm.
; (was MOD null)

ordinary_noun_head-avm := ordinary_noun_head & 
			  [J-SPEC.FIRST.LOCAL.CAT.HEAD title_head, 
			   MOD < [LOCAL [CAT [HEAD ordinary-or-date-noun_head]],
				  MODIFIED.PERIPH -]>,
			   J-POSTHEAD compound,
			   VN -].

;; (FCB 2003-09-04) type for mi and sa

adj2n-suffix_noun_head := ordinary-or-date-noun_head.

adj2n-suffix_noun_head-avm := adj2n-suffix_noun_head  & [MOD null, VN -].

; (MS 2005-10-06) I use this for month names.
; (MS 2005-11-04) I date nouns to occur in compounds, such as "毎週土曜日"

date_noun_head := temporal-noun_head & ordinary-or-date-noun_head.

date_noun_head-avm := date_noun_head & [J-SPEC null, 
					J-POSTHEAD compound,
					VN -,
					MOD < [LOCAL intersective_mod & 
						     [CAT [HEAD noun_head-avm,
							   VAL saturated]],
					       MODIFIED.PERIPH -] >].

pron_head :< noun_head-avm.

pron_head-avm := pron_head & [MOD null, 
	                      KEYS.KEY pron_rel,
			      J-SPEC null, 
			      VN -,
			      QUANTIFIABLE -].

exceptional_noun_head := nom_head-avm & [MOD null, 
					 J-SPEC null, 
					 NO-MOD -, 
					 QUANTIFIABLE -].

; (MS 2005-03-30) This seems not to be in use any more.
;exceptional_noun_nmod_head := nom_head-avm & [J-SPEC null, 
;					      QUANTIFIABLE -, 
;					      MOD < [LOCAL.CAT.HEAD noun_head]>, 
;					      J-POSTHEAD rels].

                  
relational_noun_head := ordinary_noun_head & [MOD null,J-SPEC null, VN -].
                                                   

dofw_noun_head  :< temporal-noun_head.
dofm_noun_head  :< temporal-noun_head.



dofw_noun_head-avm := dofw_noun_head & 
                      [MOD null].

dofm_noun_head-avm := dofm_noun_head & 
                      [MOD null].



nom_head  :< noun_head-avm.


nom_head-avm  := nom_head & [J-SPEC null, ADJ -].


title_head  :< noun_head-avm.



title_head-avm := title_head & 
                  [MOD < [LOCAL.CAT.HEAD idiom_head] >, 
                   J-SPEC null,
                   J-POSTHEAD left,
                   QUANTIFIABLE -].


name_head :< noun_head-avm.


name_head-avm := name_head & 
                 [J-SPEC.FIRST.LOCAL.CAT.HEAD title_head,
		  VN -,
                  QUANTIFIABLE -].

; (MS 2005-03-15) For documentation purposes, changed pn_head to surname_head

surname_head :< name_head-avm.


surname_head-avm := surname_head & 
               [MOD < [LOCAL [CAT.HEAD name_head]] >,
		J-POSTHEAD compound].

ippan_head :< name_head-avm.

ippan_head-avm := ippan_head &
                  [MOD < [LOCAL [CAT.HEAD ordinary_noun_head]] >,
                   J-POSTHEAD left].

first_name_head :< name_head-avm.


first_name_head-avm := first_name_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head]] >,
			J-POSTHEAD compound].

other_name_head :< name_head-avm.

other_name_head-avm := other_name_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head]] >,
			J-POSTHEAD compound].

inst_name_head :< name_head-avm.

;(MS 2005-11-15) Found examples of compounds with inst-names,
; such as "小田急片瀬江ノ島駅前". Changing MOD null to noun_head.

inst_name_head-avm := inst_name_head & 
                      [MOD < [LOCAL.CAT.HEAD noun_head] >,
                      J-POSTHEAD compound].

; (MS-2005-09-30) Shouldn't the relation between a location name and an institution be a compound?
; Maybe it should just be a noun: "アメリカ経済"

loc_name_head :< name_head-avm.

loc_name_head-avm := loc_name_head & 
                     [MOD < [LOCAL.CAT.HEAD noun_head] >,
                      J-POSTHEAD compound].


product_name_head :< name_head-avm.

product_name_head-avm := product_name_head &
                        [MOD null].

temp_numeral_head :< temporal-noun_head.


; (MS 2005-11-04) Found examples for compounds of temp_numerals and noun (vn): "深夜営業"
; changing the MOD null value.

temp_numeral_head-avm :=  temp_numeral_head & 
                      [MOD < [LOCAL.CAT.HEAD noun_head] >].

; (ERB 2001-08-07) Redoing numeral classifiers...
; (ERB 2001-08-07) Copying constraints from expanded def of old
; number-classifier_head and changing as appropriate.
; (ERB 2001-09-24) Making this COP-ARG - until data
; compels the contrary.
; (ERB 2001-10-29) I believe they should be COP-ARG +,
; but they need to be made into something predicative in order
; to function properly as the complement of the copula.  So,
; I think I'll add another pumping rule.

num-cl_head := init_head &
	       [ MARK null,
                 POS numcl,
                 C-MOD null,
                 J-SPEC null,
                 FORMAL formal,
                 QUANTIFIABLE -,
		 VN -,
                 COP-ARG - ].

; 本、個、便、etc.

; (ERB 2001-08-09) Trying to get disjunctive MOD values without positing
; extra lexical entries for numeral classifiers.

; (ERB 2001-09-13) J-POSTHEAD has different values depending on what the
; MOD.HEAD value is.

num-cl-mod_head := num-cl_head &
                   [ MOD < synsem > ].

num-cl-n-or-p-mod_head := num-cl-mod_head & 
                          [MOD < [LOCAL.CAT [ HEAD noun-or-case-p_head,
					      VAL saturated ]] > , 
			   J-POSTHEAD right ].

; (MS 2004-12-27) Floated numeral classifiers
; (MS 2005-01-07) Using EMPTY to prevent floated quantifiers to go into the nominal-numcl-rule.

num-cl-adv_head := num-cl-mod_head &
                   [ MOD < [LOCAL scopal_mod & [CAT [ HEAD verb_head]]] >,
		     EMPTY -].

num-cl-float_head := num-cl-adv_head.
num-cl-event_head := num-cl-adv_head.

; 番、号

; (ERB 2001-09-12) Some num-cl like things can't "float" (i.e., show 
; up outside the PP.  So these have a more specific MOD value).

; (MS 2004-11-30) But these should not go into the relative clause rule.
; That's why they get the J-POSTHEAD nonrels.

; (MS 2005-01-10) The modified noun should be saturated to prevent spurious
; ambiguity in e.g., 猫二匹を飼う
; The J-POSTHEAD should be right, because pre-nominal numeral classifiers are not 
; possible: *二匹猫を飼う

num-cl-nmod_head := num-cl-mod_head &
                    [ MOD < [LOCAL.CAT [HEAD noun_head,
					VAL saturated]] >,
		      J-POSTHEAD right].


; 円、階、etc.

num-cl-nomod_head := num-cl_head &
                     [ MOD null ].

; ERB (2001-08-28) Date expressions

; ERB (2001-09-24) Overhauling the date expressions.  The general
; plan is treat them as nouns, which take up to three arguments:
; a determiner (この、その、あの、どの）
; an OBJ2 (月 for 日 and 年 for 月)
; an integer (1-12 for 月、1-31 for 日、unlimited for 年)
; The first two of these are optional, although ordered.
; The third is obligatory, and must occur right next to the head.

; (ERB 2002-01-14) I want to allow punct_head2 in the sentence-te-coordination
; rule without allowing it anywhere else that verbs are required.  So,
; making this supertype.

verb_head-super := sentence-valid.

verb_head := verb_head-super.

;(MS 2001-09-25) I've taken S-MODIFIED out of the head in order to replace it with NUCLEUS, but not in the head.

;(ERB 2002-01-15) verb_head-avm contrasts with verbend_head, so declaring
; the feature EMPTY here causes problems:  When conjunctions place restrictions
; on its value, they force type resolution from sentence-valid to 
; verb_head-avm and then don't unify with inflected verbs (i.e., those
; that are HEAD verbend_head).  So, moving EMPTY up to verb_head.

verb_head-avm := verb_head &
             [POS v,
              AUX aux,
              COP bool,
              VN bool,
              LIGHT bool,
              ADJ bool,
              MODUS mood,
              FIN bool,
              MAIN-PRD bool,
              SMOD smod].


verb-stem_head := verb_head-avm &
                  [VN -].

ordinary-verb-stem_head := verb-stem_head.

other-verb-stem_head := verb-stem_head.

v-stem_head  := ordinary-verb-stem_head &
                [AUX aux_minus,
                 MODUS nonpassive,
                 LIGHT -,
                 ADJ -].

cop-id-stem_head := v-stem_head &
		    [COP-ARG -,
		     COP +,
		     VN -,
		     AUX aux_minus,
		     LIGHT -,
		     ADJ -].

aux-stem_head := other-verb-stem_head &
                [AUX aux_plus,
                 ADJ -,
                 LIGHT -,
                 COP-ARG -].
     
; (MS 2004-06-25) Took the ADJ - restriction out.

verbend_head := verb_head &
              [COP -].

; (ERB 2002-01-11) Most verbal endings are [SMOD unmarked]:

v-end_head := verbend_head.


verbend_head-unmarked := verbend_head &
                         [ SMOD unmarked ].

v-op-end_head := verbend_head-unmarked & [VN -].

v-cond-end_head :< v-op-end_head.

v-pass-caus-end_head := verbend_head-unmarked.

pass-end_head := v-pass-caus-end_head & [MODUS passive].

simple-pass-end_head := pass-end_head & [MOD < [LOCAL [CAT.HEAD noun_head,
						       BAR +]] >,
					 J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					 FIN +,
					 J-POSTHEAD rels,
					 C-MOD null,
					 FORMAL.AHON -].



caus-end_head  := v-pass-caus-end_head & [MODUS causative,
					   MARK < [MODIFIED.PERIPH -] >].

contracted-aux_head := verbend_head-unmarked.

verb-noninfl_head :< verb_head-avm.

verb-noninfl_head-avm := verb-noninfl_head & [AUX aux_minus].

cop_head := verb-noninfl_head-avm & [COP-ARG -, LIGHT -].

; (MS 2003-1-22) Should be COP-ARG neutr, because of 結婚するんですか 

light-verb_head := other-verb-stem_head &
                [AUX aux_minus,
                 ADJ -,
                 LIGHT +].

p_head :< final_head.

p_head-avm := p_head &
          [POS p,
           PTYPE ptype,
           MARK null,
           CASE case].

mod-p_head :< p_head-avm.

; (ERB 2002-01-22) Adverbs and such can modify things that are NUCL nucl_bool,
; but crucially not things that are NUCL conj.  This forces low adverb
; attachment wrt to the conj-rule.
; (MS 2002-07-04) But this is not valid for topic particles.
; "これは聞けば分かります"

mod-p_head-avm := mod-p_head &
              [CASE mod,
               C-MOD null,
               MOD 1-list].

vmod-p_head :< mod-p_head-avm.

; (ERB 2001-09-13) Getting rid of J-POSTHEAD value intersective, in system
; with only two HMRs.  See notes in japgram.tdl and rule-types.tdl.
; (MS 2001-11-29) Making all these intersective_mod for the differentiation in the head-adjunct rules.

vmod-p_head-avm := vmod-p_head &
                   [J-SPEC null,
                    MOD < [LOCAL intersective_mod &
					[CAT.HEAD verb_head,
                                         BAR +]] >,
                    J-POSTHEAD left].


; (ERB 2002-01-21) How bad is it for ambiguity if this doesn't
; say MOD...SMOD unmarked?  (I'm using that to constrain some other
; things and it would be nice if the head type were enough here.)

; (MS 2004-11-12) Here we restrict the MOD to be MAIN-PRD +. But this is not true
; in all cases: 社内でも有名な王が寝る。Here we want to be able to say that the king is
; famous in the company. I wonder how much this affects the ambiguity.

;topic-vmod-p_head := vmod-p_head-avm & [MOD < [LOCAL [CAT.HEAD [MAIN-PRD +]] ] >,
;                                        PTYPE topic,
;                                        COP-ARG -].

topic-vmod-p_head := vmod-p_head-avm & [PTYPE topic,
                                        COP-ARG -].

; (MS 2005-05-10) Not used any more.
;uttmod-p_head := mod-p_head-avm &
;               [J-SPEC null,
;                MOD < [LOCAL [CAT.HEAD verb_head & [FIN +,
;                                                          MAIN-PRD +],
;                                     BAR +,
;				     NUCL nucl_bool]] >,
;                J-POSTHEAD left,
;                COP-ARG -].



nmod-p_head :< mod-p_head-avm.

;"dekitara issho ni hanoofaa no kaNkou  shimaseN ka."
;"asa no juuji ni rufutohaNza no nanahyaku yoNjuuichi biN ga dete imasu keredomo."


nmod-p_head-avm := nmod-p_head &
                   [MOD < [ LOCAL.NUCL nucl_bool ] >,
                    J-POSTHEAD left,
                    COP-ARG -].




overt-nmod-p_head := nmod-p_head-avm & 
                     [PTYPE overt,
                      J-SPEC null,
                      MOD < [LOCAL [ CAT [HEAD noun_head,
                                        VAL saturated]],
                           MODIFIED.PERIPH +] > ].



; (MS 2001-12-14) The COP-ARG - is introduced to prevent spurious ambiguity in II NO DESU KA.

nspec-p_head := p_head-avm & [MOD null,
			      COP-ARG -,
                              C-MOD null,
                              PTYPE overt,
                              J-SPEC.FIRST.LOCAL.CAT.HEAD nom_head].

empty-nmod-p_head := nmod-p_head-avm & 
                     [PTYPE empty,
                      J-SPEC null,
                      MOD < [LOCAL.BAR -] >,
                      COP-ARG -].

; (MS 2005-10-21) "C-MOD < [MODIFIED.PERIPH -]" prevents the case of compounds in conjunctions.
; Changing that.

n_conj_head := p_head-avm & [MOD null,
                             CASE con,
                             PTYPE to,
                             J-SPEC null,
                             C-MOD < [MODIFIED.PERIPH bool] >].



;"ato saNgatsu desu to yahari juuninichi no mokuyoubi kara hatsuka kiNyoubi made no hou ga tsugou yoroshii no desu ga."

empty-vmod-p_head := vmod-p_head-avm & [PTYPE empty,
                                        MOD < [LOCAL [CAT.HEAD.MAIN-PRD +,
						   NUCL nucl_bool]] >,
                                        COP-ARG -].


empty-frag-p_head := p_head-avm & [PTYPE empty,
                                   MOD null,
                                   C-MOD null,
                                   COP-ARG -].

case-p_head := p_head-avm & 
               [CASE case,MOD null,J-SPEC null,C-MOD null,
                COP-ARG -].

overt-case-p_head := case-p_head & [PTYPE overt].

; (ERB 2001-08-09) Adding supertype that relates case-p_head to noun_head for
; numeral classifiers.

ga-or-wo-case-p_head := overt-case-p_head & noun-or-case-p_head & [CASE ga-or-wo].

empty-case-p_head := case-p_head  & [PTYPE empty].

; (MS & FCB 2003-10-29) added AUX aux_minus to get rid of spurious ambiguity in 普通 と 違っ て いる.
; (MS 2004-11-05) But now we don't get aspectual readings in 家から父が運んでいる . So, I take
; it out again.

postp_head := vmod-p_head-avm &
              [PTYPE overt,
	       MOD < [LOCAL [NUCL nucl_bool,
			     CAT.HEAD.AUX aux]] >,
               COP-ARG +].


; (MS & FCB 2003-10-29) added AUX aux_minus to get rid of spurious ambiguity in 普通 と 違っ て いる.
; (MS 2004-11-05) But now we don't get aspectual readings in 家で父が運んでいる . So, I take
; it out again.

adv-p_head := vmod-p_head-avm &
                [PTYPE overt,
		 MOD < [LOCAL [NUCL nucl_bool,
			       CAT.HEAD.AUX aux]] >,
                 COP-ARG -].


idiom_head :=  sentence-valid &
              [POS idiom,
               MOD null,
               C-MOD  < [LOCAL [CAT [HEAD sentence-valid & [MAIN-PRD +,
                                                       FIN +],
                                VAL saturated],
                            BAR +]] >,
               J-POSTHEAD left,
               MARK null,
               COP-ARG -,
               J-SPEC null].

sap_head := p_head-avm &
            [J-SPEC null,
             MARK null,
             MOD 0-1-list,
             SMOD marked,
             PTYPE sentence-particle,
             J-POSTHEAD left] .


; (MS 2005-05-17) This is not needed any more!
;sap1_head := p_head-avm &
;            [POS sap,
;             J-SPEC null,
;             MARK null,
;             MOD 0-1-list,
;             SMOD unmarked,
;             J-POSTHEAD left,
;             COP-ARG -] .

; (ERB 2001-09-06) Conjunctions should only modify finite sentences.

; (ERB 2002-01-07) They also have to be able to modify finite sentences
; like V-te + kudasai.  Adding a type utt-valid to describe this class.
; (was: C-MOD.LOCAL.CAT.HEAD sentence-valid).

; (ERB 2002-01-07) That doesn't give quite the right result because
; when the second conjunct is 〜ください, the message is already there
; and the message contributed by the conjunction is irrelevant.  A
; short-term solution is to make two kinds of conjunctions: those that
; are [C-MOD sentence-valid] and supply two messages and those that
; are [C-MOD s-end_head] and supply just one message.  In the long run,
; we might think about revamping the way messages are introduced.
; Also, we might worry some more about the relative scope of messages
; and the conj-rel in different constructions.
; (MS 2005-06-07) It seems that this one is never applied.
s-conj_head := sap_head &
               [MOD null,
		CASE con,
		COP-ARG -,
                C-MOD < [LOCAL [CAT [HEAD sentence-valid & [MAIN-PRD +,
                                                        FIN +,
                                                        SMOD unmarked],
                                 VAL saturated],
                            BAR +]] >,
                J-POSTHEAD left].

; (ERB 2002-01-07) Want this to apply to vn+kudasai as well, which is
; actually HEAD v-end_head.  So, change [HEAD s-end_head] to 
; [HEAD utt-valid & [SMOD marked]].  (utt-valid groups together 
; sentence-valid and s-end_head.
; (MS 2005-05-18) But this prevents "食べたから寝た" from parsing. So, I took the restriction out.

s-conj-nonprop_head := sap_head &
               [MOD null,
		COP-ARG -,
                C-MOD < [LOCAL [CAT [HEAD utt-valid & 
                                      [ FIN + ],
                                 VAL saturated],
                            BAR +]] >,
                J-POSTHEAD left].

; (ERB 2002-01-07) utt-valid groups together sentence-valid and
; s-end_head.  (Added for conjunction with non-propositional right
; conjuncts.)

s-end_head := sap_head & utt-valid.

s-end_head-avm := s-end_head &
              [MOD null,
               C-MOD null,
               J-POSTHEAD left].

interj_head :< final_head.

; (ERB 2001-12-10) These aren't doing anything semantically, so
; make them use the intersective head adj rule.

; (ERB 2001-12-10) Making them more like "well" and "so" in the LinGO
; grammar.  Among other things, this means they're scopal modifiers.

; (ERB 2001-12-10) The corresponding words in the LinGO grammar only
; attach to matrix sentences.  Try making these guys [MOD utt].  This
; would save us having to put in a message for the sentence they 
; attach to (can't tell what it will be anyway).  Should also force
; high attachment.

interj_head-avm := interj_head &
                   [POS interj,
                    J-SPEC null,
                    MARK null,
                    MOD < [LOCAL scopal_mod &
                                        [CAT.HEAD utterance_head]] >,
                    C-MOD null,
                    J-POSTHEAD left,
                    COP-ARG -].


excl_head := idiom_head &
             [J-SPEC null,
              MARK null].


det_head :< final_head.

det_head-avm := det_head &
            [POS det,
             MARK null,
	     KEYS.KEY def_rel,
             J-SPEC < [LOCAL [CAT.HEAD noun_head,
                                    BAR +],
                            MODIFIED.PERIPH bool] >,
             MOD null,
             C-MOD null,
             COP-ARG -].

; (MS 2002-04-17) DAI behaves like a definite determiner on counted nouns: 一本 - one book, 第一本 - the first book. 
; I've thus made it a determiner that specifies counted nouns. 
; I could not think of a solution that changes the card-rel to ord-rel, though.


card2ord_head-avm := det_head &
		     [POS det,
		      MARK null,
		      J-SPEC < [LOCAL [CAT.HEAD noun_head,
				       BAR +],
				LKEYS.KEYREL reg-nom-relation,
				MODIFIED.PERIPH bool] >,
		      MOD null,
		      C-MOD null,
		      COP-ARG -].


vn_head :< verb-noninfl_head-avm.

; (ERB 2001-09-03) If I want the vn-light verb combination to be done via the
; head-spr rule, I need VNs to have a compatible J-SPEC value.

; (ERB 2001-09-19) I'm trying to keep the output of v2vn-infl-rule
; from being the complement of nspec-no-3, which is supposed to attach
; to te forms.  So as a first pass, I'm going to say that all vns
; are [H-TENSE no_tense].  This also requires a change to light verbs.

; (MS 2001-11-22) I take the MODUS indicative restriction out in order to allow VNs to combine with light verbs in, e.g., potential mode.

; (ERB 2001-12-28) For VN + itadaku, these can't be J-SPEC null, if that combination
; is to happen via the head-spr rule.  Try J-SPEC ... HEAD aux-stem_head

; (ERB 2002-01-02) That's overly restrictive if VN + kudasai is vn-vend-rule
; (subtype of head-spr rule).  Try J-SPEC ... HEAD verb_head, and hope it doesn't
; overgenerate.

; (ERB 2002-01-02) It does over generate, since suru is also looking for a
; vn specifier.  Try adding constraint [LIGHT -].  (Assumes that the
; vn-light-rule doesn't check the J-SPEC value of the VN.)

; (MS 2002-02-08) Took the HEAD restriction out. Then, also VNs can be specifiers of 
; nominalizations as in "変更届けを提出済ですが".

vn_head-avm := vn_head &
           [MOD null,
            C-MOD null,
            MODUS mood,
            FIN -,
            VN +,
            J-SPEC.FIRST.LOCAL.CAT.HEAD [LIGHT -],
            MARK < [LOCAL [CAT.HEAD verb_head,
                                  BAR +]] >,
            COP-ARG -].

; (ERB 2001-09-03) Can't require HEAD light-verb_head of J-SPEC value because
; that's MOD none, but the inflected light verb is MOD synsem.


i-adj_head := verb_head-avm &
              [VN -,
               C-MOD null,
               AUX aux_minus,
               COP -,
               LIGHT -,
               ADJ +,
               J-POSTHEAD rels,
               COP-ARG -].


; (MS 2002-1-7) This should have an ADJ +, shouldn't it?
; (MS 2002-1-15) changed the J-SPEC from verbend_head-unmarked to verbend_head, otherwise 小さかった wouldn't parse.
; (MS 2002-12-04) Took the J-SPEC value out. Otherwise, 小さいこと would not parse.

i-adj-stem_head :=  other-verb-stem_head &
                   [ADJ +].
                                                  
adj_head := adj-or-adv_head & [COP-ARG -].


na-adj_head  := adj_head &
              [C-MOD null,
               MARK null].

na-adj-basic_head := na-adj_head & [ADJ +,POS adj].

;na-adj-suffix_head := na-adj-basic_head & [MOD < [LOCAL intersective_mod & 
;							[CAT [HEAD ordinary_noun_head,
;							      VAL saturated]]] >,
;					   J-POSTHEAD left].

na-adj-end_head := na-adj_head & verbend_head-unmarked & [POS adj,
							  MOD null,
							  J-SPEC.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2005-03-30) This seems not to be used any more.
;exceptional-adj_head := adj_head &
;                        [MOD < [LOCAL.CAT.HEAD ordinary_noun_head ] >,
;                         POS adj,
;                         J-SPEC null,
;                         MARK null].

; (ERB 2001-01-02) [MOD ... NUCL +] is too restrictive if
; we want head-adjunct rules to be [NUCL -] on the mother.
; This may have been there to restrict ambiguity, but I think
; the ambiguity is probably valid.

; (ERB 2002-01-22) On the other hand, we really don't want adverbs
; attaching wrt to the conj-rule.  So require [NUCL nucl_bool].

; (MS 2002-06-19) Sometimes we want to allow attachements of adverbs on lower verbs. 
;  I thus take the MAIN-PRD + restriction on the modified item out.
;  "税金の項目を申告でなく源泉にしたいのですが"

adv_head := adj-or-adv_head &
            [POS adv,
             J-SPEC null,
             MARK null,
             C-MOD null].


; (MS 2004-11-05) erased AUX aux_minus on the modified to account for aspectual reading
; of また彼が帰って来る


adv_head-avm := adv_head &
            [KEYS.KEY adv_rel,
	     MOD < [LOCAL [CAT.HEAD sentence-valid]] >,
	     H-TENSE present].

case-adv_head := adv_head &
            [MOD < >].

hes_head :< final_head.

hes_head-avm := hes_head &
            [POS hes,
             J-SPEC null,
             MARK null,
             MOD < [LOCAL.CAT [HEAD ordinary_noun_head,
			       VAL saturated]] >,
             C-MOD null,
             J-POSTHEAD right,
             COP-ARG -].


;dai ichi kibou

; (ERB 2001-08-06) Redoing the numbers following Jeff Smith's analysis
; of English number names.

; (ERB 2001-08-06) Numbers don't modify anything.  They will be SPRs
; of numeral classifiers and other elements.

; (ERB 2001-08-20) Adding a feature [ST-ALONE bool] (for "stand-alone")
; to express the fact that when sen takes ichi as its SPR, it can't
; be the head of the thing that NumCl select.  (And especially not with
; the NumCl 年).

; (ERB 2001-10-29) int_head should be COP-ARG -, as integers
; themselves can't be predicative (they need to be promoted first).
; (Was COP-ARG +.)

int_head := init_head &
           [ ST-ALONE bool,
             POS card,
             C-MOD null,
             J-POSTHEAD left,
             MARK null,
             J-SPEC 1-list,
             COP-ARG -].

int_head-avm := int_head &
                [MOD null].

; (ERB 2001-08-06) Subtypes of int_head for subcategorization of SPR and COMPS
; inside number names.  Names of the form intk- mean "int_head with k or fewer
; digits".

; (ERB 2001-08-21) Adding subtypes for XDigitErsatz that don't correspond
; to types that are already there.

; (ERB 2004-1-18) Need a special type for 何 in num cl phrases,
; so that it's an integer but can't be selected by anything else.

nan_int :< int_head-avm.

int21 :< int_head-avm.
int17- :< int_head-avm.
int17 :< int17-.
int13- :< int17-.
; (ERB 2001-08-21) For ThirteenPlusDigitErsatz
int13x :< int13-.
int13 :< int13-.
int9- :< int13-.
; (ERB 2001-08-21) For Nine-TwelveDigitErsatz
int9x :< int9-.
int9  :< int9-.
int5- :< int9-.
; (ERB 2001-08-06) For Six-EightDigitErsatz
int5x :< int5-.
int5  :< int5-.
int4x :< int5-.
int4z :< int4x.
int4- :< int4x.
int4  :< int4-.
int3- :< int4-.
int3  :< int3-.
int2- :< int3-.
int2  :< int2-.

; (ERB 2001-08-06)Need a type "1 or fewer digits" because ichi is special: It
; behaves like the other one digit numbers when it's a complement, but
; differently in specifier position (juu and hyaku won't take it as a
; specifier).

int1- :< int2-.
int1  :< int1-.
int_ichi :< int1-.

; (ERB 2001-12-05) Need a special head type for 半 because it has a very
; restricted distribution.  (Chasen calls it a 名詞-接尾-一般+n-n.  Although
; an inflectional rule analysis isn't implausible, I'm going to stick
; with a syntactic analysis of things like 年半 in 二年半 for now.)

han_head := final_head &
            [ MOD null,
              C-MOD null,
              J-SPEC null ].

grad_head := final_head.

grad_head-avm := grad_head &
                 [POS adv,
                  MARK null,
                  MOD 1-list,
                  C-MOD null,
                  J-POSTHEAD left,
                  J-SPEC null,
                  COP-ARG -].

;;;;;;;;;;;;;;;;;;SUBCATEGORIZATION - others;;;;;;;;;;;;;;;;;;;;;;;;;;


spr-arg := j-valence &
              [SPR 1-list,
	       SUBJ null,
	       COMPS null].



spr-obj-arg := j-valence &
               [SPR 1-list,
		SUBJ null,
		COMPS 1-list].

obj-arg := j-valence &
               [SPR null,
		SUBJ null,
		COMPS 1-list].

obj-obj2-arg := j-valence &
               [SPR null,
                SUBJ null,
		COMPS 2-comps-list].

sbj-arg := j-valence &
               [SPR null,
		SUBJ opt-1-arg,
		COMPS null].


; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

sbj-obj-arg := j-valence &
               [SPR null,
		SUBJ opt-1-arg,
		COMPS 1-list].


sbj-obj-obj2-arg := j-valence &
               [SPR null,
		SUBJ opt-1-arg,
		COMPS 2-comps-list].

sbj-spr-arg  := j-valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS null].

;(MS 2002-11-18) This one is needed for subject raising, if the subject could also have been deleted.

sbj-or-not-spr-arg  := j-valence &
		[SPR 1-list,
		 SUBJ 0-1-list,
		 COMPS null].

sbj-obj-spr-arg  := j-valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 1-list].

sbj-obj-or-not-spr-arg := j-valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 0-1-list].

sbj-obj-obj2-spr-arg := j-valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 2-comps-list].

; (MS 2003-10-05) insert a quant-relation that introduces the attributes,
;  while the _rel is a sort, says Dan.


noun_sc  :=  spr-arg &
             [SPR opt-1-arg & 
		  < [LOCAL [CAT.HEAD det_head,
			    CONT det-sem-type]] >].



temp_noun_sc  :=  spr-obj-arg &
             [SPR opt-1-arg & 
		  < [LOCAL.CAT.HEAD det_head] >,
	      COMPS opt-1-arg & 
		  <[LOCAL [CAT.HEAD case-p_head & [CASE temp-no]]] >].


title_sc  :=  spr-arg &
             [SPR < [LOCAL [CAT [HEAD noun_head,
				 VAL saturated]]] >].

loc-title_sc := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT [HEAD loc_name_head,
				    VAL saturated]]] >].


p_sat :=  obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL.CAT.VAL saturated] >].


kara-made_sc :=  obj-obj2-arg &
                 [COMPS obl-2-args &
			< j-synsem & [LOCAL.CAT [HEAD noun_head,
					       VAL saturated]],
			  j-synsem & [LOCAL.CAT.HEAD case-p_head & [PTYPE kara]] >].


nom_sc :=  spr-arg &
           [SPR obl-1-arg].

subcategorizing-noun_sc := spr-obj-arg &
                           [COMPS obl-1-arg &
				  < [LOCAL.CAT.VAL saturated] >,
			    SPR opt-1-arg &
				  < [LOCAL [CAT.HEAD det_head,
					    CONT det-sem-type]] > ].

; (MS 2004-08-25) Topics and colons should be allowed as arguments.
; This is why I changed the CASE to ga-or-coparg.

adj_sc := sbj-arg &
           [SUBJ.FIRST [LOCAL.CAT.HEAD case-p_head & [CASE ga-or-coparg]] ].


eval-adj_sc := obj-arg &
	       [COMPS < [LOCAL [CAT [HEAD [FORMAL.AHON -],
				     VAL saturated],
				BAR +]] > ].


;;; (AO 2003-09-04) MS patch for expressions like "... de, ..." in japanese dictionaries.
; (MS 2004-06-25) The restriction on EMPTY - is not useful. It prevents the parsing of, e.g.
; 子供は学生と大人が先生だ。
; (MS 2005-05-17) Trying to put sentence particles into the type hierarchy of particles.

sap_sc := p_sat &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT [HEAD sentence-valid & 
					   [MODUS uttmodus,
					    MAIN-PRD +],
				      VAL saturated],
				 BAR +],
			  MODIFIED hasmod] > ].

; (ERB 2001-12-28) For kudasai on VNs.

sap-restricted_sc := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT [HEAD vn_head,
					   VAL saturated],
				      BAR +]] > ].

desu-sap_sc := sap_sc & 
               [COMPS < [LOCAL.CAT.HEAD verb_head & [COP -, VN -]] > ].



             

;;;;;;;;;;;;SUBCATEGORIZATION - verbs;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




ga-wo_transitive := sbj-obj-arg &
                     [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                           COMPS opt-1-arg &
			   < [LOCAL.CAT.HEAD case-p_head & [CASE wo]] >].


; (SF 2003)
; (MS 2003-12-23) This seems not to be used.
;ni-ga_transitive := sbj-obj-arg &
;                     [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >,
;                           COMPS opt-1-arg &
;			   < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

ga-ni_transitive := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                          COMPS < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] > ].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

naru_adv_transitive := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
		     COMPS obl-1-arg &
			   < [LOCAL.CAT.HEAD adv_head] >].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.
; (FCB 2005-03-22) removed this as we now treat the ni-or-to as optional

; naru_noun_transitive :=  sbj-obj-arg &
;                     [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
;                           COMPS obl-1-arg &
; 			  < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] > ].

; (FCB and CH 2005-034-12) for complement suru 
; (do-parse-tty "彼 が 鈍 を 銀 に し た") "he made lead into silver"
; FIXME now also parses  (do-parse-tty "彼 が 鈍 を とても し た") 
; need to distinguish 綺麗に/美しく from real adverbs
suru_noun_ditransitive :=  sbj-obj-obj2-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS
			  < [OPT + ,
			     LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]], 
			    [OPT -,
			     LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].

suru_adv_ditransitive :=  sbj-obj-obj2-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS
			  < [OPT + ,
			     LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]], 
			    [OPT -,
			     LOCAL.CAT.HEAD adv_head] >].


ga-to_transitive1 := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
                          COMPS  obl-1-arg &
			  < [LOCAL.CAT.HEAD case-p_head & [CASE to]] > ].

ga-to_transitive2 := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                          COMPS opt-1-arg & 
			  < [LOCAL.CAT.HEAD  case-p_head & [CASE to]] >].


ga-to-ni_transitive1 := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS opt-1-arg & 
			  < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].

ga-to-ni_transitive2 := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS obl-1-arg & 
			  < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].



intransitive := sbj-arg &
                [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].


to_intransitive-opt := obj-arg &
                [COMPS opt-1-arg & 
			  < [LOCAL.CAT.HEAD case-p_head & [CASE to]] >].


to_intransitive-obl := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL.CAT.HEAD case-p_head & [CASE to]] >].


ditransitive :=  sbj-obj-obj2-arg &
                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		  COMPS opt-2-args &
		       < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
			  [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].

; (MS 2004-11-15) This seems not to be used any more.

;ga-wo-to-ditransitive := sbj-obj-obj2-arg  &
;                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
;		  COMPS < [OPT + ,
;			   LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
;			  [OPT - ,
;			   LOCAL.CAT.HEAD case-p_head & [CASE to]] >].

ga-wo-toni-ditransitive := sbj-obj-obj2-arg  &
                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		  COMPS < [OPT + ,
			   LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
			  [OPT + ,
			   LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].


; (MS 2003-12-23) Added CASE ni-or-ga for, e.g., ni - ga wakaru.

mental_state_transitive :=  sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-ga]] >,
		     COMPS opt-1-arg &
			  < [LOCAL.CAT.HEAD case-p_head & [CASE ga-or-wo]] >].

aru_transitive :=  sbj-arg &
           [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].

cop_transitive := obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL [BAR +,
			   CAT [HEAD [COP-ARG +,MAIN-PRD -],
				VAL saturated]]] > ].


; (MS 2004-11-30) If the VAL of the na-adj is restricted to be saturated, 
; the relative-clause-gap-rules cannot be applied. Rather, the cop-sem should 
; take the subject of the nad-adj.

cop-stem_transitive := sbj-obj-arg &
                       [SUBJ #sbjval,
			COMPS obl-1-arg &
			      < [LOCAL [BAR +,
					     CAT [HEAD na-adj_head,
						  VAL.SUBJ #sbjval]]] > ].


; (ERB 2001-09-24) Experimenting with removing [BAR +] constraint
; on OBJ to allow Ns built out of NumClPs to be OBJ of id-cop desu
; and allow them as dtrs in compounds.

cop-id_transitive := sbj-obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL [CAT [HEAD noun_head,
				     VAL saturated]]] >,
		SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga-or-coparg]] > ].


; (ERB 2001-09-03) Changing light verbs to make them in charge of the
; j-valence of the vn+light verb combination.
; (MS 2001-09-14) Changing that back.
; (MS 2002-11-11) This one is going to be interesting!

light_transitive := j-valence &
            [SPR  obl-1-arg &
		 < [LOCAL [CAT [HEAD vn_head & [MAIN-PRD -],
				 VAL [SUBJ #sbj,
				      COMPS #comps]],
			    BAR -]] >,
	     SUBJ #sbj,
	     COMPS #comps].



; (MS 2004-11-18) Type for obj-id. The comps list of the specifier should be emptied.
; 私 が 先生 に 本 を 買っ て もらっ た

aux_transitive  :=  sbj-obj-spr-arg & 
          [SPR obl-1-arg &
	       < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
						 COP -,
						 VN -,
						 AUX aux_minus],
			      VAL [COMPS null]],
			 CONT.HOOK.XARG #ind,
			 NUCL nucl_plus]] >,
	   COMPS < [OPT + ,
		    LOCAL [CAT.HEAD case-p_head & [CASE ni],
			   CONT.HOOK.INDEX #ind]] >,
	   SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] > ].


; (ERB 2001-12-28) For VN + itadaku, etc.

light-aux_transitive  :=  j-valence & 
          [SPR obl-1-arg &
	       < [LOCAL [CAT [HEAD  vn_head & [MAIN-PRD -],
			     VAL [COMPS < #obj >,
				   SUBJ #subj]],
			 CONT.HOOK.XARG #arg1ind,
			 NUCL nucl_plus]]>,
	   COMPS < #obj,
		   [OPT + ,
		    LOCAL [CAT.HEAD case-p_head & [CASE ni],
			   CONT.HOOK.INDEX #arg1ind]] >,
	   SUBJ #subj].


; (MS 2004-06-25) Took the COMPS null restriction out to allow the rel-clause-obj-gap-rule to apply.
; And then took over the COMPS value from the verb to the auxiliary.
; (MS 2004-07-09) FORMAL.AHON - restriction on the SPR, to rule out "mashite"
; (MS 2004-11-05) AUX aux_minus on the specifier might be too strong: 読んでもらっている
; (MS 2004-11-17) This is valid for pure-aspect.
; (CH 2005-03-18)
; added [SPR.FIRST.LOCAL.CAT.HEAD.MOD null] to disallow te-adjunct
; in the SPR.
; 「で」 in 「読んでいる」 should be te-end-lex rather than te-adjunct.
pure-aspect_transitive :=  j-valence & 
 [SPR obl-1-arg &
      < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
					COP -,
					MOD null,
					VN -,
					AUX aux_minus_or_complex,
					FORMAL.AHON -],
		     VAL  [SUBJ  #sbj,
			   COMPS #obj]],
		NUCL nucl_plus]] >,
  SUBJ #sbj,
  COMPS #obj].

; (MS 2004-11-17) In aspect_transitive, we need to link the ARG2 of the verb to the ARG1 of
; the aspect aux.
 
aspect_transitive :=  sbj-spr-arg & 
                      [SPR obl-1-arg &
			   < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
							     COP -,
							     VN -,
							     AUX aux_minus_or_complex,
							     FORMAL.AHON -]],
				     NUCL nucl_plus]] >,
		       SUBJ  < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] > ].


 
perspective_transitive  :=  sbj-obj-spr-arg & 
                            [SPR obl-1-arg &
				 < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
									COP -,
									VN -,
									AUX aux_minus],
						VAL [SUBJ #sbj,
						     COMPS null]]]] >,
			     SUBJ #sbj,
			     COMPS opt-1-arg &
				 < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].

; (ERB 2001-12-28) For VN + kureru etc.

light-perspective_transitive  :=  sbj-obj-spr-arg & 
				  [SPR obl-1-arg &
				 < [LOCAL [CAT [HEAD  vn_head & [MAIN-PRD -],
						      VAL [SUBJ < #sbjval >]],
						 BAR +]] >,
				   SUBJ < #sbjval  & [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
				   COMPS opt-1-arg &
				       < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].





sbj-narg_transitive := sbj-obj-arg & 
          [COMPS obl-1-arg &
		 < [LOCAL [CAT [HEAD noun_head,
				     VAL saturated]]] >,
                SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].
		       
                                 
    
;;;;;;;;;;;;;;LEXICAL TYPE -- unknown words;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

my_unknown_word := lexical_sign.

my_unknown_noun := my_unknown_word & ordinary-n-lex.

my_unknown_vn := my_unknown_word & vn-trans1-lex.

;;;;;;;;;;;;;;LEXICAL TYPES -- particles;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (ERB 2001-10-17) Some p-lex identify their KEY with their OBJ's
; and some don't, do I can't make the whole class lexical_sign-word.
; I'm going to make p-lex lexical_sign and make the subtypes that
; don't do key identification more specific.

p-lex := lexical_sign & 
         [SYNSEM [LOCAL [CAT [HEAD p_head-avm & [FORMAL.SHON #1, QUANTIFIABLE #2],
                              VAL p_sat & [COMPS #comps & < [LOCAL [CAT.HEAD [FORMAL.SHON #1,
									      QUANTIFIABLE #2],
								    CONT.HOOK.INDEX #ind]] >]],
                         CTXT.BACKGROUND <! !>,
			 CONT [HOOK.XARG #ind],
                         BAR +,
			 ARG-S #comps],
                  NON-LOCAL [QUE <! !>,
                          AFFIX <! !>]],
          INFLECTED +].


; (ERB 2001-10-17) This is the supertype for p-lex's that don't
; identify their KEY with their OBJ's KEY.  Name means p-lex-contentful.

p-lex-c := p-lex & lexical_sign-word.

; (ERB 2001-11-26) Identification of CONT.KEY.HANDEl and LTOP is
; redundant, since both LTOP and KEY are coming from the complement.
; Also, adding MOD-IND and MOD-HAND to info that gets raised.

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND

; (MS 2005-06-20) FORMAL should come from the complement.


case-p-lex := p-lex & 
            [SYNSEM [LOCAL [CAT [HEAD overt-case-p_head & [FORMAL #formal],
                                VAL.COMPS < [LOCAL [CAT.HEAD.FORMAL #formal,
						    CONT [HOOK [INDEX #arg, 
								LTOP #hand]]]] >],
                           CONT [HOOK [INDEX #arg, 
				       LTOP #hand],
                                 RELS <! !>,
                                 HCONS <! !>]]]].

; (MS 2005-05-06) renamed ga-wo-ni-p-lex (cleaning up particles).

case-p-lex-np := case-p-lex & 
                  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head].

; (MS 2005-11-10) getting rid of skip files.


case-p-lex-np-coparg := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE coparg].

case-p-lex-np-ga := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ga].

case-p-lex-np-wo := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE wo].

case-p-lex-np-to := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE to].

case-p-lex-np-kara := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE kara-case].

case-p-lex-np-ni := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ni].

case-p-lex-np-no := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE no-case].

; (MS 2005-05-11) This is the topic marker that replaces case particles,
; such that we have massive ambiguity whenever case particles occur. 

case-p-lex-np-topic := case-p-lex-np &
		       [SYNSEM [LOCAL.CAT.HEAD.PTYPE wa,
				NON-LOCAL.UNDERSPEC_ARG -]].

; (MS 2005-05-13) It sets empathy to the entity it attaches to.

case-p-lex-np-topic-ga := case-p-lex-np-topic &
		       [SYNSEM.LOCAL [CAT.HEAD.CASE ga,
				      CONT.HOOK.XARG #emp,
				      CTXT.EMPATHY.EMPEE #emp]].

; (MS 2005-09-22) It sets empathy to the entity it attaches to, only
; when it is case ga! If it is a case of object topicalization, the 
; empathy is rather set to the sentence subject (see Watanabe 2000)

case-p-lex-np-topic-wo := case-p-lex-np-topic &
		       [SYNSEM.LOCAL.CAT.HEAD.CASE wo].

; (MS 2005-04-07) It seems that we don't need these any more.
; adverb +  case particle is elliptical or ungrammatical, as the NTT
; people say.

;ga-wo-ni-p-lex-2 := case-p-lex & 
;                  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [CAT.HEAD adv_head,
;							   CONT.HOOK.INDEX event]].

;(MS 2002-1-7) restricted this to postpositions, in order to keep NO GA out.
; (MS 2004-06-25) INDEX and XARG must be the same, otherwise the phrase cannot be selected for.
; (MS 2005-05-06) renamed ga-wo-ni-p-lex-3 (cleaning up particles).

case-p-lex-postp := case-p-lex & 
 [SYNSEM.LOCAL [CONT.HOOK.INDEX #ind,
		CAT.VAL.COMPS.FIRST.LOCAL [CONT.HOOK.XARG #ind,
					   CAT.HEAD postp_head & [PTYPE nontop,
								  CASE mod]]]].

case-p-lex-postp-ga := case-p-lex-postp &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ga].

case-p-lex-postp-wo := case-p-lex-postp &
			[SYNSEM.LOCAL.CAT.HEAD.CASE wo].

case-p-lex-postp-ni := case-p-lex-postp &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ni].


; (MS 2005-05-06) renamed to-case-lex (cleaning up particles).
; BUT I really don't know what this is for. Commented it out until
; I can find a good example.
;case-p-lex-vmodp := case-p-lex & 
;                  [SYNSEM.LOCAL [CONT.HOOK.INDEX #ind,
;				 CAT.VAL.COMPS.FIRST.LOCAL [CONT.HOOK.XARG #ind,
;							    CAT.HEAD vmod-p_head & [PTYPE nontop]]]].

; "何日くらいかかるかを教える"
; (MS 2003-12-19) Matrix 0.6
; (MS 2005-05-06) This is rather a complementizer. Took that out and gave the o-4 the type
; comp-prpstn-lex.
;ga-wo-ni-p-lex-4 := comp-prpstn-lex &
;		    [SYNSEM.LOCAL [CAT [HEAD case-p_head,
;					VAL.COMPS.FIRST [LOCAL [CONT.HOOK.LTOP #ohand,
;								CAT.VAL saturated]]],
;                          CONT [RELS <! message &
;				      [PRED proposition_m_rel,
;				       LBL #chand,
;				       MARG #soa] !>,
;                                HOOK.LTOP #chand,
;                                HCONS <! qeq & [LARG #ohand,
;                                                 HARG #soa] !>]]].


; (MS 2005-05-06) We seem not to need this any more, as the ni-case-5 is replaced with
; naadj2adv-end-lex.
;ga-wo-ni-p-lex-5 := case-p-lex & 
;                  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2005-05-06) renamed particles (case-p-lex-np and case-p-lex-vmodp).
;to-case-lex :< case-p-lex.

; (ERB 2002-02-14) This should take the LTOP of its OBJ for the LARG
; handle, not KEY.LBL.  (Problem was embedded conjoined sentences where
; KEY comes from right conjunct, but LTOP comes from conjunction.)
; (FCB 2005-06-27) Added ARG0 to message

comp-lex := p-lex-c &
 [SYNSEM.LOCAL [CAT [HEAD case-p_head & [CASE to],
		     VAL.COMPS.FIRST.LOCAL.CONT.HOOK [LTOP #ohand,
					INDEX #index]],
		CONT [RELS  <! message & [LBL #chand,
					  ARG0 #index,
					  MARG #soa] !>,
		      HOOK.LTOP #chand,
		      HCONS <! qeq & [LARG #ohand,
				      HARG #soa] !>]]].

comp-prpstn-lex := comp-lex &
                   [SYNSEM.LOCAL.CONT.RELS <! message & [PRED proposition_m_rel] !>].

; (MS 2005-11-10) getting rid of skip files.

comp-prpstn-lex-sentarg := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD sentence-valid].

comp-prpstn-lex-naarg := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].


comp-prpstn-lex-questarg := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD sap_head & [SMOD quest]].

comp-prpstn-lex-questarg-to := comp-prpstn-lex-questarg &
			       [SYNSEM.LOCAL.CAT.HEAD.CASE to].

comp-prpstn-lex-quotarg := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD quotation-sentence-end_head].

comp-prpstn-lex-varg := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT [HEAD.CASE to,
					      VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [VN -,
											 MAIN-PRD -]]].

comp-prpstn-lex-quot := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.CASE to].

; (MS 2005-05-09) I don't see why we need this: a copula is inserted
; even with the comp-prpstn-lex.
;comp-copinsert-lex := p-lex-c &
;            [SYNSEM [LOCAL [CAT [HEAD case-p_head & [CASE to],
;                                VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
;						       CONT.HOOK [INDEX #oind]]],
;                          CONT [RELS <! message & #key & [LBL #phand,
;							  MARG #soa], 
;				            [PRED 'cop_id_rel,
;					     ARG2 #oind,
;					     LBL #cophand] !>,
;                                HOOK.LTOP #phand,
;                                HCONS <! qeq & [LARG #cophand,
;                                                 HARG #soa] !>]],
;		     LKEYS.KEYREL #key]].

; (ERB 2002-02-11) Hack to keep these guys out of the orindary
; head-complement-hf rule, now that I've made the embedded-question-rule
; a binary rule (see notes at embedded-question-rule-type):  Make
; them be MSG.LIST nelist, while hcomp-hf requires MSG.LIST elist.
; In the long run, the right analysis probably involves revamping the
; analysis of clauses in this grammar so that we can have a better theory
; of embedded clause types.  That overhaul will cause this hack to no
; longer work, but it should also render it unnecessary.

comp-int-lex := comp-lex &
                [SYNSEM.LOCAL [CONT [MSG message,
				     RELS <! [PRED question_m_rel] !>]]].

; (MS 2005-11-10) getting rid of skip files.

comp-int-lex-varg := comp-int-lex &
		     [SYNSEM.LOCAL.CAT [HEAD.CASE to,
					VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [MAIN-PRD -]]].

comp-int-lex-naarg := comp-int-lex &
		     [SYNSEM.LOCAL.CAT [HEAD.CASE to,
					VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head]].

comp-int-lex-nonquest := comp-int-lex &
		     [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.QUE <! !>].

comp-int-lex-naarg-nonquest := comp-int-lex-naarg & comp-int-lex-nonquest.

comp-int-lex-varg-nonquest := comp-int-lex-varg & comp-int-lex-nonquest.

comp-int-lex-unmarked := comp-int-lex &
			 [SYNSEM.LOCAL.CAT [HEAD.CASE to,
					    VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [SMOD unmarked]]].





; (MS 2003-12-19) Matrix 0.6
; (MS 2005-11-09) These all have PTYPE nattr.

nspec-p-lex  :=  p-lex-c & 
                 [SYNSEM [LKEYS.KEYREL #key,
			  LOCAL [CAT [HEAD nspec-p_head & [J-SPEC.FIRST [LOCAL.CONT.HOOK [INDEX #i,
											  LTOP #h]],
							   PTYPE nattr],
				      VAL.COMPS.FIRST.LOCAL [CONT [HOOK.INDEX #arg],
							     CAT.VAL saturated]],
				
				     CONT [HOOK.INDEX #arg,
					   RELS <! #key & quant-relation & [PRED udef_rel,
                                                                   ARG0 #i,
                                                                   RSTR #restr]!>,
					   HCONS <! qeq &
						  [HARG #restr,
						   LARG #h] !>]]]].

; (MS 2005-11-09) Getting rid of skip files.

nspec-p-nouncomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head].

nspec-p-pcomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD postp_head].

nspec-p-vcomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & 
									 [H-TENSE te,
									  VN -]].



; (ERB 2001-11-28) Making all Ps intersective modifiers.

mod-p-lex :=  p-lex-c & 
            [SYNSEM.LOCAL.CAT.HEAD mod-p_head-avm &
				   [ MOD < [LOCAL intersective_mod] > ]].


nmod-p-lex :=  mod-p-lex & 
            [SYNSEM [LOCAL.CAT.HEAD overt-nmod-p_head,
                     MODIFIED.PERIPH -]].

; (MS 2005-11-09) Getting rid of skip files.

nmod-p-lex-pconj := nmod-p-lex &
            [SYNSEM [LOCAL [CAT [HEAD [MOD < [LOCAL.CONT [HOOK.INDEX #mod]] >,
				       J-POSTHEAD left],
				 VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD p_head & [PTYPE nontop,
										     CASE mod],
								  CONT [HOOK.INDEX #arg]]]],
                           CONT n-conj-sem-type],
		     LKEYS [KEYREL [L-INDEX #arg,
				    R-INDEX #mod]]]].


;(MS 2005-05-14) This is not used any more. The parentheses do not build the heads.
;parmod-p-lex :=  mod-p-lex & 
;            [SYNSEM [LOCAL.CAT.HEAD nmod-p_head-avm & [MOD < [LOCAL.CAT [HEAD brackets-or-quotations-end_head,
;									 VAL saturated]] > ],
;                     MODIFIED.PERIPH +]].



conj-lex := p-lex-c &
              [SYNSEM [LOCAL [CAT.HEAD n_conj_head],
		       MODIFIED.PERIPH +]].

; (ERB 2001-11-26) Changing modifiers to grab MOD-IND & MOD-HAND.
; (MS 2004-12-15) Changing that back!

nounmod-p-lex := nmod-p-lex &
                 [SYNSEM [LKEYS.KEYREL #key & prep-mod-relation &
					  [ARG2 #mod,
					   ARG0.E.TENSE no_tense,
					   LBL #handle,
					   ARG1 #arg],
			  LOCAL [CAT [HEAD.MOD < [LOCAL.CONT.HOOK [INDEX #mod,
								   LTOP #handle]] >,
				      VAL.COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #arg]],
				 CONT prep-sem-type &
				     [RELS <! #key !>,
				      HOOK.INDEX #mod,
				      HCONS <! !>]]]].

;(MS 2005-11-09) Getting rid of skip files.

nounmod-p-vcomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head].

nounmod-p-vcomp-quest-lex := nounmod-p-vcomp-lex &
		       [SYNSEM.LOCAL [CAT.VAL.COMPS.FIRST [LOCAL.CAT.HEAD [MODUS uttmodus,
									   FIN +,
									   FORMAL.AHON -,
									   MAIN-PRD +],
							   NON-LOCAL.QUE <! #top !>],
				      CONT.HOOK.LTOP #top]].

nounmod-p-vcomp-prepmod-lex := nounmod-p-vcomp-lex &
			       [SYNSEM.LKEYS.KEYREL prep-mod-relation].

nounmod-p-ncomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST synsem & [LOCAL.CAT.HEAD noun_head]].

nounmod-p-ncomp-prepmodrel-lex := nounmod-p-ncomp-lex &
			     [SYNSEM.LKEYS.KEYREL prep-mod-relation].

nounmod-p-ncomp-vnmod-lex := nounmod-p-ncomp-lex &
			     [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD.VN +] >,
				      LKEYS.KEYREL prep-mod-relation]].

nounmod-p-ncomp-relmod-lex := nounmod-p-ncomp-lex &
			     [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD relational_noun_head] >,
				      LKEYS.KEYREL prep-mod-relation]].

nounmod-p-exc-ncomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL.CAT.HEAD exceptional_noun_head]]].


nounmod-p-ncomp-plusbar-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD noun_head,
									   BAR +]]]].

nounmod-p-intcomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD int_head,
									   BAR +]]]].

nounmod-p-pcomp-lex := nounmod-p-lex &
		       [SYNSEM [LOCAL [CAT [HEAD.PTYPE nattr,
					    VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD vmod-p_head  & [PTYPE nontop],
									     CONT.HOOK.XARG #1,
									     BAR +]]],
				       CONT.RELS <! prep-mod-relation & [PRED '_no_p_rel] !>],
				LKEYS.KEYREL.ARG1 #1]].



;(MS 2005-05-14) This is not used any more. The parentheses do not build the heads.

;parentmod-p-lex := parmod-p-lex &
;                 [SYNSEM [LKEYS.KEYREL #key & prep-mod-relation &
;                                         [ARG2 #mod, 
;					  ARG0.E.TENSE no_tense,
;                                          LBL #handle,
;                                          ARG1 #arg],
;			  LOCAL [CAT [HEAD.MOD <[LOCAL.CONT.HOOK [INDEX #mod,
;								  LTOP #handle]]>,
;				      VAL.COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #arg]],
;				 CONT prep-sem-type &
;				     [RELS.LIST.FIRST #key,
;				      HOOK.INDEX #mod,
;				      HCONS <! !>]]]].

; (ERB 2001-08-09) Type for the "no" that connects NumClP to nouns
; (ERB 2001-11-28) Replace INDEX and LTOP with MOD-IND and MOD-HAND.
; (MS 2002-09-10) This should also hold for "〜".
; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (MS 2004-12-27) Work on floated numeral classifiers
; (MS 2005-01-07) Using EMPTY to prevent floated quantifiers to go into the nominal-numcl-rule.

nmod-numcl-p-lex := nmod-p-lex &
[ SYNSEM.LOCAL [ CAT [ VAL.COMPS.FIRST.LOCAL.CAT.HEAD num-cl-mod_head &
                                                     [ MOD < [LOCAL [CONT.HOOK [ XARG #xarg,
										 INDEX #modind,
										 LTOP #hand ] ]] >,
						       EMPTY +],
                       HEAD [ MOD < [ LOCAL.CONT.HOOK [INDEX #modind,
						       LTOP #hand ] ,
                                    MODIFIED.PERIPH + ]>,
                              PTYPE overt,
                              J-SPEC null ]],
                 CONT [ HOOK.XARG #xarg,
			RELS <! !>,
                        HCONS <! !> ]]].
                       
; (ERB 2001-09-03) Adding constraint that the INDEX of vmod-p-lex be
; the same as the MOD...INDEX.

; (ERB 2001-09-03) If the topic relation is to take an event as the
; value of ARG2, it can't inherit this constraint on the sem type.
; So, I'll create a super type that does contain all the constraints
; that topic particles have in common with other vmod ps.  It also
; can't inherit the constraint that it's getting the ARG2 value from
; it's object's INDEX.

; (ERB 2001-09-06) We decided that topic shouldn't take an ARG2 at all.
; But that still means it can't inherit the constraint on the sem type.

; (ERB 2001-09-06) On this new analysis of wa, it can't identify its
; INDEX with its ARG, since the ARG will be the noun it attaches to
; in some cases and that can't unify with the event of the verb it
; modifies.  Likewise, we don't want the event of a PP modified by
; wa to be the same as the event of the main verb.  The confusing thing
; here is that wa is syntactically modifying the main verb and semantically
; modifying the NP or PP it attaches to.  Can't simply make it a syntactic
; modifier of NP because that NP won't be able to attach to the verb.
; Instead, I'm moving the constraint about INDEX=ARG to prep-sem-type.
; and saying something different about wa.

; (ERB 2001-10-01) It turns out that making topic-rel arg_rel only
; leads to MRSs that don't scope when wa marks NPs.  So, going back to
; having ARG = event of MOD and ARG2 = index of OBJ.

; (ERB 2001-10-03) It's not true of wa that OBJ.INDEX = ARG2.  Moving
; that to vmod-p-lex.

; (ERB 2001-11-28) Grab MOD-IND and MOD-HAND, not INDEX & LTOP.

; (ERB 2002-01-10) Experimenting with treating particle uses of
; など as topic markers with some extra content.  For this purpose,
; I need to allow for RELSs of more than one relation on vmod-p-lex-super.

; (MS 2004-06-26) Go back to grab INDEX and LTOP.

vmod-p-lex-super := mod-p-lex & 
            [SYNSEM [LKEYS.KEYREL #key,
		     LOCAL [ CAT [ HEAD vmod-p_head-avm &
                                       [MOD < [LOCAL.CONT.HOOK [LTOP #hand,
								INDEX #mind]] > ]],
                            CONT [ HOOK [LTOP #hand],
                                   RELS <! #key & [ARG2 #mind] !>,
                                   HCONS <! !>]]]].

; (ERB 2001-09-13) Other than wa, these guys are intersective modifiers.
; (ERB 2001-10-01) Try making wa an intersective modifier, too.

vmod-p-lex :=  vmod-p-lex-super & 
            [SYNSEM [LKEYS.KEYREL prep-mod-relation & [ARG1 #arg,
						       ARG2 #ind,
						       ARG0.E.TENSE no_tense],
		     LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #arg,
			     CONT prep-sem-type &
					     [HOOK.INDEX #ind]]]].

; (MS 2005-11-10) getting rid of skip files.

vmod-p-lex-parentarg := vmod-p-lex &
			[SYNSEM.LOCAL.CAT [HEAD postp_head,
					   VAL.COMPS.FIRST.LOCAL.CAT.HEAD parent-end_head]].


vmod-p-lex-vtearg := vmod-p-lex &
		     [SYNSEM.LOCAL.CAT [HEAD postp_head,
					VAL.COMPS.FIRST.LOCAL.CAT [HEAD verb_head & [FIN -,
										     VN -],
								   VAL saturated]]].

vmod-p-lex-narg := vmod-p-lex &
		   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head].

vmod-p-lex-parg := vmod-p-lex &
		   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE postp-case]].


; (MS 2005-05-10) Not used any more.
;uttmod-p-lex  :=  mod-p-lex & 
;                  [SYNSEM.LOCAL.CAT.HEAD uttmod-p_head].

postp-lex-general := vmod-p-lex &
             [SYNSEM.LOCAL.CAT.HEAD postp_head].

postp-lex := postp-lex-general & 
             [SYNSEM.LOCAL [CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head,
			    CONT.RELS <! relation !>]].


postp-lex-varg := postp-lex-general & 
             [SYNSEM.LOCAL.CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [FORMAL.AHON -, 
									   MODUS indicative,
									   MAIN-PRD -]]].

;(MS 2004-06-25) This is for the second conjunction in, e.g. "犬と猫とがいます"
; to avoid spurious ambiguity in "犬と猫といます", I use the trick with the empty RELS
; on MOD.
; (MS 2005-06-02) This second conjunction should not add to the MRS. Therefore, it
; belongs under mod-p-lex in the type hierarchy, adding an empty RELS list. The head
; should be postp_head, such that it can be subcategorized for by case particles.

postp-lex-coord := mod-p-lex & 
             [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
						       CONT.HOOK.INDEX conj-ref-ind & #ind],
				 HEAD postp_head & [MOD.FIRST.LOCAL.CONT.RELS <! !>]],
			    CONT [HOOK.INDEX #ind,
				  RELS <! !>]]].

postp-lex-ahon := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

postp-lex-main := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

postp-lex-sub := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].

postp-lex-robust := postp-lex &
		  [SYNSEM.NON-LOCAL.ROBUST +].




; (ERB 2001-08-30) I need to fix wa-parg so that it identifies the INDEX of its OBJ's MOD
; with the INDEX of it's own MOD.  In the process, I'm moving the further constraints on that
; type to a subtype here (from the instance in p-lex).

; (ERB 2001-09-03) Fixing this so that the ARG2 of wa is the KEY.ARG0 of 
; de (in dewa), not the INDEX, which is identified with #modind (which would
; lead to ARG and ARG2 having the same value.  This led to changing the
; definition of topic-rel so that its ARG2 can take an event as its value,
; and to undoing the constraint that this belong to prep-sem-type, which
; requires a prep-mod-rel as the KEY.  This, in turn, means that topic-vmod-p-lex
; isn't a subtype of vmod-p-lex.

; (ERB 2001-09-03) Adding constraint that the handles of wa and its OBJ should be
; the same.  Don't think anything could scope in there.

; (ERB 2001-09-06) Unlike other Ps, wa is semantically modifying the
; NP or PP it attaches to.  So it must not identify ARG & INDEX.  Instead
; it passes up it's MOD's INDEX.

; (ERB 2001-09-13) Because it's semantically modifying its object, it must
; also identify its LTOP with OBJ.LTOP.

; (ERB 2001-09-26) All of the sudden, "dono X wa" isn't parsing.  I don't
; think that wa or dono have been changed since last time it was working,
; but to make it work, I'm going to remove the constraint that wa only
; take QUE <! !> objects.

; (ERB 2001-09-27) Makino & Tsutsui claim that (topic) wa can't mark
; wh NPs, and Atusko confirms this.  However, contrastive wa can mark
; PPs, at least, as shown in the following:
;
; どの口座には利息がつきますか。
;
; Since we don't have a distinction between topic and contrastive wa,
; let wa modify QUE ne things for now.

; (ERB 2001-10-01) It turns out that making topic-rel arg_rel only
; leads to MRSs that don't scope when wa marks NPs.  So, going back to
; having ARG = event of MOD and ARG2 = index of OBJ.  Undoing constraints
; associated with having ARG = index of OBJ.

; (MS 2005-05-11) In cleaning up particles, renaming topic-vmod-p-lex.
; (MS 2005-05-13) Topic particles should set speaker empathy.

topic-p-lex := vmod-p-lex-super &
                    [SYNSEM [LKEYS.KEYREL prep-mod-relation &
					[ ARG2 #ind,
					  ARG0.E.TENSE no_tense ],
			     LOCAL [ CAT [ HEAD topic-vmod-p_head ],
				     CONT topic-sem-type  &
					 [HOOK.INDEX #ind,
					  RELS <! relation !>]]]].

;(MS 2005-11-10) getting rid of skip files.

topic-vhead-connect-p-lex := topic-p-lex &
		[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD verb_head & [FIN +,
										 VN -,
										 COP -,
										 ADJ -,
										 FORMAL.AHON -,
										 MAIN-PRD -],
							   CONT.HOOK.INDEX #objind]],
			       CONT [RELS <! [PRED '_toshite_p_rel,
					      ARG1 #objind] !>]]].

; (ERB 2002-01-10) Experimenting with treating particle uses of など
; as contributing topic semantics in addition to nado relation.

;plain-topic-vmod-p-lex := topic-vmod-p-lex.

; (ERB 2001-09-13) Want pobj wa to pass up any constraints its OBJ had on the
; OBJ's MOD's LTOP as well.

; (ERB 2001-10-01) Making wa ARG/ARG2 again, but I don't want ARG = ARG2.
; That arises because the P object of wa identifies its ARG with its 
; MOD.IND with its own INDEX and wa takes the INDEX of its OBJ as ARG2
; and the INDEX of it's MOD (same thing) as ARG...  So grab the KEY.ARG0 instead.
; (ERB 2001-11-28) Grab MOD-IND and MOD-HAND instead of INDEX and LTOP.

; (ERB 2002-01-10) Some Ps select for MAIN-PRD + or -.  We 
; presumably want this selection to persist for P+wa.  (Immediate 
; motivation is reducing ambiguity in "dehanai" sentences.)

; (MS 2002-07-12) We could as well just unify the MOD values of both particles. This would 
; restrict the ambiguity in the case of  には, but there a problem with のは.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-05-11) Linking XARG of the complement to ARG1, instead of INDEX.

topic-pobj-lex := topic-p-lex & 
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD p_head & 
						     [PTYPE nontop,
						      MOD #mod,
						      CASE mod],
					   CONT.HOOK.XARG #objind],
                    HEAD.MOD #mod & < [LOCAL.CONT.MOD-HAND #modtop] > ],
	       CONT [ HOOK.LTOP #modtop,
		      RELS.LIST.FIRST [ARG1 #objind]]]].

;(MS 2005-11-09) Getting rid of skip lexicon.

topic-pobj-postpcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE postp-case].

topic-pobj-fullmod-lex := topic-pobj-lex &
			  [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT [VAL [UNSAT -,
									 SUBJ null],
								    HEAD.EMPTY -],
							       CONT.HOOK.XARG full_ref-ind]] >].

topic-pobj-fullmod-postpcomp-lex := topic-pobj-fullmod-lex & topic-pobj-postpcomp-lex.

topic-pobj-modcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE nontop,
									      CASE mod]].


topic-pobj-negmod-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD.MODUS negative] >].

topic-pobj-overtmodcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE overt,
									      CASE mod]].

topic-pobj-overtmodcomp-negmod-lex := topic-pobj-negmod-lex &topic-pobj-overtmodcomp-lex. 

topic-pobj-vmodpcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD vmod-p_head & [PTYPE overt]].


; (ERB 2001-09-06) Moving some constraints on narg wa here.
; (MS 2003-12-19) Matrix 0.6

topic-nobj-lex := topic-p-lex &
[SYNSEM [LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [ CAT.HEAD noun_head,
					     CONT.HOOK.INDEX #objind ]]],
	 LKEYS.KEYREL.ARG1 #objind]].

;(MS 2005-11-09) Getting rid of skip lexicon.

topic-nobj-fullmod-lex := topic-nobj-lex &
			  [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT [VAL [UNSAT -,
									 SUBJ null],
								    HEAD.EMPTY -],
							       CONT.HOOK.XARG full_ref-ind]] >].

topic-nobj-negmod-lex := topic-nobj-lex &
			 [SYNSEM.LOCAL [CAT.HEAD.MOD < [LOCAL.CAT.HEAD.MODUS negative] >]].


topic-nobj-adjmod-lex := topic-nobj-negmod-lex &
			 [SYNSEM.LOCAL [CAT.HEAD.MOD < [LOCAL.CAT.HEAD i-adj_head] >]].


; (ERB 2002-01-10) Experimenting with treating particle uses of など
; as contributing topic semantics in addition to nado relation.
; (MS 2005-05-13) But why should that be different to the treatment of, e.g.
; demo, nanka and others?

;plain-topic-nobj-lex := topic-nobj-lex.


;topic-plus-nobj-lex := topic-nobj-lex &
;[ SYNSEM [LKEYS.ALTKEYREL #altkey & adj-relation &
;                               [ LBL #hand,
;                                 ARG1 #ind ],
;	  LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
;							LTOP #hand ],
;		  CONT [ RELS <! relation, #altkey !> ]]]].

; (ERB 2001-09-06) Moving some constraints on varg, comparg, & advarg wa here.
; (MS 2003-12-19) Matrix 0.6

topic-vobj-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT [ HEAD sentence-valid & 
                                                      [VN -,
                                                       COP -,
                                                       ADJ -,
                                                       H-TENSE te],
                                                 VAL saturated ],
					   CONT.HOOK.INDEX #objind]],
               CONT.RELS <! [ ARG1 #objind ] !>]]. 

topic-vobj-lex-neg := topic-vobj-lex &
		      [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [FIN +,
										      FORMAL.AHON -],
					  HEAD [PTYPE shika,
						MOD < [LOCAL.CAT.HEAD.MODUS negative] >]]]].

; (ERB 2001-10-03) Complementizer to is actually a case-p_head, and in
; this case we want to grab the index, since it doesn't contribute a relation. 

topic-cobj-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [ CAT.HEAD case-p_head & [PTYPE to],
                                           CONT.HOOK.INDEX #objind ]],
               CONT.RELS <! [ARG1 #objind ] !>]].

; (MS 2002-05-22) inserted the CONT.KEY restriction to keep input from n2adv out.
; (MS 2003-12-19) Matrix 0.6 


topic-advarg-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST [LOCAL [CAT.HEAD adv_head & [KEYS.KEY adv_rel],
					    CONT.HOOK.INDEX #objind]]],
	       CONT [RELS <! [ARG1 #objind] !>]]].


topic-cardarg-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST [LOCAL [CAT.HEAD int_head & [MOD < [LOCAL.CAT.HEAD.MODUS negative] >],
					    CONT.HOOK.INDEX #objind]]],
	       CONT [RELS <! [ARG1 #objind] !>]]].

adv-p-lex := vmod-p-lex & 
             [SYNSEM.LOCAL.CAT.HEAD adv-p_head].

; (MS 2005-08-17) We want date-noun-lex to occur with or without に, but 
; date-noun-adv-lex never to occur with に. In order to do so, I restrict 
; the adv-p-lex-np semantically to non-date-nouns and invent a second one 
; for date nouns.
; (MS 2005-10-18) This is too strict. We cannot get results for relative sentences plus ni,
; for example. So, we do a trick and use FIN to distinguish them.

adv-p-lex-np :=  adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head &
							      [FIN +]]].

;(MS 2005-11-10) getting rid of skip files.

adv-p-lex-np-sub := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].

adv-p-lex-np-main := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

adv-p-lex-np-exh := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS null] >].


adv-p-lex-np-nonexh := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS 1-list] >].


adv-p-lex-date :=  adv-p-lex & 
            [SYNSEM.LOCAL.CAT [HEAD.PTYPE ni,
			       VAL.COMPS.FIRST.LOCAL [CONT.RELS.LIST.FIRST niarg-relation,
						      CAT.HEAD noun_head]]].

adv-p-lex-iadj := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD i-adj_head].

;(MS 2005-11-10) getting rid of skip files.
adv-p-lex-iadj-main := adv-p-lex-iadj &
		       [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

adv-p-lex-iadj-sub := adv-p-lex-iadj &
		       [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].


adv-p-lex-p := adv-p-lex & 
            [SYNSEM.LOCAL.CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE nontop]]].

;(MS 2005-11-10) getting rid of skip files.

adv-p-lex-p-main := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

adv-p-lex-p-sub := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].


adv-p-lex-tocomp := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE to, CASE mod]].

adv-p-lex-postp := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE postp-case]].

adv-p-lex-p-exh := adv-p-lex-p &
		   [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS null] >].


adv-p-lex-tocomp-main := adv-p-lex-p-main & adv-p-lex-tocomp.


adv-p-lex-postp-main := adv-p-lex-p-main & adv-p-lex-postp.

adv-p-lex-postp-sub  := adv-p-lex-p-sub & adv-p-lex-postp.

adv-p-lex-postp-main-exh := adv-p-lex-postp-main & adv-p-lex-p-exh.




; (ERB 2002-01-10) To keep this from attaching to "empty-copula-id-rule"
; Vs, say COP -.  Might be too strong, and there might be another
; solution...
; (MS 2002-05-28) VN - to prevent ambiguity.

adv-p-lex-vp := adv-p-lex & 
[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & 
                                                [FORMAL.AHON -,
                                                 VN -,
                                                 COP -]].

adv-p-lex-naadj := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].

adv-p-lex-parent := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD parent-end_head].


; (ERB 2001-08-02) This type used to say the OBJ must be LEX +,
; but that doesn't work for "kono neko to sono neko ga neru".
; Don't know if some other subtype did need the constraint.
; (MS 2002-1-7) The L-HAND and R-HAND are not bound. 
;(MS 2004-06-24) As the n-conjunction gets an index, it should be quantified
; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (MS 2005-06-01) I try to unify the coordinated heads. It has to be shown if this
; is adequate (counterexamples?)
; (FCB 2005-06-26) Unifying heads stops things like: 商売 や 映画


n_conj-p-lex := conj-lex & 
            [SYNSEM [LKEYS.KEYREL conjunction-relation & #key &
                                    [C-ARG #index,
				     LBL #hndl,
                                     L-INDEX #arg,
                                     R-INDEX #mod],
		     LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT.HEAD noun_head,
						       CONT [HOOK.INDEX #mod]]] >,
				       J-POSTHEAD left],
                                VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
						       CONT [HOOK.INDEX #arg],
						       BAR +]],
			    CONT n-conj-sem-type &
                               [HOOK [INDEX conj-ref-ind & #index],
				RELS <! #key , quant-relation & [PRED udef_rel,
								 ARG0 #index,
								 RSTR #rest] !>,
				HCONS <! qeq & [HARG #rest, LARG #hndl] !>]]]].


; (MS 2005-06-01) The restriction on the complement (to be a noun_head) was redundant.

hyphen-conj-p-lex := n_conj-p-lex &
            [SYNSEM [LOCAL.CAT.HEAD.PTYPE to,
		     LKEYS.KEYREL.PRED 'to_and]].


; (MS 2005-05-17) I am not sure that we need this. The only instance is "か", as in "東京からか". 
; Taking the entry out.

;postp-conj-p-lex := mod-p-lex & 
;            [SYNSEM [LKEYS.KEYREL #key & [L-INDEX #arg,
;					  R-INDEX #mod],
;		     LOCAL [CAT [HEAD nmod-p_head-avm & [MOD < [LOCAL [CAT.HEAD postp_head,
;								       CONT [HOOK.INDEX #mod]]] >,
;							 J-POSTHEAD left],
;                               VAL.COMPS.FIRST.LOCAL [CAT.HEAD postp_head,
;						      CONT [HOOK.INDEX #arg]]],
;			    CONT n-conj-sem-type &
;                               [HCONS <! !>,
;				RELS <! #key !>]]]].

compl-conj-p-lex := conj-lex & 
            [SYNSEM [LKEYS.KEYREL #key & [C-ARG #index,
					  L-HNDL #arg,
					  R-HNDL #mod],
		     LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT.HEAD case-p_head & [CASE #case,
									       PTYPE to],
						       CONT [HOOK.LTOP #mod]]] >,
				       J-POSTHEAD left],
				 VAL.COMPS.FIRST.LOCAL [CAT.HEAD case-p_head & [CASE #case,
										PTYPE to],
							CONT [HOOK.LTOP #arg]]],
			    CONT n-conj-sem-type &
				[HCONS <! !>,
				 HOOK.INDEX conj-ref-ind & #index,
				 RELS <! #key !>]]]].




;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- others;;;;;;;;;;;

; (MS 2003-12-19) Matrix 0.6

dt-lex := lexical_sign-word & 
	  [SYNSEM [LOCAL [CAT [HEAD det_head-avm & [J-SPEC.FIRST.LOCAL.CONT.HOOK [INDEX #ind,
										  LTOP #spechand]], 
			       VAL saturated],
			  CTXT.BACKGROUND <! !>,
			  CONT lex-det-sem-type & [HOOK [INDEX #ind,
							 XARG #ind],
						   RELS <! #key !>,
						   HCONS <! qeq &
							  [LARG #spechand,
							   HARG #hand] !>],
			  BAR +,
			  ARG-S <>],
		   LKEYS.KEYREL #key & [ARG0 #ind,
					RSTR #hand],
		   NON-LOCAL [AFFIX <! !>]],
	   INFLECTED +].

det-lex := dt-lex &
             [SYNSEM.NON-LOCAL.QUE <! !>].

det-wh-lex := dt-lex &
             [SYNSEM [NON-LOCAL.QUE <! #top !>,
                      LOCAL [CONT.HOOK.LTOP #top,
			     CAT.HEAD.KEYS.KEY #pred],
		      LKEYS.KEYREL.PRED #pred & whq_rel]].

; (MS 2002-04-17) DAI behaves like a definite determiner on counted nouns: 一本 - one book, 第一本 - the first book. 
; I've thus made it a determiner that specifies counted nouns. 
; I could not think of a solution that changes the card-rel to ord-rel, though.
; (MS 2003-12-19) Matrix 0.6


card2ord-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD card2ord_head-avm & [J-SPEC.FIRST.LOCAL [CAT.HEAD.KEYS.KEY quantity_rel,
									       CONT.HOOK [INDEX #ind,
	       									 LTOP #spechand]],
	                                                   KEYS.KEY def_rel], 
                                 VAL saturated],
                            CTXT.BACKGROUND <! !>,
                            CONT lex-det-sem-type & [HOOK [INDEX #ind,
							   XARG #ind],
                                                     RELS <! #key !>,
                                                     HCONS <! qeq &
                                                             [LARG #spechand,
                                                              HARG #hand] !>],
                            BAR +,
			    ARG-S <>],
		     LKEYS.KEYREL #key &
			   [PRED def_rel,
			    ARG0 #ind,
			    RSTR #hand],
                     NON-LOCAL [AFFIX <! !>,
			     QUE <! !> ]],
             INFLECTED +].



hes-lex   := lexical_sign-word &
            [SYNSEM [LOCAL [CAT  [HEAD hes_head-avm, VAL saturated],
                            CONT hes-sem-type,
                            CTXT.BACKGROUND <! !>,
			    ARG-S <>],
		     LKEYS.KEYREL.PRED hes_rel,
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].



; (MS 2005-05-17) Trying to put sentence particles into the type hierarchy of particles.

sap-lex  := p-lex-c & 
            [SYNSEM [LOCAL [CAT [HEAD sap_head & [FORMAL.SHON #1], 
                                 VAL sap_sc & [COMPS #comps & [FIRST.LOCAL.CAT.HEAD.FORMAL.SHON #1]]],
                            CTXT.BACKGROUND <! !>,
			    ARG-S #comps],
                     NON-LOCAL [AFFIX <! !>]],
             INFLECTED +].

; (ERB 2001-12-28) For kudasai in VN + kudasai.  Brought in all relevant constraints
; from s-end-lex and s-end2-lex.

; (ERB 2002-01-02) This didn't work.  See notes at VERBAL ENDINGS, this file.

; (ERB 2002-01-14) comma_s-conj is taking sentences ending in 
; no+de as its OBJ.  
; (MS 2005-05-17) This is not needed any more!

;sap1-lex  := lexical_sign-word & 
;            [SYNSEM [LOCAL [CAT [HEAD sap1_head & [FORMAL.SHON #1], 
;                                 VAL sap_sc & [COMPS #comps & [FIRST.LOCAL.CAT.HEAD.FORMAL.SHON #1]]],
;                            CTXT.BACKGROUND <! !>,
;			    ARG-S #comps],
;                     NON-LOCAL [QUE <! !>,
;                             AFFIX <! !>]],
;             INFLECTED +].

; (ERB 2002-01-24) To force one order of combination in clauses with
; multiple conjunctions, require OBJ to be NUCL not_fin_conj.  (This
; probably isn't strictly correct, but I'll use it cut down ambiguity
; until we find a counterexample.)

;(MS 2004-06-25) Took the EMPTY - restriction on the complement out.
; changed the relation to conjunction-relation. I want a C-ARG to be accessible
; for modification and so on. This should be the LTOP. The tense information is unified between 
; the two conjuncts and passed to the top.
; We need to add a value to XARG, in order not to get spurious ambiguity with the vmod-p が
; (FCB 2005-01-29) Added J-POSTHEAD rels to VAL.COMPS.FIRST.CAT.HEAD
; to get rid of spurious ambiguity with comma-vmod2
; (I don't want it to trigger for coord) 食べて、笑った。
; (FCB 2005-01-30) Add EMPTY - restriction on main verb.  
; Otherwise there is a lot of ambiguity with fragments
; (FCB 2005-04-12) FIXME - can we put the EMPTY - restriction on the complement back?
; (FCB 2005-06-27) Added ARG0 to messages
; (MS 2005-06-07) It seems that this one is never applied.
; (FCB 2005-06-29) but it is used by several lexical entries
; (MS 2005-07-01) but I had renamed the s-conj-nonprop-lex!
 ;s-conj-lex := sap-lex &
 ; [SYNSEM [LOCAL [CAT [HEAD s-conj_head &
 ;			   [C-MOD < [LOCAL [CONT.HOOK [LTOP #main-v-handel,
 ;						       INDEX #main-index,
 ;						       INDEX.E #tam],
 ;					    CAT.HEAD.EMPTY -]]> ],
 ;		      VAL.COMPS.FIRST [LOCAL [CONT.HOOK [LTOP #subord-v-handel,
 ;							 INDEX.E #tam,
 ;							 INDEX #subord-index,
 ;							 XARG #xarg],
 ;					      CAT.HEAD [EMPTY bool,
 ;							J-POSTHEAD rels,
 ;							FIN +],
 ;					      NUCL not_fin_conj ]]],
 ;		 NUCL nucl_minus,
 ;		 CONT [HOOK [INDEX #ind & event & [E #tam],
 ;			     LTOP #top,
 ;			     XARG #xarg],
 ;		       RELS <! conjunction-relation & #key &
 ;			     [C-ARG #ind,
 ;			      LBL #top,
 ;			      R-HNDL #main,
 ;			      L-HNDL #subord],
 ;			     message &
 ;			     [PRED proposition_m_rel,
 ;			      LBL #main,
 ;			      ARG0 #main-index,
 ;			      MARG #prpstnsoa1],
 ;			     message &
 ;			     [PRED proposition_m_rel,
 ;			      LBL #subord,
 ;			      ARG0 #subord-index,
 ;			      MARG #prpstnsoa2] !>,
 ;		       HCONS <! qeq & [LARG #main-v-handel,
 ;				       HARG #prpstnsoa1],
 ;			      qeq & [LARG #subord-v-handel,
 ;				     HARG #prpstnsoa2] !>]],
 ;	  LKEYS.KEYREL #key,
 ;	  NON-LOCAL.QUE <! !>]].

;s-conj1-lex := s-conj-lex & [SYNSEM.LOCAL.CAT [HEAD.FORMAL.AHON #1,
;                                               VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORMAL.AHON #1]].

;s-conj1-decl-lex := s-conj1-lex &
;		    [SYNSEM.LOCAL [CAT.HEAD.SMOD decl]].

;s-conj2-lex := s-conj-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (ERB 2002-01-07) For conjunctions that allow non-propositional 
; right conjuncts.  This type doesn't supply a message for the
; right conjunct, since it would already have one.  However, since
; the right conjunct is also the head, these sentences won't go through
; a message-adding utterance rule.  So, the s-conj-nonprop-lex needs
; to supply a message for itself (and send the right handle up).
; [See further notes at s-conj-nonprop_head.]

; (ERB 2002-01-24) To force one order of combination in clauses with
; multiple conjunctions, require OBJ to be NUCL not_fin_conj.  (This
; probably isn't strictly correct, but I'll use it cut down ambiguity
; until we find a counterexample.)

; (MS 2002-02-07) The problem is that in the case of something like
; 食べれば行きますので教えて下さい NODE is not interpreted as an s-conj-lex
; and thus the sentence doesn't parse. I'll take that out and make another try.
; (MS 2005-06-07) These are all decl. They all identify AHON.
; (FCB 2005-06-27) Added ARG0 to messages


s-conj-lex := sap-lex &
 [SYNSEM [LOCAL [CAT [HEAD s-conj-nonprop_head &
			   [C-MOD < [LOCAL.CONT.HOOK [LTOP #main-v-handel,
						      INDEX #main-index]] >,
					FORMAL.AHON #ahon,
					SMOD decl],
		      VAL.COMPS.FIRST.LOCAL [CONT.HOOK [LTOP #subord-v-handel,
							INDEX #subord-index],
					     CAT.HEAD [EMPTY -,
						       FORMAL.AHON #ahon],
					     NUCL nucl]],
		 NUCL nucl_minus,
		 CONT [HOOK [INDEX #main-index,
			     LTOP #top],
		       RELS <! subord-or-conj-relation & #key &
			     [LBL #subord-hand,
			      R-HNDL #main-v-handel,
			      L-HNDL #subord],
			     message &
			     [PRED proposition_m_rel,
			      LBL #subord,
			      ARG0 #subord-index,
			      MARG #prpstnsoa2],
			     message &
			     [PRED proposition_m_rel,
			      ARG0 #main-index,
			      LBL #top,
			      MARG #subord_rel]!>,
		       HCONS <! qeq & [LARG #subord-v-handel,
				       HARG #prpstnsoa2],
			      qeq & [LARG #subord-hand,
				     HARG #subord_rel] !>]],
	  LKEYS.KEYREL #key,
	  NON-LOCAL.QUE <! !>]].


s-conj-lex-fincomp := s-conj-lex &
		      [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FIN +].

s-conj-lex-desusapsc := s-conj-lex &
			[SYNSEM.LOCAL.CAT.VAL desu-sap_sc].


;s-conj-nonprop1-lex := s-conj-nonprop-lex & 
;                       [SYNSEM.LOCAL.CAT [HEAD [FORMAL.AHON #1,
;						SMOD decl],
;                                          VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORMAL.AHON #1]].

; (MS 2005-06-07) We seem not to use this any more.
;s-conj-nonprop2-lex := s-conj-nonprop-lex & 
;                       [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].



; (ERB 2002-01-07) LTOP was unbound.  Making it KEY.HANDEL.
; (FCB 2005-06-27) Added ARG0 to message

s-end-lex := sap-lex &
              [SYNSEM [LKEYS.KEYREL #key & [MARG #soahandle,
					    ARG0 #ind,
					    LBL #top],
		       LOCAL [CAT [HEAD s-end_head-avm & [COP-ARG -],
				   VAL.COMPS.FIRST.LOCAL.CONT.HOOK [LTOP #v-handle,
								    INDEX #ind]],
			      CONT [HOOK [LTOP #top,
					  INDEX #ind],
				    RELS <! #key !>,
				    HCONS <! qeq & [LARG #v-handle,
						   HARG #soahandle] !>]]]].

s-end1-lex := s-end-lex & [SYNSEM.LOCAL.CAT [HEAD.FORMAL.AHON #1,
                                             VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORMAL.AHON #1]].


s-end1-decl-lex := s-end1-lex &
		   [SYNSEM [LOCAL [CAT.HEAD.SMOD decl,
                            CONT.RELS <! message &
                                          [PRED proposition_m_rel] !>],
		      NON-LOCAL.QUE 0-dlist]].

s-end1-declint-lex := s-end1-lex &
		   [SYNSEM [LOCAL [CAT.HEAD.SMOD decl,
				   CONT.RELS <! [PRED abstr-ques_m_rel] !>],
		      NON-LOCAL.QUE 0-dlist]].

s-end1-decl-minusahon-lex := s-end1-decl-lex &
			      [SYNSEM.LOCAL [CAT [HEAD.FORMAL.AHON -,
						  VAL.COMPS.FIRST [NON-LOCAL.QUE <! !>,
								   LOCAL.CAT.HEAD.COP +]],
					     CTXT [C-INDICES.SPEAKER #1,
						   EMPATHY.EMPEE #1]]].

s-end1-decl-full-lex := s-end1-decl-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.EMPTY -].


s-end1-quest-lex := s-end1-lex &
		    [SYNSEM [LOCAL [CAT.HEAD.SMOD quest,
                      CONT.RELS <! message & [ PRED question_m_rel ] !>],
			     NON-LOCAL.QUE 0-dlist]].

s-end1-quest-minusahon-lex := s-end1-quest-lex &
			      [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

s-end1-quest-minusahon-vcomp-lex := s-end1-quest-minusahon-lex &
				    [SYNSEM [LOCAL [CAT [VAL.COMPS.FIRST [NON-LOCAL.QUE 0-dlist,
									  LOCAL.CAT.HEAD verb_head]]]]].


s-end1-quest-minusahon-copcomp-lex := s-end1-quest-minusahon-lex &
				      [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST [NON-LOCAL.QUE 1-dlist,
									LOCAL.CAT.HEAD.COP +]].

s-end2-lex := s-end-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-11-09) To get rid of skip files.

s-end2-nemasc-lex := s-end2-lex &
		     [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
				    CONT.RELS <! message & [ PRED ne_m_rel] !>,
				    CTXT.C-INDICES.SPEAKER.PNG.GEN masc]].

s-end2-nefem-lex := s-end2-lex &
		     [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
				    CONT.RELS <! message & [ PRED ne_m_rel] !>,
				    CTXT.C-INDICES.SPEAKER.PNG.GEN fem]].

s-end2-quest-lex := s-end2-lex &
		     [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
                      CONT.RELS <! message & [ PRED question_m_rel] !>]].



; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-02) For generation, these need PRED values on the arg1-relation.
; (FCB 2005-06-27) Added ARG0 to message 
; FIXME I am not sure who should be the ARG0 of the main message!
; (MS 2005-11-09) These all have SMOD decl.

s-ell-end-lex := sap-lex &
 [SYNSEM [LOCAL [CAT [HEAD s-end_head-avm & [EMPTY +,
					     SMOD decl],
		      VAL.COMPS.FIRST.LOCAL.CONT.HOOK [LTOP #v-handle,
						       INDEX #subord-index]],
		 CONT [HOOK [INDEX #ind,
			     LTOP #prpstnh2],
		       RELS <! #key,
			     message &
			     [PRED proposition_m_rel,
			      LBL #subord,
			      ARG0 #subord-index,
			      MARG #prpstnsoa1],
			     message &
			     [PRED proposition_m_rel,
			      LBL #prpstnh2,
			      MARG #prpstnsoa2],
			     arg1-relation &
			     [LBL #main,
			      PRED 'ellipsis,
			      ARG0 #ind] !>,
		       HCONS <! qeq & [LARG #v-handle,
				       HARG #prpstnsoa1],
			      qeq & [LARG #handel,
				     HARG #prpstnsoa2] !>]],
	  LKEYS.KEYREL subord-or-conj-relation & #key & [R-HNDL #main,
							 L-HNDL #subord,
							 LBL #handel],
	  NON-LOCAL.QUE <! !>]].


; (ERB 2001-12-10) Making these more like discourse adverbs like
; "well" and "so" in the LinGO grammar.  (Existing analysis gives
; them only a LBL and doesn't link that handle up to anything.
; In a sufficiently long sentence, this leads to non-scoping MRSs.)

; (ERB 2001-12-10) ... that means they must be scopal modifiers!


interj-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD interj_head-avm &
                                      [ MOD < [LOCAL.CONT.HOOK.LTOP #rhand ] >],
                                 VAL saturated],
                            CTXT.BACKGROUND <! !>,
                            CONT interj-sem-type &
				[RELS <! subord-or-conj-relation &
				       [ LBL #top,
					 PRED 'discourse_rel,
					 R-HNDL #rhand,
					 L-HNDL #hand ],
				       #key & interj-relation &
				       [ LBL #hand ] !>,
				 HOOK.LTOP #top],
                            BAR +,
			    ARG-S <>],
		     LKEYS.KEYREL #key,
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].

; (MS 2005-11-09) Subtypes to get rid of skip files.

interj-bar-lex := interj-lex &
		  [SYNSEM.LOCAL.BAR +].

interj-robust-lex := interj-lex &
		  [SYNSEM.NON-LOCAL.ROBUST +].


excl-lex := idiom-lex &
            [SYNSEM [LOCAL [CAT.HEAD excl_head,
			    CONT excl-sem-type]]].

; (MS 2005-11-09) Subtypes to get rid of skip files.

excl-robust-lex := excl-lex &
		   [SYNSEM.NON-LOCAL.ROBUST +].

excl-ahon-lex := excl-lex &
		   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON + ].


idiom-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD idiom_head & [C-MOD < [LOCAL.CONT.HOOK [LTOP #rhand,
									      INDEX #ind]] > ], 
                                 VAL saturated],
                            CONT [HOOK [INDEX #ind,
					LTOP #top],
                                  RELS <! #key,
                                         subord-or-conj-relation &
                                         [PRED 'discourse_rel,
					  LBL #top,
                                          L-HNDL #lhand,
                                          R-HNDL #rhand] !>],
                            CTXT.BACKGROUND <! !>,
                            BAR +,
			    ARG-S <>],
		     LKEYS.KEYREL #key & [LBL #lhand],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].


greeting-lex := idiom-lex &
                [SYNSEM [LOCAL.CONT greeting-sem-type]].

; (MS 2005-11-09) Subtype to get rid of skip files.

greeting-ahon-lex := greeting-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].



;;;;;;;;;;;;;;;;;;;;LEXIKAL TYPES - NOUNS;;;;;;;;;;;


; (ERB 2001-11-05) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.


n-lex-super := lexical_sign & 
         [SYNSEM [LOCAL [ CAT.HEAD noun_head,
			  CONT [ HOOK [INDEX #ind,
				       LTOP #top,
				       XARG nothing]]],
		  LKEYS.KEYREL [ARG0 #ind,
				LBL #top]],
          INFLECTED +].

n-lex := n-lex-super & lexical_sign-word.

; (MS 2005-07-04) This is nonsense, I think. It was used only for mitai.
;exceptional-n-lex := n-lex &
;[SYNSEM [LOCAL [CAT [HEAD exceptional_noun_head,
;		     VAL noun_sc],
;		CONT common-noun-sem-type & 
;		    [RELS <! #key !>,
;		     HCONS <! !>],
;		BAR -],
;	 LKEYS.KEYREL #key,
;	 NON-LOCAL [QUE <! !>,
;		    AFFIX <! !>]],
; J-NEEDS-AFFIX -,
; INFLECTED +].


ordinary-or-wh-n-lex := n-lex &
                  [SYNSEM [LOCAL [CAT [HEAD ordinary_noun_head-avm & [KEYS.KEY #pred],
                                       VAL noun_sc & [SPR.FIRST #spr]],
				  ARG-S < #spr >,
                                  CONT common-noun-sem-type & [HOOK.INDEX #ind & [PNG.PN three],
							       RELS <! #key !> ]],
			   LKEYS.KEYREL #key & [ARG0 #ind, PRED #pred],
                           NON-LOCAL.AFFIX <! !>]].

ordinary-n-lex := ordinary-or-wh-n-lex &
                  [SYNSEM [NON-LOCAL.QUE <! !>,
                           LOCAL.CONT [HCONS <! !>]],
                   STEMTYPE noun-stem].

; (MS 2005-09-02) This is not necessary any more. We move the entries to date-noun-lex.

;possibly-adv-n-lex := ordinary-or-wh-n-lex & 
;                      [STEMTYPE poss-adv-stem,
;                       SYNSEM [NON-LOCAL.QUE <! !>,
;                               LOCAL [CONT common-noun-sem-type &
;                                          [HCONS <! !>,
;					   HOOK.INDEX #ind,
;                                           RELS <! #key !>]],
;			       LKEYS.KEYREL #key & [ARG0 #ind]]].


;;; (FCB 2003-08-05) added for mi and sa
; (MS 2005-03-15) This is not correct: It should take an adjective as argument!
; FIXME!

adj2n-suffix-lex := n-lex &
		      [SYNSEM [LOCAL [CAT [HEAD adj2n-suffix_noun_head-avm &  [J-POSTHEAD right],
					   VAL noun_sc & [SPR.FIRST #spr]],
				      BAR -,
				      ARG-S < #spr >,
				      CONT common-noun-sem-type & [HOOK.INDEX #ind & [PNG.PN three],
								   RELS <! #key !> ]],
			       LKEYS.KEYREL #key & [ARG0 #ind],
			       NON-LOCAL.AFFIX <! !>]].	   


; (ERB 2001-10-23) 自分 unbound RELS values because it was a direct subtype
; of pron-lex, which says nothing about the semantics.  In addition, the
; constraint CONT personal-pronoun-sem-type is repeated on many types below.
; So, I'm going to make a subtype, pers-pron-lex, that bears this constraint
; and is also the type for 自分.

pron-lex := n-lex & 
           [SYNSEM [LOCAL [CAT [HEAD pron_head-avm,
                               VAL saturated],
                           BAR +,
			   ARG-S <>],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]]].

pers-pron-lex := pron-lex &
                 [ SYNSEM [LKEYS.KEYREL real-pron-relation & #key & [PRED pron_rel],
			   LOCAL.CONT personal-pronoun-sem-type &
					  [RELS.LIST.FIRST #key]]].

; (MS 2005-02-28) Renamed the pers-pron-selfemp-lex.
; This is actually only the reflexive 自分

reflexive-pronoun-lex := pers-pron-lex &
			 [ SYNSEM [LOCAL [CONT [HOOK.INDEX #ind],
					  CTXT.EMPATHY.EMPEE #ind],
				   LKEYS.KEYREL pron-relation,
				   NON-LOCAL [QUE <! !>,
					      REL <! #ind !>]]].


; (MS 2005-02-28) Renamed the pron-honsubj-selfemp-lex. 
;This is actually only the honorific reflexive. Thus, it
; inherits from the reflexive-pronoun-lex and we don't need the 
; pron-honsubj-lex any more. ご自分

reflexive-pronoun-honsbj-lex := reflexive-pronoun-lex &
			    [SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
					   CONT [HOOK.INDEX #1],
					   CTXT [C-INDICES.SPEAKER #2,
						 BACKGROUND <! obj-honor_rel &
							     [POLARITY +,
							      HONORER #2,
							      HONORED #1] !>]]].
			   
; (MS 2005-02-28) renamed pron-sp-ref-lex. No example.

pron-firstperson-ref-lex := pers-pron-lex &
		   [SYNSEM [LKEYS.KEYREL [ARG0 [PNG.PN one]],
			    LOCAL [CAT.HEAD.FORMAL.SHON -,
				   CONT [HOOK.INDEX #1],
				   CTXT [C-INDICES.SPEAKER #1,
					 EMPATHY.EMPEE #1,
					 BACKGROUND <! obj-honor_rel &
						     [POLARITY -,
						      HONORER #1,
						      HONORED #1] !>]]]].



; (MS 2005-02-28) renamed pron-add-ref-lex. そちら

pron-secondperson-ref-lex := pers-pron-lex &
                    [SYNSEM [LKEYS.KEYREL [ARG0 [PNG.PN two]],
			     LOCAL [CAT.HEAD.FORMAL.SHON +,
                                   CONT [HOOK.INDEX #1],
                                   CTXT [C-INDICES [SPEAKER #2,
                                                    ADDRESSEE #1],
                                         BACKGROUND <! obj-honor_rel &
                                                     [POLARITY +,
                                                      HONORER #2,
                                                      HONORED #1] !>]]]].

; (MS 2005-03-01) added addressee honorification: そちら, 君

pron-secondahon-ref-lex := pron-secondperson-ref-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

pron-secondminusahon-ref-lex := pron-secondperson-ref-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

; (MS 2005-02-28) added the clear plural cases, such as 君達

pron-secondpl-ref-lex := pron-secondperson-ref-lex &
			 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twopl].

; (MS 2005-02-28) added the clear singular cases, such as 君

pron-secondsg-ref-lex := pron-secondperson-ref-lex &
			 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twosg].


; (MS 2005-02-28) renamed pron-sp-add-ref-lex. We do not need the distinction
; between inclusion of the addressee and exclusion, because the pronouns don't give
; this distinction. This can inherit from pron-firstperson-ref-lex. 私達
;  (MS 2005-03-01) added types for honorification: こちら

pron-firstpl-ref-lex := pron-firstperson-ref-lex &
                       [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN onepl].

pron-firstplahon-ref-lex := pron-firstpl-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-02-28) added the clear singular first person pronoun type. 私

pron-firstsg-ref-lex := pron-firstperson-ref-lex &
                       [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN onesg].

; (MS 2005-03-01) added types for honorification: 私、ぼく

pron-firstsgahon-ref-lex := pron-firstsg-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

pron-firstsgminusahon-ref-lex := pron-firstsg-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

; (MS 2005-02-28) renamed pron-ent-ref-lex.

pron-thirdperson-ref-lex :=  pers-pron-lex &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN three]]].


; (MS 2005-02-28) added the clear singular third person pronoun type. 彼女

pron-thirdsg-ref-lex := pron-thirdperson-ref-lex  &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN threesg]]].

; (MS 2005-03-01) we need gender for the third person singular. 彼、彼女, それだけ

pron-thirdsgfem-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN fem].

pron-thirdsgmasc-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN masc].

pron-thirdsgneut-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN neut].

; (MS 2005-03-01) added honorification: あちら

pron-thirdsgneutahon-ref-lex := pron-thirdsgneut-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].


; (MS 2005-02-28) added the clear plural third person pronoun type. 彼ら

pron-thirdpl-ref-lex := pron-thirdperson-ref-lex  &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN threepl]]].

; (MS 2005-03-01) third person plural can be andro (彼ら) or neutr (それら).

pron-thirdplandro-ref-lex := pron-thirdpl-ref-lex &
			     [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN andro].


pron-thirdplneut-ref-lex := pron-thirdpl-ref-lex &
			     [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN neut].



; (MS 2005-03-01) gender neutr for all demonstrative pronouns. 

pron-demon-lex := pron-lex &
                  [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i & [PNG.GEN neut]],
			   LOCAL.CONT ppron-sem-type &
					  [RELS <! #key & 
						 generic-nom-relation,
						 quant-relation & [PRED 'dem_rel] !>,
					   HOOK.INDEX #i]]].

pron-loc-ref-lex  := pron-lex &
                  [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
				 LOCAL.CONT lpron-sem-type &
					  [HOOK.INDEX #i,
					   RELS.LIST.FIRST #key ]]].



;  TT&FCB 2003-09-03 took away [SYNSEM [LOCAL [CAT [ VAL.SPR.FIRST.LOCAL.KEYS.KEY.PRED 'def]]
; so that we could actually parse these things!
; otherwise unification fails with quantify-n-infl-rule
; (MS 2003-12-19) Fixed that.

day-lex := n-lex & 
               [SYNSEM [LOCAL [CAT [HEAD temporal-noun_head,
                                    VAL noun_sc & [SPR.FIRST #spr & [LOCAL.CAT.HEAD.KEYS.KEY def_rel]]],
                               CONT [HOOK [LTOP #hand],
				     RELS <! #key !>,
				     HCONS <! !>],
			       CTXT.BACKGROUND <! !>,
			       ARG-S < #spr >],
			LKEYS.KEYREL contentful-nom-relation & #key & [LBL #hand],
                        NON-LOCAL [QUE <! !>,
				   AFFIX <! !>]]].

dofw-n-lex  := day-lex & 
	       [SYNSEM [LOCAL.CAT.HEAD dofw_noun_head-avm,
			LKEYS.KEYREL dofw-relation    ]].



dofm-n-lex := day-lex & 
               [SYNSEM [LOCAL.CAT.HEAD dofm_noun_head-avm,
			LKEYS.KEYREL dofm-relation ]].


mofy-n-lex := day-lex & 
               [SYNSEM [LOCAL.CAT.HEAD temp_numeral_head-avm & [J-POSTHEAD compound],
			LKEYS.KEYREL mofy-relation    ]].

relational-n-lex := n-lex &
		    [SYNSEM [LOCAL [CAT [HEAD relational_noun_head,
                                    VAL noun_sc & [SPR.FIRST #spr & [LOCAL.CAT.HEAD.KEYS.KEY def_rel]]],
                               CONT [HOOK [LTOP #hand],
				     RELS <! #key !>,
				     HCONS <! !>],
			       CTXT.BACKGROUND <! !>,
			       ARG-S < #spr >],
			LKEYS.KEYREL contentful-nom-relation & #key & [LBL #hand],
                        NON-LOCAL [QUE <! !>,
				   AFFIX <! !>]]].

; (MS 2003-07-14) With PRED string (matrix.tdl), it is not possible to use types here and therefore I cannot state PRED def (which overrides PRED udef in the quantify-n-infl-rule). Default-Unification might help here.
; (MS 2003-10-08) I'll use the KEY value instead.
; (MS 2005-11-09) These needed to link the KEYS.KEY, otherwise we parse (and generate) 第花子

name-lex  := n-lex & 
                  [SYNSEM [LOCAL [CAT [HEAD name_head-avm & [KEYS.KEY #pred],
                                       VAL noun_sc &
                                          [SPR.FIRST #spr & [LOCAL.CAT.HEAD.KEYS.KEY def_rel]]],
                                  CONT mod-id-nominal-sign-sem-type &
                                      [RELS <! #key !>,
				       HOOK.INDEX #ind,
                                       HCONS <! !>],
				  CTXT.BACKGROUND <! !>,
				  ARG-S < #spr >],
			   LKEYS.KEYREL named-relation & #key & [ARG0 #ind, PRED #pred],
                           NON-LOCAL [QUE 0-dlist,
				      AFFIX <! !>]]].


person-name-lex := name-lex.


surname-lex := person-name-lex & loc-or-surname-lex &
                  [SYNSEM.LOCAL.CAT.HEAD surname_head].

first_name-lex := person-name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD first_name_head-avm].

;;; names which can be first or surname, artists' names
;;; (do-parse-tty "タモリ")

other_name-lex := person-name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD other_name_head-avm].


ippan-name-lex := name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD ippan_head-avm].

loc_name-lex := loc-or-surname-lex & 
                [SYNSEM.LOCAL [CAT.HEAD loc_name_head-avm]].
                               

inst_name-lex := loc-or-surname-or-instname-lex &
                  [SYNSEM.LOCAL [CAT.HEAD inst_name_head-avm]].
                               
                   

agent-name-lex := name-lex & 
                  [SYNSEM.LOCAL [CAT.HEAD surname_head-avm]].


product-name-lex := name-lex &
                  [SYNSEM.LOCAL [CAT.HEAD product_name_head-avm]].

; (MS 2005-09-30) Added types for names that can be ambiguous.

loc-or-surname-or-instname-lex := name-lex &
                  [SYNSEM.LOCAL [CAT.HEAD name_head & [J-POSTHEAD compound]]].

loc-or-surname-lex :=  loc-or-surname-or-instname-lex.

surname-or-instname-lex := loc-or-surname-or-instname-lex.

; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.
; (FCB 2005-04-11) Added  SYNSEM.LOCAL.CAT.HEAD.MOD null, to stop 
; interjections popping up all over the place in (do-parse-tty "この こと が 起きる")

nom-lex := n-lex-super & 
           [SYNSEM [LOCAL [CAT [HEAD nom_head-avm & 
				     [MOD null],
				VAL.SPR #spr],
                            CTXT.BACKGROUND <! !>,
			   ARG-S #spr,
                          BAR +],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]]].

; (MS 2003-12-19) Matrix 0.6

temp_numeral-basic-lex  := n-lex & 
           [SYNSEM [LOCAL [CAT [HEAD temp_numeral_head-avm,
                                VAL temp_noun_sc &
                                     [SPR.FIRST #spr,
				      COMPS #comps & [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
									      XARG #i],
								   CAT.HEAD.KEYS.KEY 'temp_loc]]]],
                           CONT common-noun-sem-type &
                               [HOOK [INDEX #i,
				      LTOP #hand]],
                           CTXT.BACKGROUND <! !>,
			   ARG-S < #spr . #comps >],
		    LKEYS.KEYREL.ARG0 #i,
                    NON-LOCAL.AFFIX <! !>]].


temp_numeral-lex := temp_numeral-basic-lex &
                    [SYNSEM [LOCAL [CAT.HEAD.J-POSTHEAD compound,
				    CONT common-noun-sem-type &
                                        [RELS <! #key !>,
					 HOOK.INDEX #i,
                                         HCONS <! !>]],
			     LKEYS.KEYREL #key & [ARG0 #i]]].

temp_numeral-whq-lex := temp_numeral-lex &
                        [SYNSEM [NON-LOCAL.QUE <! #top !>,
                                 LOCAL.CONT.HOOK.LTOP #top]].

temp_numeral-nonwh-lex  := temp_numeral-lex &
                           [SYNSEM.NON-LOCAL.QUE <! !>].

temp_numeral-dur-lex := temp_numeral-basic-lex &
                         [SYNSEM [NON-LOCAL.QUE <! !>,
				  LOCAL.CONT.RELS <! #key !>,
				  LKEYS.KEYREL #key]].

;;; FCB 2003-08-14 食事 中 juu/chuu 
;;; Should probably be more of an operator
;;; should take an event noun/temporal noun as argument ???

temp_numeral-dur-suffix-lex := temp_numeral-dur-lex &
			       [SYNSEM.LOCAL [CAT.HEAD.J-POSTHEAD right,
					      BAR -]].


temp_numeral-dur-whq-lex := temp_numeral-lex &
                            [SYNSEM [NON-LOCAL.QUE <! #top !>,
                                     LOCAL.CONT.HOOK.LTOP #top]].


; (MS 2005-11-09) These all seem to have "mo" affixes.

affix-noun-lex := n-lex &
                  [SYNSEM [LOCAL [CAT [HEAD [MOD null,
                                             C-MOD null,
                                             J-SPEC null,
                                             QUANTIFIABLE -,
                                             COP-ARG -],
                                       VAL noun_sc & [SPR #spr]],
                                  CONT common-noun-sem-type &
                                      [HCONS <! !>,
				       HOOK.INDEX #i,
                                       RELS <! #key !>],
                                  CTXT.BACKGROUND <! !>,
				  ARG-S #spr,
                                  BAR +],
			   LKEYS.KEYREL #key & [ARG0 #i],
                           NON-LOCAL [QUE <! !>,
				      AFFIX <! mo !> ]]].
                                       
;;;;;;;;;;;;;;;;;; numeral classifiers ;;;;;;;;;;;;;;;;;;;;;;;

; (ERB 2001-08-06) Redoing numeral-classifiers along with new analysis
; of number names.


; (ERB 2001-12-05) spr-obj-num-cl-lex has slightly different semantic constraints,
; so replace num-cl-sem-type here with num-cl-sem-type-super and further
; constrain on subtypes.

; (MS 2002-02-01) added some necessary restrictions.

numeral-classifier := lexical_sign-word &
[ SYNSEM [ LOCAL [ CAT.HEAD num-cl_head &
			    [KEYS [KEY quantity_rel]],
                   CONT num-cl-sem-type-super & [MSG no-msg],
                   BAR + ],
           NON-LOCAL [QUE <! !> ,
                   AFFIX <! !>]],
  J-NEEDS-AFFIX -,
  INFLECTED +].

; (ERB 2004-1-16) New semantic analysis has num-cls introducing more
; relations, with the total number depending on the semantic type.

;spr-only-num-cl-lex := numeral-classifier &
;[ SYNSEM [ LOCAL [ CAT [VAL spr-arg &
;                              [ SPR #spr & [FIRST [OPT - ,
;					   LOCAL [ CAT [ HEAD int_head &
;							      [ ST-ALONE + ],
;							 VAL saturated ],
;						   CONT.HOOK [LTOP #handle,
;							      INDEX #ind,
;							      XARG #arg]]]]],
;			HEAD.KEYS [KEY quantity_rel, ALTKEY #altpred]],
;		   ARG-S #spr,
;		   CONT num-cl-sem-type &
;			   [HOOK [XARG #arg,
;				  INDEX #ind],
;			    RELS <! #key & [ARG0 #ind,
;					    ARG1 #arg] !>,
;			    MSG no-msg]],
;	   LKEYS [KEYREL #key & quantity-relation & [AMOUNT #handle],
;		  ALTKEYREL.PRED #altpred]]].

; (ERB 2004-1-18) The SPR should have its XARG coindexed with
; the modified noun's MOD-IND value and the LTOP of the NumCl.
; (The numerals identify that XARG with the ARG1 of their card-rel.)

; (ERB 2004-1-18) We don't actually wan't the SPR's LTOP to 
; be the same as the NumCl's LTOP, as in the case of measure-num-cl-lex
; this shouldn't be the case (or we end up with the noun-rel
; for the measure unit and the noun-rel of the modified NP sharing
; a handle.)  Move this constraint onto appropriate subtype.
; Likewise for the MOD-IND = XARG.  True of individuating numeral
; classifiers, but not of measure numeral classifiers.  Move
; to appropriate subtypes.


spr-only-num-cl-lex := numeral-classifier &
[ SYNSEM [ LOCAL [ CAT [ VAL spr-arg &
                              [ SPR #spr &
                                   [FIRST [OPT - ,
					   LOCAL [ CAT [ HEAD int_head &
							      [ ST-ALONE + ],
							 VAL saturated ],
						   CONT.HOOK.INDEX #arg]]]]],
		   ARG-S #spr,
		   CONT num-cl-sem-type &
			    [MSG no-msg,
			     HOOK.XARG #arg]]]].

; (ERB 2001-08-21) For "numeral classifiers" that go before the
; numbers, i.e., $, ＄, ￥...
; I'm leveraging the fact that ordinary numeral classifiers never
; have objects.  So all numeral classifiers are HEAD num-cl, and
; num-cl is a subtype of init_head.

; (ERB 2001-09-12) I found one of these that can be a modifier ("No."),
; so I'm changing the types to cross-classify the order and the
; possible MOD values.

; (ERB 2004-1-18) These also will make no semantic contribution in
; the new analysis. ... except to hook up the XARG and LTOP of the
; COMPS element to the appropriate values. ... but this works differently
; for measure and individuating numeral classifiers.

obj-only-num-cl-lex := numeral-classifier &
 [ SYNSEM.LOCAL [CAT [VAL obj-arg &
			[ COMPS #comps & 
				[FIRST [OPT - ,
					LOCAL [ CAT [ HEAD int_head &
							   [ ST-ALONE + ],
						      VAL saturated ]]]]]],
		  ARG-S #comps,
		  CONT num-cl-sem-type &
			  [ MSG no-msg ]]].

; (ERB 2001-12-05) Some numeral classifiers take both a specifier and
; an object, namely those that can take 半 as an object.  (In 二年半,
; 年 has to be the head for semantic reasons.)

; (ERB 2004-1-18) measure-num-cl-lex is now contributing a whole mess
; of relations.  Need to allow cross-classification with this type
; without creating conflicting specifications on the RELS value.
; Use LKEYS.ALTKEYREL to stash the plus rel, and then pull it on in
; the relevant subtype.  Also, add constraints so that the XARG
; of the han_rel gets bound properly.  Mention of XARG looks okay
; here, because it's not related to anything in the MOD value.

spr-obj-num-cl-lex := numeral-classifier &
[ SYNSEM [ LOCAL [ CAT [ VAL spr-obj-arg &
                                [ SPR.FIRST #spr &
					    [OPT - ,
					     LOCAL [ CAT [ HEAD int_head &
								[ ST-ALONE + ],
							   VAL saturated ],
						     CONT.HOOK [ LTOP #spr_h,
								 XARG #xarg ]]],
				  COMPS.FIRST #comps &
					    [OPT - ,
					     LOCAL [ CAT.HEAD han_head,
						     CONT.HOOK [ LTOP #obj_h,
								 XARG #xarg ]]]]],
		   ARG-S < #spr , #comps >],
	   LKEYS.ALTKEYREL plus-relation &
		           [ ARG1 #xarg,
			     TERM1 #spr_h,
			     TERM2 #obj_h ]]].

                         

; (ERB 2001-09-13) Type for extra entries of "No." and "bangou"
; that attach to numbers already marked by gou or ban.  This will
; get strings like
;
; 口座No.1234号を閉じる
;
; and also unfortunately strings like
;
; 口座No.No.1234を閉じる
;
; and providing double parses for strings like
;
; 口座No.1234を閉じる
;
; there is presumably real (two-way) amibguity to both of these:
; as 番号 is also a noun.
;
; 口座番号1234を閉じる
; 口座番号1234号を閉じる
;
; I don't know how to rule this out.  The semantic representations
; will reflect Atusko's intuitions that there's something redundant
; here.
;
; (ERB 2001-09-13) This creates so much ambiguity, we should probably wait
; until the data requires it.
;

; Types for different MOD possibilities. 
; (ERB 2004-1-18) Francis has convinced me that there is also an
; ambiguity in the case of mensural classifiers (e.g., 円、メートル、
; etc) between direct modification and the anaphoric use, linked 
; to the head noun by の.  Therefore, this dimension of classification
; is no longer mod v. nomod, but individuating vs. measure.  I
; expect to see some more types in here as we extend the analysis
; to other NumCl types.

; (ERB 2001-11-28) Grab MOD-IND and MOD-HAND instead of INDEX
; and LTOP.  Also, these are intersective modifiers.

; (ERB 2004-1-18) Put constaints on semantics etc for individuating
; numeral classifiers here.

; (ERB 2004-1-16) Per Francis, the individuate-rel can be left
; implicit.  Presumably an inference engine could get it from 
; the card-rel. No need for that extra quant-rel either.

; (ERB 2004-1-18) Constraints on the SPR don't belong here,
; as a few oddballs actually take a COMPS instead.  

; (MS 2004-12-22) no MOD-IND/MOD-HAND


individuating-num-cl-lex := numeral-classifier &
  [ SYNSEM.LOCAL [ CAT.HEAD num-cl-mod_head & 
			    [ MOD < [ LOCAL intersective_mod &
					    [ CONT.HOOK [ LTOP #ltop,
							  INDEX #ind ]]]>],
		   CONT [ RELS <! !>,
			  HCONS <! !>,
			  HOOK [ INDEX #ind,
				 LTOP #ltop ] ]]].


; (ERB 2002-01-22) We don't want an attachment ambiguity between
; posthead NumClPs and prehead modifiers.  Restrict posthead
; NumClPs to modifying things that are [NUCL +].  (These same
; guys also modify PPs, but those are [NUCL bool] from the P,
; regardless of what's inside, so this shouldn't pose any problems.
; (Famous last words!)  This leads to funny looking trees (because
; the supposedly floated quantifier is attaching low), but the MRS
; looks fine, so leave it for now.

; (MS 2005-01-07) Changing the head from num-cl-n-or-p-mod_head to num-cl-nmod_head,
; because I don't need the p-modification any more, because I have introduced the 
; floating rules.

anymod-ind-num-cl-lex := individuating-num-cl-lex &
[ SYNSEM.LOCAL.CAT.HEAD num-cl-nmod_head &
                        [ MOD < [LOCAL.NUCL nucl_plus ] > ]].

; (ERB 2001-09-12) Some num-cl like things can't "float" (i.e., show 
; up outside the PP.  So these have a more specific MOD value).

noun-mod-ind-num-cl-lex := individuating-num-cl-lex &
[ SYNSEM.LOCAL.CAT.HEAD num-cl-nmod_head ].

; (FCB 2005-02-10) Adverbial numeral classifiers
; this is a supertype for event and floating classifiers
;;; (FCB 2005-01-28) added J-POSTHEAD left so they only modify following verbs

adv-num-cl-lex := numeral-classifier &
[ SYNSEM.LOCAL [CAT [HEAD num-cl-adv_head &
			  [J-POSTHEAD left,
			   MOD < [ LOCAL.CONT.HOOK [LTOP #top,
						    INDEX #ind]] >],
		     VAL [COMPS < >,
			  SUBJ < >]],
		CONT [HOOK [LTOP #top,
			    INDEX #ind],
		      HCONS <! !>]]].

; (MS 2004-12-27) Floated numeral classifiers, modifying verbs,
; semantically counting their subjects. This type is needed for 
; the lexical rule that makes the numeral classifier float.
; only for non-zpros.

floated-num-cl-lex := adv-num-cl-lex &
[ SYNSEM.LOCAL [CAT [HEAD num-cl-float_head, 
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg]],
		CONT.HOOK.XARG #xarg]].

floated-ind-sbj-num-cl-lex := floated-num-cl-lex &
[ SYNSEM.LOCAL [CAT [HEAD [MOD < [ LOCAL.CONT.HOOK.XARG #xarg & full_ref-ind] >],
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK [XARG #xarg]]]]].

floated-ind-obj-num-cl-lex := floated-num-cl-lex &
[ SYNSEM.LOCAL [CAT [HEAD [MOD < [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [INDEX #xarg & full_ref-ind]] >],
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK [XARG #xarg]]]]].

; (FCB 2005-01-17) Added event classifiers
; 回、遍、度  not sure about 発, 拳 etc


event-num-cl-lex := adv-num-cl-lex & 
[ SYNSEM.LOCAL [CAT [HEAD num-cl-event_head,
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK [LTOP #top,
						     XARG #ind]]],
		CONT [HOOK [LTOP #top,
			    INDEX #ind],
		      RELS <! !>]]].


; (ERB 2004-1-18) These ones are differentiated from the 
; individuating ones by their semantic contribution (and
; reumably eventually by their lack of fussiness in what
; ontological types they'll modify), but they can serve as
; modifiers in the same way.  [We may want to separate out
; the syntactic details of the MOD possibilities from this
; semantic distinction at some point, but leave that for now.]
; For now, say that they can only show up as premodifiers of Ns.

; (ERB 2004-1-18) Need to leave length of RELS list underspecified,
; since spr-obj-num-cl-lex adds a plus-relation to tie in the 
; complements "han".  Furthermore, need to hold off
; on relating the LBL of the noun-relation to number,
; as it might end up being identified with the LTOP
; of the SPR or with the plus-relation.

; (ERB 2004-1-20) At the moment, the only connection between the
; measure phrase semantics and the degree-rel is through label
; sharing.  Dan seemed to think that this might need to be
; elaborated at some point, but this will do for now.  In
; the paper (Bender & Siegel 2004, IJCNLP-04) I'm going to 
; write as if there were another role (EARG, for Extent ARG)
; in the degree-rel to tie things together.
; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (FCB 2005-08-07) fixed 'unspec_adj_rel, specified ARG0 to event

measure-num-cl-lex := numeral-classifier &
[ SYNSEM [ LKEYS.KEYREL #key,
	   LOCAL [ CAT.HEAD num-cl-nmod_head & 
			    [ MOD < [ LOCAL intersective_mod &
					    [ CONT.HOOK [ LTOP #ltop,
							  INDEX #ind ]]]>],
		   CONT [ RELS.LIST < quant-relation &
				[ PRED udef_rel,
				  ARG0 #meas-ind,
				  RSTR #harg ],
				#key & noun-relation &
				[ LBL #larg,
				  ARG0 #meas-ind ],
				degree-relation &
				[ LBL #larg,
				  PRED 'degree_rel,
				  ARG1 #darg ],
				arg1-relation &
				[ LBL #ltop,
				  PRED 'unspec_adj_rel,
				  ARG0 event & #darg, 
				  ARG1 #ind ], ... >,
			  HCONS <! qeq & 
				 [ HARG #harg,
				   LARG #larg ] !>,
			  HOOK [ INDEX #ind,
				 LTOP #ltop ]]]]].

; Cross-classified subtypes:

; (ERB 2001-11-01) I need three separate rules that promote numeral
; classifier phrases to NPs: one for "true" NumCls like 本、匹、etc.,
; one for word like 円、階、etc., and one for numbers used as numeral
; classifiers.  In order to distinguish between the first two, I'm
; going to say that the 本 type is always ALTKEY no_rel, while the
; 円 type is always ALTKEY relation.

; (ERB 2001-11-14) To keep the nominal-numcl rules straight, I'm
; typing the KEY values.  Putting that info in here for lack of a
; better place right now.

; 本、個、匹、人、 etc.

; (MS 2003-09-26) As Matrix Ver.0.5 does not include no-relation any
; more, I'll erase that here.

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-16) Changing semantic analysis to fit with Francis's
; thinking better.  These ones are the "individuating" classifiers.
; Putting all the constraints here for now and worrying about
; generalizing later.

;num-cl-mod-lex := num-cl-lex & anymod-ind-num-cl-lex &
;                  [ SYNSEM.LKEYS [ KEYREL reg-quantity-relation & [PRED 'reg-quantity_rel],
;					 ALTKEYREL no-relation ]].

; (ERB 2004-1-16) Per Francis, the individuate-rel can be left
; implicit.  Presumably an inference engine could get it from 
; the card-rel. No need for that extra quant-rel either.

;num-cl-mod-lex := num-cl-lex & anymod-ind-num-cl-lex &
;  [ SYNSEM.LOCAL [ CAT [ HEAD.MOD.FIRST.LOCAL.CONT [ MOD-IND #ind,
;						     HOOK [ LTOP #ltop ] ],
;			 VAL.SPR.FIRST.LOCAL.CONT.HOOK [ XARG #ind,
;							 LTOP #ltop ] ],
;		   CONT [ RELS <! !>,
;			  MOD-IND #ind,
;			  MOD-HAND #ltop,
;			  HOOK [ INDEX #ind,
;				 LTOP #ltop ] ]]].


; (ERB 2004-1-16) Per Francis, the individuate-rel can be left
; implicit.  Presumably an inference engine could get it from 
; the card-rel. No need for that extra quant-rel either.

; (ERB 2004-1-18) Moved constraints on the semantics of these
; guys up to individuating-num-cl-lex.  Still need to hook up
; XARG and LTOP of SPR to appropriate things.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

num-cl-spr-only-ind-lex := spr-only-num-cl-lex & anymod-ind-num-cl-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ INDEX #xarg,
							LTOP #ltop ],
		       VAL.SPR.FIRST.LOCAL.CONT.HOOK [ XARG #xarg,
						       LTOP #ltop ]]].


; 番、号

; (MS 2003-09-26) As Matrix Ver.0.5 does not include no-relation any
; more, I'll erase that here.

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-18) Hook up XARG and LTOP of SPR with appropriate
; things.  This looks mighty similar to the above.  Consider just
; having this type further constrain the MOD value?
; (MS 2004-12-22) no MOD-IND/MOD-HAND

num-cl-spr-only-ind-nmod-lex := spr-only-num-cl-lex & noun-mod-ind-num-cl-lex &
  [ SYNSEM.LOCAL.CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ INDEX #xarg,
							LTOP #ltop ],
		       VAL.SPR.FIRST.LOCAL.CONT.HOOK [ XARG #xarg,
						       LTOP #ltop ]]].


; 円、年、階、etc

; (ERB 2003-12-03) Norm-relation is gone, so here the type of ALTKEY
; will be noun-rel.  It doesn't really matter what it is exactly, as
; long as it contrasts with no-relation, because the only information
; we take from it presently is the PRED value.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Constraint length of RELS list and 
; relate SPR..LTOP/XARG to noun-relation.  

num-cl-spr-only-meas-lex := spr-only-num-cl-lex & measure-num-cl-lex &
  [ SYNSEM [ LKEYS.KEYREL [ LBL #lbl,
			    ARG0 #xarg ],
	     LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
							 XARG #xarg ],
		     CONT.RELS <! *top*, *top*, *top*, *top* !> ]]].

; ￥、＄、etc.

; (ERB 2003-12-03) Norm-relation is gone, so here the type of ALTKEY
; will be noun-rel.  It doesn't really matter what it is exactly, as
; long as it contrasts with no-relation, because the only information
; we take from it presently is the PRED value.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Constraint length of RELS list and 
; relate COMPS..LTOP/XARG to noun-relation.  


num-cl-obj-only-meas-lex := obj-only-num-cl-lex & measure-num-cl-lex &
  [ SYNSEM [ LKEYS.KEYREL [ LBL #lbl,
			    ARG0 #xarg ],
	     LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
							   XARG #xarg ],
		     CONT.RELS <! *top*, *top*, *top*, *top* !> ]]].

; numbers used as numcls

; (MS 2003-09-26) As Matrix Ver.0.5 does not include no-relation any
; more, I'll erase that here.

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.


num-cl-obj-only-nmod-ind-lex-super := obj-only-num-cl-lex & noun-mod-ind-num-cl-lex.

; No., 番号

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.


num-cl-obj-only-nmod-ind-lex := num-cl-obj-only-nmod-ind-lex-super.

; (ERB 2001-09-13) This creates so much ambiguity, we should probably wait
; until the data requires it.

;num-cl-spr-obj-nmod-lex := spr-obj-num-cl-lex & noun-mod-ind-num-cl-lex.

; 年、 時、ヶ月 etc. with 半

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Pull plus-relation from ALTKEYREL onto RELS list,
; relate its LBL to LBL of noun-relation in KEYREL, ARG1 to ARG0.

num-cl-spr-obj-meas-lex := spr-obj-num-cl-lex & measure-num-cl-lex &
   [ SYNSEM [ LKEYS [ KEYREL [ LBL #lbl,
			       ARG0 #xarg ],
		      ALTKEYREL #altkey & [ LBL #lbl,
					    ARG1 #xarg ]],
	     LOCAL [ CONT.RELS <! *top*, *top*, *top*, *top*,
				   #altkey !> ]]].







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic-subcategorizing-n-lex := n-lex & 
                         [SYNSEM [LOCAL [CAT [HEAD ordinary_noun_head-avm &
                                                   [QUANTIFIABLE -],
                                              VAL subcategorizing-noun_sc &
						   [SPR.FIRST #spr,
						    COMPS #comps]],
                                         CONT [HCONS <! !>],
                                         BAR +,
					 ARG-S < #spr . #comps >],
                                  NON-LOCAL [QUE <! !>,
                                          AFFIX <! !>]]].

subcategorizing-n-lex := basic-subcategorizing-n-lex & 
                         [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
				  LOCAL.CONT common-noun-sem-type &
						 [HOOK.INDEX #i,
						  RELS <! #key !>]]].

subcategorizing-poss-n-lex := subcategorizing-n-lex &
                              [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE nattr]].

; (MS 2001-12-19) This is 'only' (DAKE, NOMI) and 'each' (GOTONI). I'll make the semantics parallel to the Lingo examples.

temp_mod-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD temp_mod_head,
                                 VAL saturated],
			    ARG-S < >,
                            CTXT.BACKGROUND <! !>],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].


; (MS 2003-12-19) Matrix 0.6

temp_nmod-lex := temp_mod-lex & 
            [SYNSEM [LKEYS.KEYREL #key,
		     LOCAL [CAT.HEAD temp_nmod_head &
				   [MOD < [LOCAL [CAT.VAL saturated,
						  CONT.HOOK.INDEX #arg]]> ],
			   CONT simple-adj-sem-type &
				    [RELS <! #key & adj-relation & [ARG1 #arg ] !>,
				     HOOK.INDEX #arg,
				     HCONS <! !>]]]].

; (MS 2005-11-09) Subtype in order to get rid of skip files.
; This shouldn't undergo the empty rules.


temp_nmod-nonempty-lex := temp_nmod-lex &
			  [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun_head-avm & [EMPTY +]] > ].
			  







; (ERB 2001-11-28) Constrain these to head-adj-1 and use
; MOD-IND/MOD-HAND.
; (MS 2003-10-29) There was a mistake on the RELS that prevented the RELS to pass up.
; (MS 2004-12-22) use HOOK instead of MOD-IND/MOD-HAND

noun_mod-lex := lexical_sign-word &
            [SYNSEM [LKEYS.KEYREL #key & [ARG1 #inst, 
					  LBL #handle],
		     LOCAL [CAT [HEAD noun_mod_head-avm &
				      [MOD < [LOCAL intersective_mod &
						    [ CONT.HOOK [INDEX #inst,
								 LTOP #handle]]] > ], 
				 VAL saturated],
			    ARG-S < >,
			    CONT simple-verb-sem-type &
				[RELS <! #key !>,
                                 HCONS <! !>],
                            BAR -],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]], 
             INFLECTED +].

; (ERB 2002-01-10) Some are prehead, like 単なる ...

noun_mod-lex-l := noun_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD left ].

; (MS 2005-11-09) Subtype to get rid of skip files.

noun_mod-lex-l-relational := noun_mod-lex-l &
			     [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD relational_noun_head ].

; (ERB 2002-01-10) ... and some are posthead, like 等 (distinct
; from particle use of 等)  (Assuming this is intersective, may
; not be.)

noun_mod-lex-r := noun_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right ].


; (MS 2005-07-05) changed RELS.LIST.FIRST.LBL #handle to LTOP

pp_mod-lex := lexical_sign-word &
            [SYNSEM [LKEYS.KEYREL #key & [ARG1 #inst, 
					  LBL #handle],
		     LOCAL [CAT [HEAD pp_mod_head-avm &
				      [MOD < [LOCAL intersective_mod &
						    [ CONT [HOOK [XARG #inst,
								  LTOP #handle]]]] > ], 
				 VAL saturated],
			    ARG-S < >,
			    CONT simple-adj-sem-type &
				[RELS <! #key !>,
                                 HCONS <! !>],
                            BAR +],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]], 
             INFLECTED +].


pp_mod-lex-r := pp_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right ].




; (MS 2001-10-23) this shall be for ookina, chiisana
; (FCB 2005-04-09) linked LBL so that it scopes
; should really reify some of this out with i-adj and na-adj I suppose
pred-adj-lex := lexical_sign-word &
            [SYNSEM [LOCAL [CAT [HEAD verb_head-avm &
                                      [MOD < [LOCAL intersective_mod & [CAT [HEAD ordinary_noun_head,
									     VAL saturated]]] >,
                                       MARK null,
                                       C-MOD null,
                                       J-SPEC null,
                                       J-POSTHEAD rels,
                                       H-TENSE no_tense,
                                       FIN +,
                                       AUX aux_minus,
                                       COP -,
                                       VN -,
                                       ADJ -,
                                       LIGHT -,
                                       MAIN-PRD -,
                                       COP-ARG -], 
                                 VAL sbj-arg &
                                      [SUBJ #sbj & [FIRST.LOCAL.CONT.HOOK.INDEX #sbjind]]],
			    ARG-S #sbj,
                            CONT [RELS <! #key !>,
				  HOOK [XARG #sbjind,
					INDEX #ind,
					LTOP #top],
                                  HCONS <! !>]],
		     LKEYS.KEYREL #key & 
			   [LBL #top,
			    ARG0 #ind,
			    ARG1 #sbjind],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]], 
             INFLECTED +].


; (MS 2005-11-09) Subtypes in order to get rid of skip files.

hon-prefix-lex := lexical_sign-affix &
                  [SYNSEM [LOCAL [CAT [HEAD hon-prefix_head,
                                       VAL saturated],
				  ARG-S < >,
                                  CONT [RELS <! !>,
                                        HCONS <! !>],
                                  CTXT.BACKGROUND <! !>,
                                  BAR -],
                           NON-LOCAL [QUE <! !>,
                                   AFFIX <! !>]], 
                   INFLECTED +].

hon-prefix2n-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [HEAD ordinary_noun_head,
							       VAL.SPR 1-list ]]> ].

hon-prefix2vn-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD vn_head ] > ].

hon-prefix2na-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD na-adj_head ] > ].



; (ERB 2001-09-06) Sentences with commas in them have broken HCONS values.  So 
; I'm adding HCONS <! !> to see if that helps.                   


; (ERB 2002-01-02) To the extent that punctuation doesn't contribute
; semantically, all of these guys should have empty WLINK values.

; (MS 2003-08-22) Added scopal_mod information just to avoid spurious ambiguity.
; (FCB 2005-04-12) To get the MRS to scope link LTOP.

comma-lex := lexical_sign &
             [SYNSEM [LOCAL [CAT [VAL saturated,
				  HEAD.MOD < [LOCAL scopal_mod &
						    [CONT.HOOK.LTOP #ltop]] >],
			     ARG-S < >,
                             CONT[ HOOK.LTOP #ltop,
                                   RELS <! !>,
                                   HCONS <! !> ],
                             CTXT.BACKGROUND <! !>],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]],
              INFLECTED +].

comma-pmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-pmod_head].

comma-advmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-advmod_head].

comma-sapmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-sapmod_head].

comma-infvmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-infvmod_head].

comma-vmod1-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-vmod1_head].

comma-vmod2-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-vmod2_head].

comma-interjmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-interjmod_head].

; (ERB 2002-01-14) Special comma entry that picks up infinitival
; verbs and gives them a CMOD value.  To get semantics right,
; copy up LTOP, INDEX, MOD-IND and MOD-HAND from the OBJ.

; (ERB 2002-01-15) Restrict this to OBJs that are C-MOD null to
; keep real TE forms out.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

comma-lex-2 := lexical_sign &
[SYNSEM [LOCAL [CAT [ VAL obj-arg & [ UNSAT +,
				      COMPS obl-1-arg & #comps &
					    [FIRST.LOCAL [ CAT [ HEAD verb_head &
								      [ FIN -,
									ADJ -,
									VN -,
									C-MOD null,
									MODUS infinitive],
								 VAL saturated ],
							   CONT [ HOOK #hook ]]]],
		      HEAD punct_head2],
		ARG-S #comps,
                CONT[ RELS <! !>,
                      HCONS <! !>,
                      HOOK #hook ],
                CTXT.BACKGROUND <! !>],
         NON-LOCAL [QUE <! !>,
                 AFFIX <! !>]],
 INFLECTED +].


parenthesis-end-lex := lexical_sign &
             [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg & 
				   [COMPS obl-2-args & #comps &
					  < [LOCAL [CAT [HEAD head & [QUANTIFIABLE +],
							   VAL saturated],
						      CONT.HOOK #hook]],
					      [LOCAL.CAT.HEAD parent-init_head] >],
				  HEAD parent-end_head], 
			     ARG-S #comps,
			     CONT[ HOOK #hook,
				   RELS <! !>,
				   HCONS <! !> ],
			     CTXT.BACKGROUND <! !>],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]],
              INFLECTED +].


parenthesis-init-lex := lexical_sign &
                        [SYNSEM [LOCAL [CAT [HEAD parent-init_head,
                                             VAL saturated],
					ARG-S < >,
                                        CONT[ RELS <! !>,
                                              HCONS <! !> ],
                                        CTXT.BACKGROUND <! !>],
                                 NON-LOCAL [QUE <! !>,
                                         AFFIX <! !>]],
                         INFLECTED +].




quotation-name-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL saturated,
                                           HEAD quotation-name-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].



quotation-name-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					    [COMPS obl-2-args & #comps &
						   < [LOCAL.CAT [HEAD name_head,
							     VAL saturated]],
						 [LOCAL.CAT.HEAD quotation-name-init_head] > ],
					   HEAD quotation-name-end_head],
				      ARG-S #comps,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +]. 


quotation-noun-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL saturated,
                                           HEAD quotation-noun-init_head],
				      ARG-S < >,
                                      CONT  [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


quotation-noun-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL [CAT [HEAD noun_head,
									VAL saturated],
                                                                    CONT.HOOK #hook ]],
						 [LOCAL.CAT.HEAD quotation-noun-init_head] > ],
					   HEAD quotation-noun-end_head],
				      ARG-S #comps,
                                      CONT [ HOOK #hook,
                                             RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +]. 


quotation-sentence-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL saturated,
                                           HEAD quotation-sentence-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].

; (MS 2004-08-24) linked INDEX and XARG to INDEX and XARG of the complement.
; (MS 2004-12-15) we need to link the whole HOOK, which can then be accessed by 
; conjunctions (「 居る 」 や 「 来る 」 や 「 行く 」 の 尊敬語 。)

quotation-sentence-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL [CAT [HEAD verb_head,
								    VAL saturated],
							       CONT [ HOOK #hook]]],
						       [LOCAL.CAT.HEAD quotation-sentence-init_head] >],
					   HEAD quotation-sentence-end_head],
				      ARG-S #comps,
				      CONT [ HOOK #hook,
					     RELS <! !>,
					     HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
			       NON-LOCAL [QUE <! !>,
					  AFFIX <! !>]],
		       INFLECTED +].


quotation-sap-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL saturated,
                                           HEAD quotation-sap-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


quotation-sap-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL.CAT [HEAD noun_head,
							     VAL saturated]],
						 [LOCAL.CAT.HEAD quotation-sap-init_head] >],
					   HEAD quotation-sap-end_head],
				      ARG-S #comps,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


; (MS 2004-12-20) This is for definition sentences, such as 「 来る 」 の 尊敬語
; (FCB 2005-06-27) Added ARG0 to message 
quotation-definition-end-lex :=  lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL [CAT [HEAD final_head & [EMPTY -],
								    VAL saturated],
							       CONT.HOOK [LTOP #vlabel,
									  INDEX #vindex]]],
						       [LOCAL.CAT.HEAD quotation-noun-init_head] >],
					   HEAD quotation-definition-end_head],
				      ARG-S #comps,
                                      CONT [HOOK [LTOP #ltop,
						  INDEX #index],
					    RELS <! #key,
						    message & [LBL #arg1,
							       PRED proposition_m_rel,
							       ARG0 #vindex,
							       MARG #marg],
						    quant-relation & 
						  [PRED 'udef_rel,
						   ARG0 #index,
						   RSTR #rstr]  !>,
                                              HCONS <! qeq & [HARG #rstr, LARG #ltop],
						       qeq & [HARG #marg, LARG #vlabel] !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>],
			       LKEYS.KEYREL #key & noun-arg1-relation &
					  [PRED 'nom_rel,
					   ARG0 #index,
					   ARG1 #arg1,
					   LBL #ltop]],
                       INFLECTED +].
                       

ordinary-nohon-n-lex := ordinary-n-lex & [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; (MS 2003-12-19) Matrix 0.6

ordinary-nohon-indef-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY indef_rel].

ordinary-nohon-minusbar-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.BAR -].
ordinary-nohon-plusbar-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.BAR +].

; (MS 2005-11-09) To get rid of skip files.

ordinary-nohon-threepl-n-lex := ordinary-nohon-n-lex & [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN threepl].

ordinary-nohon-plusbar-indefspec-n-lex := ordinary-nohon-plusbar-n-lex & [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LKEYS.KEYREL.PRED '_indef_n_rel].


; (MS 2004-12-24) Changed the name from ordinary-nohon-minusbar-right-n-lex.
; (MS 2005-07-04) But we have the noun_mod-lex-r and noun_mod-lex-l for these!

;ordinary-suffix-n-lex := ordinary-nohon-minusbar-n-lex & 
;				       [SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right].

; (MS 2004-12-24) Changed the name from ordinary-nohon-minusbar-left-n-lex.

;ordinary-prefix-n-lex := ordinary-nohon-minusbar-n-lex & 
;				       [SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD left].



ordinary-honsubj-n-lex := ordinary-n-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                         CONT.HOOK.INDEX #1,
                                         CTXT [C-INDICES.SPEAKER #2,
                                               BACKGROUND <! obj-honor_rel &
                                                           [POLARITY +,
                                                            HONORER #2,
                                                            HONORED #1] !>]]].

ordinary-honsubj-plusbar-n-lex := ordinary-honsubj-n-lex &
				  [SYNSEM.LOCAL.BAR +].



ordinary-honobj-n-lex := ordinary-n-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
                             CONT.HOOK.INDEX #1,
                             CTXT [C-INDICES.SPEAKER #2,
				BACKGROUND <! obj-honor_rel &
                                                   [POLARITY +,
                                                    HONORER #2,
                                                    HONORED #1] !>]]].







;TITLE

; (MS 2002-1-7) This had to be changed because it's not allowed to have one index identified between two words.
; It's kind of hacked to parallel the English solution. I still believe in the head-specifier construction here.


; (ERB 2002-01-07) We need to use the type title-id_rel so that the
; k2y code can find it and do the right thing.

; (MS 2003-12-19) Matrix 0.6


title-lex  := n-lex & 
              [SYNSEM [LOCAL [CAT [HEAD title_head-avm,
                                      VAL title_sc & 
                                           [SPR #spr & [FIRST [LOCAL.CONT.HOOK [INDEX #nameind,
										LTOP #handle]]]]],
			      ARG-S #spr,
			      CONT nominal-sign-sem-type &
				  [HOOK [INDEX #titleind,
					 LTOP #titlehand],
				   RELS <! #key,
					     [PRED udef_rel,
					      ARG0 #titleind,
					      RSTR #restr],
                                               title-id-relation &
					      [ARG1 #titleind,
					       ARG2 #nameind,
					       LBL #handle] !>,
				   HCONS <! qeq & [LARG #titlehand,
						       HARG #restr]!>],
                                 BAR +],
		       LKEYS.KEYREL #key & 
			     [LBL #titlehand],
                       NON-LOCAL [QUE <! !>,
                               AFFIX <! !>]]].


; (MS 2005-09-30) Let's try to do without this. title-inst-lex should work for locations as well.
; title-loc-lex :=  n-lex & 
;                  [SYNSEM [LOCAL [CAT [HEAD title_head-avm,
;                                       VAL loc-title_sc & [COMPS #comps]],
;				  ARG-S #comps,
;                                  CONT common-noun-sem-type &
;                                      [HOOK.INDEX #i,
;				       RELS <! #key !>],
;                                  BAR +],
;			   LKEYS.KEYREL #key & [ARG0 #i],
;                           NON-LOCAL [QUE <! !>,
;                                   AFFIX <! !>]]].                      
                                     
; (MS 2005-03-15) Institutions can attach to all kinds of names, like 田中大学。

title-inst-lex := title-lex & 
                  [SYNSEM.LOCAL [CAT.VAL.SPR obl-1-arg &
					     [FIRST [LOCAL [CAT.HEAD name_head]]]]].




; (MS 2001-12-14) Changing the SPR from pn_head to noun_head, because some titles (sama) can be attached to functions. 
; e.g. GAKUSEI SAMA. 
; (MS 2005-10-21) I want the title to have its own pred: it's a difference between "san" and "shachou"!

title-pers-lex := title-lex & 
[SYNSEM [LOCAL.CAT.VAL.SPR obl-1-arg &
			   [FIRST [LOCAL [CAT.HEAD noun_head]]]]].


title-pers-honsubj-lex := title-pers-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
               CONT.HOOK.INDEX #1,
               CTXT [C-INDICES.SPEAKER #2,
                     BACKGROUND <! obj-honor_rel &
                                 [POLARITY +,
                                  HONORER #2,
                                  HONORED #1] !>]]].

title-pers-minus-honsubj-lex := title-pers-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
               CONT.HOOK.INDEX #1,
               CTXT [C-INDICES.SPEAKER #2,
                     BACKGROUND <! obj-honor_rel &
                                 [POLARITY -,
                                  HONORER #2,
                                  HONORED #1] !>]]].


;WH-WORDS

; (ERB 2001-10-04) In order to keep adv_np_rule from over applying,
; I'm going to constrain these to be KEY reg-nom_rel.
; (MS 2003-12-19) Matrix 0.6

wh-word-lex  := n-lex &  
                     [SYNSEM [LOCAL [CAT [VAL noun_sc & [SPR #spr & [FIRST.LOCAL.CAT.HEAD.KEYS.KEY whq_rel]],
                                          HEAD temporal-noun_head & [MOD null]],
				     ARG-S #spr,
                                     CONT [HOOK.LTOP #top,
                                           RELS <! #key !>,
                                           HCONS <! !>]],
			      LKEYS.KEYREL #key & reg-nom-relation & [LBL #top],
                              NON-LOCAL [QUE <! #top !>,
                                      AFFIX <! !>]]].

; (ERB 2001-09-19) We were getting massive overgeneration in 
; sentences like Xはどこですか because the SUBCAT values of どこ
; which is an instance of this type was completely underspecified.
; Fixing that.

; (ERB 2001-09-19) Sentences with いつ and どこ aren't producing
; scopable MRSs, so I'm working on the semantics of this type.
; Also, I don't see why どこ is a temp_rel, so I'm going to split
; this type.


; (ERB 2001-11-14) Adding dokoka and itsuka, which have a lot
; in common with doko and itsu, so I'm making a supertype.


quant-word-temp-or-place-lex := n-lex &
                    [SYNSEM [LOCAL [CAT [ HEAD temporal-noun_head & [MOD null],
                                          VAL saturated ],
				    ARG-S < >,
                                    CONT [RELS <! #key & noun-relation &
                                                    [ LBL #h,
                                                      ARG0 #ind ],
                                                    quant-relation & 
                                                    [ ARG0 #ind,
                                                      RSTR #h2 ] !>,
                                           HCONS <! qeq &
                                                     [ HARG #h2,
                                                       LARG #h ] !> ]],
			     LKEYS.KEYREL #key,
                             NON-LOCAL [AFFIX <! !>]]].

wh-word-temp-or-place-lex := quant-word-temp-or-place-lex &
[ SYNSEM [ LOCAL.CONT [ RELS.LIST.REST.FIRST.PRED 'wh_rel,
                        HOOK.LTOP #top ],
           NON-LOCAL.QUE <! #top !> ]].

indef-word-temp-or-place-lex := quant-word-temp-or-place-lex &
[ SYNSEM [ LOCAL.CONT.RELS.LIST.REST.FIRST.PRED indef_rel,
           NON-LOCAL.QUE <! !> ]].

; (ERB 2001-10-03) Chaning the hierarchy for temporal relations.
; いつ behaves like 去年 or 翌日 in terms of occurring as a modifier
; without に, so it's relation is a non-future-date_rel.  (Was
; temp_rel.)

wh-word-temp-lex := wh-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL non-future-date-relation     ].

wh-word-place-lex := wh-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL place-relation ].

wh-word-person-lex := wh-word-temp-or-place-lex &
[ SYNSEM [LOCAL.CAT.HEAD.KEYS.KEY pron_rel,
	  LKEYS.KEYREL  pron-relation]].

wh-word-thing-lex := wh-word-temp-or-place-lex &
[ SYNSEM [LOCAL.CAT.HEAD.KEYS.KEY pron_rel,
	  LKEYS.KEYREL  pron-relation]].


; (ERB 2001-11-14) itsuka and dokoka.

indef-word-temp-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL non-future-date-relation ].

indef-word-place-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL place-relation ].

; (ERB 2001-11-14) dareka

indef-word-person-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL reg-nom-relation & [ PRED 'person ]].

; (ERB 2001-10-04) My new adv_np_rule, meant for date expressions,
; is applying to いくら because the type of its key isn't sufficiently
; constrained.  I'm going to say it's a reg-nom_rel for now.

wh-word-quantity-lex  := n-lex &
                    [SYNSEM [LOCAL [CAT [HEAD temporal-noun_head & [MOD null],
                                         VAL noun_sc & [SPR #spr & [FIRST.LOCAL.CAT.HEAD.KEYS.KEY whq_rel]]],
				    ARG-S #spr,
                                    CONT [RELS <! #key,
                                                   [PRED 'part-of_rel,
                                                    LBL #h1,
                                                    ARG0 #x1],
						quant-relation & 
						[PRED udef_rel,
						 ARG0 #x1,
						 RSTR #h2]!>,
                                          HCONS <! qeq & [HARG #h2,
                                                           LARG #h1] !>,
                                          HOOK.LTOP #top]],
			     LKEYS.KEYREL #key & reg-nom-relation,
                             NON-LOCAL [QUE <! #top !>,
                                     AFFIX <! !>]]].

                  



wh-word-honsubj-lex := wh-word-person-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
               CONT.HOOK.INDEX #1,
               CTXT [C-INDICES.SPEAKER #2,
                     BACKGROUND <! obj-honor_rel &
                                 [POLARITY +,
                                  HONORER #2,
                                  HONORED #1] !>]]].


; (MS 2001-10-18) A new analysis for koto that takes a VP.
; (ERB 2002-01-14) In an attempt to rein in non-prop GA, I made
; things like "tabeta" [SMOD unmarked].  Change the requirement
; on the SPR here from [SMOD decl] to [SMOD unmarked].
; (MS 2003-10-08) Problems with Matrix 0.5?
; (FCB 2004-01-07) Fixed problem with koto HOOK by coindexing INDEX with ARG0
; (MS 2004-12-17) But it should not take an empty copula.
; (MS 2005-01-26) BAR + on the SPR is not right, VNs for nom-pred-vn-lex are not BAR +
; (FCB 2005-03-01) but we need BAR+ on the SPR for nom-pred-lex
; (MS 2005-06-24) The verb should be plain form: "食べること", "*食べますこと"
; (FCB 2005-06-27) Added ARG0 to message 

nom-pred-lex-basic := nom-lex & 
       [SYNSEM [LOCAL [CAT [VAL.SPR.FIRST [LOCAL [CONT.HOOK [LTOP #verb-hand, INDEX #verb-index],
						 CAT [HEAD verb_head & [MAIN-PRD -,
									MODUS uttmodus,
									FORMAL.AHON -,
									SMOD unmarked,
									EMPTY -]],
						 BAR bool]]],
                      CONT  nom-pred-sem-type &
                          [RELS <! [ARG0 #i,
				    PRED #k-pred,
                                     LBL #nom-hand,
                                     ARG1 #prpstn-hand],
                                  quant-relation & 
				 [ARG0 #i, 
				  PRED udef_rel,
				  RSTR #restr],
                                  message &
                                          [PRED proposition_m_rel,
					   LBL #prpstn-hand,
					   ARG0 #verb-index,
					   MARG #soa] !>,
                           HOOK [LTOP #nom-hand,
				 INDEX #i],
                           HCONS <! qeq &
                                   [HARG #restr,
                                    LARG #nom-hand],
                                   [HARG #soa,
                                    LARG #verb-hand] !> ]],
		LKEYS.KEYREL.PRED #k-pred]].

; (FCB 2005-03-01) added BAR+ on the SPR for nom-pred-lex
; removes spurious ambiguity for e.g., (do-parse-tty "見積もる こと")
nom-pred-lex := nom-pred-lex-basic & 
 [SYNSEM.LOCAL.CAT [VAL nom_sc & [SPR.FIRST.LOCAL[ CAT.VAL saturated,
						   BAR +]]]].

nom-pred-vn-lex := nom-pred-lex &
		   [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD vn_head].

nom-exceptional-pred-lex :=  nom-pred-lex &
			     [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].




; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.

nom-common-lex := nom-lex & lexical_sign-word &
                  [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
			   LOCAL [CAT.VAL nom_sc & [SPR.FIRST.LOCAL [CAT.HEAD det_head & [SMOD decl]]],
				  CONT common-noun-sem-type &
							  [HOOK.INDEX #i,
							   RELS <! #key !>,
							   HCONS <! !> ]]]].

nom-exceptional-common-lex := nom-common-lex &
			      [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].

; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.

; (MS 2003-01-15) The co-indexing of the SPRs handel with the LTOP handel leads to not scoping MRSs. Took that out.
; (MS 2003-12-17) Adapting to Matrix Ver. 0.6: unspec_rel is now unspec-compound-relation

; (FCB 2005-04-11) Added  SYNSEM.LOCAL.CAT.HEAD.MOD null, to stop 
; interjections popping up all over the place in (do-parse-tty "これ の こと が 起きる")

nom-dummy-lex := nom-lex & lexical_sign-word &
       [SYNSEM [LOCAL [CAT [VAL nom_sc & [SPR.FIRST.LOCAL [CAT.HEAD nspec-p_head & [SMOD decl],
                                                 CONT [HOOK.INDEX #spri]]]],
                      CONT nom-sem-type &
                          [HOOK.INDEX #i,
                           RELS diff-list & 
                                 <! #key,
                                  unspec-compound-relation & [PRED 'unspec_compound_rel,
							      ARG2 #spri,
							      ARG1 #i] !>,
                           HCONS <! !>]],
		LKEYS.KEYREL #key & [ARG0 #i]]].

nom-exceptional-dummy-lex := nom-dummy-lex &
			     [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].


; (MS 2005-01-27) This seems not to be used any more.

;nom-transitive-lex := nom-lex & lexical_sign-word &
;       [SYNSEM [LOCAL [CAT [VAL nom_sc & [SPR.FIRST.LOCAL [CAT.HEAD nspec-p_head & [SMOD decl];,
;                                                 CONT [HOOK.INDEX #spri]]]],
;                      CONT nom-sem-type &
;                          [HOOK [INDEX #i],
;                           RELS diff-list & 
;                                 <! #key !>,
;                           HCONS <! !>]],
;		LKEYS.KEYREL #key & [ARG0 #i, ARG1 #spri]]].


;;;;;;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- adjectives;;;;;;;;;;;;;;;;;;


adj-lex := lexical_sign-word & 
           [SYNSEM [LOCAL [CAT.HEAD adj_head,
                           BAR +],
                    NON-LOCAL.AFFIX <! !>]].



na-adj-basic-lex := adj-lex & [SYNSEM [LOCAL [CAT [HEAD na-adj-basic_head & [MAIN-PRD -,
									     MOD null],
                                                  VAL adj_sc & [SUBJ #sbj & [FIRST.LOCAL.CONT.HOOK.INDEX #arg]]],
					     ARG-S #sbj,
					     
                                             CONT na-adj-sem-type & [HOOK.XARG #arg,
								     RELS <! #key !>],
                                             BAR +],
				       LKEYS.KEYREL #key & [ARG1 #arg]],
                               J-NEEDS-AFFIX -,
                               INFLECTED +].

na-adj-lex := na-adj-basic-lex & [SYNSEM.NON-LOCAL [QUE <! !>]].

na-adj-negative-lex := na-adj-lex & [SYNSEM [LOCAL.CAT.HEAD.MODUS negative,
                                             NON-LOCAL [QUE <! !>]]].

; (MS 2005-03-30) This seems not to be used any more.
;exceptional-adj-lex := adj-lex & [SYNSEM [LOCAL [CAT [HEAD exceptional-adj_head,
;                                                      VAL adj_sc & [SUBJ #sbj & [FIRST.LOCAL.CONT.HOOK.INDEX #arg]]],
;						 ARG-S #sbj,
;                                                CONT na-adj-sem-type & [RELS <! #key !>,
;									HOOK.XARG #arg],
;                                                BAR +],
;					  LKEYS.KEYREL #key & [ARG1 #arg],
;                                          NON-LOCAL [QUE <! !>]]].

na-adj-wh-lex := na-adj-basic-lex &
             [SYNSEM [NON-LOCAL.QUE <! #top !>,
                      LOCAL.CONT.HOOK.LTOP #top]].

; (MS 2002-05-02) this is for 的 that is separated by CHASEN.
; (MS 2004-12-21) but wrongly assumed that this modifies its noun. it should be the
; head of the phrase in 時間的な継続, such that it can be subcategorized for by な

na-adj-suffix-lex := adj-lex & [SYNSEM [LOCAL [CAT [HEAD na-adj_head & [MAIN-PRD -],
						    VAL sbj-narg_transitive & [COMPS.FIRST [OPT -,
										    LOCAL.CONT.HOOK.INDEX #arg]]],
					       CONT na-adj-sem-type & [RELS <! #key !>,
								       HOOK.XARG #arg]],
					LKEYS.KEYREL #key & [ARG1 #arg],
					NON-LOCAL [QUE <! !>]],
                               J-NEEDS-AFFIX -,
                               INFLECTED +].

;;;;;;;;;;;;;;;;;;;;;;;;;LEXIKAL TYPES -- adverbs;;;;;;;;;;;;;;;;;;


adv-lex := lexical_sign-word & 
           [SYNSEM [LOCAL [CAT  [HEAD adv_head-avm, 
                                 VAL saturated],
			   ARG-S < >,
                           CTXT.BACKGROUND <! !>,
                           BAR +],
                    NON-LOCAL [AFFIX <! !>]],
            INFLECTED +,
            J-NEEDS-AFFIX -].

; (ERB 2001-09-06) HCONS isn't sufficiently constrained on this type.  
; Making it be exactly one thing long.

; (ERB 2001-09-06) Editing the semantics of this type to match
; the English type pp_wh_le.  E.g., how = in which way.
; In Japanese, there are the following instances:
; ikaga = in which way
; dou = in which way
; donokurai = to which extent
; naze = for which reason
; ikani = in which way
;
; (NB ikaga seems to have another use, too.)

; (ERB 2001-09-06) In order to do the above, changing CONT value
; to wh-adv-sem-type.


; (ERB 2001-11-28) Constrain these to intersective head-adj rules.
; Changing ref to KEY.LBL and KEY.ARG0 to MOD-HAND and MOD-IND.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

adv-wh-lex := adv-lex &
             [SYNSEM [NON-LOCAL.QUE <! #head-hd !>,
		      LKEYS [KEYREL #key & [ARG1 #ind,
					    LBL #head-hd],
			     ALTKEYREL #altkey],
		      LOCAL [CAT.HEAD [MOD < [LOCAL intersective_mod &
						    [ CONT.HOOK [ LTOP #head-hd,
							     INDEX #ind]]] >,
				       COP-ARG +,
				       J-POSTHEAD left],
			     CONT wh-adv-sem-type &
				      [HOOK [LTOP #head-hd,
					     INDEX #ind],
				       RELS <! #key , #altkey , quant-relation !> ]]]].

; (ERB 2001-09-06) For dou, which wants to modify a V (i.e., something that is
; HEAD verb & LEX +.

lex-mod-adv-wh-lex := adv-wh-lex &
                      [ SYNSEM.LOCAL.CAT.HEAD.MOD < [LEX +] > ].

; (ERB 2001-09-13) Getting rid of J-POSTHEAD value intersective, in system
; with only two HMRs.  See notes in japgram.tdl and rule-types.tdl.


; (ERB 2001-11-28) Constraining intersective adverbs to stay out of
; head-adjunct-rule3.  

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)

; (MS 2004-11-26) Changing MOD-HAND and MOD-IND in MOD to LTOP and INDEX.

isect-adv-lex := adv-lex &
 [SYNSEM [LOCAL [CAT.HEAD [MOD < [LOCAL intersective_mod & 
					[CONT.HOOK [LTOP #handel,
						    INDEX #ind]]] >,
			   COP-ARG +,
			   J-POSTHEAD left],
		 CONT i-sect-adv-sem-type &
			  [HOOK.INDEX #ind,
			   RELS <! #key !>]],
	  LKEYS.KEYREL #key & adv-relation & 
		[ARG0 event,
		 ARG0.E.TENSE no_tense,
		 ARG1 #ind,
		 LBL #handel],
	  NON-LOCAL.QUE <! !>]].

;a new analysis of degree adverbs is needed here! (MS)

;dim-adv-lex := adv-lex &
;         	[SYNSEM [LOCAL [CAT.HEAD [MOD < [LOCAL.KEYS [KEY [DIM #dim,
;                                                               LBL #handle]]] >,
;                                          J-POSTHEAD left],
;                                CONT dim-adj-sem-type &
;                                                        [RELS <! adj-relation & [ARG1 #dim, LBL #handle] !>]],
;                         NON-LOCAL.QUE <! !>]].
      


; (ERB 2001-11-28) Constraining scopal adverbs to stay out of the
; intersective head-adj rules.

; (ERB 2001-11-30) And making them grab the INDEX and LTOP like
; true scopal modifiers!

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)


scopal-adv-lex := adv-lex &
                  [SYNSEM [LOCAL [CAT.HEAD [MOD < [LOCAL scopal_mod & 
                                                      [ CONT.HOOK [INDEX #ind,
								   LTOP #h2],
							NUCL nucl_plus]] > ],
				  
                                  CONT scopal-adv-sem-type &
                                       [HOOK [INDEX #ind,
					      LTOP #top],
					RELS <! #key !>,
                                        HCONS <! qeq & [HARG #h1,
							LARG #h2] !> ]],
			   LKEYS.KEYREL #key & scopal-adv-relation & [ARG1 #h1,
								      ARG0 #ind,
								      LBL #top],
                           NON-LOCAL.QUE <! !>]].

scopal-adv-regular-lex := scopal-adv-lex &
			  [SYNSEM.LOCAL.CAT.HEAD [J-POSTHEAD left,
						  COP-ARG +]].

; (MS 2005-11-09) To get rid of skip files.

scopal-adv-regular-negmod-lex := scopal-adv-regular-lex &
				 [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.KEYS.KEY "_neg_v_rel" ].

; (MS 2004-12-15) This doesn't have to be COMPS null on the modifiee, otherwise we
; don't get relative-clause-obj-gap rules. But it should be COP-ARG -, such that
; we will not get spurious ambiguity in the case of 人が食べるべきだ

scopal-adv-right2left-lex := scopal-adv-lex &
			  [SYNSEM.LOCAL.CAT.HEAD [J-POSTHEAD right,
						  COP-ARG -,
						  MOD < [LOCAL.CAT.HEAD verb_head] > ]].


; (MS 2005-11-09) To get rid of skip files.
scopal-adv-right2left-presentmod-lex := scopal-adv-right2left-lex &
					[SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD [H-TENSE present,
											  FORMAL.AHON -]].


;;;;;;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- numbers;;;;;;;;;;;;;;;;;;


; (ERB 2001-08-06) Redoing the numbers following Jeff Smith's analysis
; of English number names.

; (ERB 2001-08-07) Took out identification of LBL and MOD's LBL.
; Will be making these MOD none eventually anyway.

; (ERB 2001-08-07) card-lex can no longer modify anything.  They will
; be SPRs of numeral classifiers and other entities.  The MOD none
; constraint is on int_head.

; (ERB 2004-1-16) They're still not modifying anything directly, but
; semantically it's going to look like they are.  So, I've updated the
; definitions of the relevant relations (integer-relation, and its
; subtypes).  Now card-lex needs to identify the ARG1 of the
; const-relation and any plus or times relations (the modified thingy)
; with its XARG, so that other card-lexes and the numeral classifier
; can get at it.  Modify card-lex, card-sem-type, card-with-object and
; card-with-specifier appropriately.


; (ERB 2004-1-18) Making special entry for 何 in numeral classifier
; phrases.  Assume for the moment (probably incorrectly) that
; 何十年 etc are ungrammatical, because I don't know what their
; semantics should look like.  This entry will share some but not
; all of the constraints on card-lex, so I'm going to create a 
; supertype card-lex-super:

card-lex-super := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [ HEAD int_head-avm,
				  VAL [SUBJ null,
				       COMPS 0-1-list & #comps]],
			    ARG-S #comps,
                            CTXT.BACKGROUND <! !>,
                            BAR bool],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]], 
	     INFLECTED +].

card-lex := card-lex-super & 
            [SYNSEM [LOCAL [CAT.HEAD.KEYS.KEY #pred,
			    CONT card-sem-type & [ RELS.LIST.FIRST #key]],
		     NON-LOCAL [QUE <! !>,
				AFFIX <! !>],
		     LKEYS.KEYREL #key & [PRED #pred]]].

; (ERB 2004-1-18) Special type for 何 in numeral classifier phrases.

nan-card-lex := card-lex-super &
 [ SYNSEM.LOCAL [ CAT [ VAL saturated,
			HEAD nan_int ],
		  CONT [ RELS <! quant-relation &
			         [ PRED whq_rel,
				   ARG0 #ind,
				   RSTR #harg ],
			         noun-relation &
			         [ PRED 'number_rel,
				   ARG0 #ind,
				   LBL #larg ],
			         arg12-relation &
			         [ PRED 'unspec_rel,
				   LBL #ltop,
				   ARG1 #xarg,
				   ARG2 #ind ] !>,
			 HCONS <! qeq &
				[ HARG #harg,
				  LARG #larg ] !>,
			 HOOK [ LTOP #ltop,
				XARG #xarg ],
			 MSG no-msg ]]].
				   

; (ERB 2001-08-06) Subtypes of card-lex are cross-classified on
; two dimensions: their value and their j-valence.

card-value :< card-lex.
card-j-valence :< card-lex.

; (ERB 2001-08-06) Subtypes of card-j-valence are cross-classified
; on two dimensions:  Whether or not there's a SPR and whether or
; not there's an OBJ.  This can't be done with optionality, since
; there is a semantic difference between hyaku with a complement
; and hyaku without a complement.

card-specification :< card-j-valence.
card-complementation :< card-j-valence.

card-no-object := card-complementation &
		  [ SYNSEM.LOCAL.CAT.VAL [ COMPS null]].

card-with-object := card-complementation & 
            [SYNSEM [LOCAL [CAT.VAL [ COMPS obl-1-arg &
					    < [LOCAL [ CAT [ VAL saturated,
							     HEAD int_head ],
						       CONT.HOOK [ XARG #xarg,
								   LTOP #term2 ]]] >],
			    CONT [ HOOK.XARG #xarg,
				   RELS.LIST.REST.FIRST plus-relation & 
					     [ ARG1 #xarg,
					       TERM2 #term2 ]]]]].


card-no-specifier := card-specification &
                     [ SYNSEM [ LOCAL.CAT.VAL [ SPR null ],
                                      LKEYS [KEYREL #key,
                                             ALTKEYREL #key ]]].

card-with-specifier := card-specification & 
            [SYNSEM [LOCAL [ CONT.HOOK.XARG #xarg,
			     CAT.VAL.SPR obl-1-arg &
				       [FIRST [LOCAL [ CAT [ VAL saturated,
							     HEAD int_head ],
						       CONT.HOOK [ XARG #xarg,
								   LTOP #factor2 ]]]]],
		     LKEYS [KEYREL.LBL #factor1,
			    ALTKEYREL times-relation & 
				       [ ARG1 #xarg,
					 FACTOR1 #factor1,
					 FACTOR2 #factor2 ]]]].

; (ERB 2001-08-06) Cross-classified subtypes of card-j-valence:

card-with-object-with-specifier := card-with-object & card-with-specifier &
     [ SYNSEM [LKEYS.ALTKEYREL #altkey &
				 [ LBL #term1 ],
		     LOCAL.CONT [HOOK.LTOP #top,
				 RELS <! relation, [ LBL #top,
					       TERM1 #term1 ], #altkey !> ]]].

card-with-object-no-specifier := card-with-object & card-no-specifier &
     [ SYNSEM [LKEYS.KEYREL.LBL #term1,
		     LOCAL.CONT [HOOK.LTOP #top,
			   RELS <! relation, [ LBL #top,
                                                TERM1 #term1 ] !> ]]].

card-no-object-with-specifier := card-no-object & card-with-specifier &
     [ SYNSEM [LKEYS.ALTKEYREL #altkey & [LBL #top],
		     LOCAL.CONT [HOOK.LTOP #top,
				 RELS <! relation, #altkey !> ]]].

card-no-object-no-specifier := card-no-object & card-no-specifier &
     [ SYNSEM.LOCAL.CONT [ RELS <! [ LBL #top ] !>,
                           HOOK.LTOP #top ]].

; (ERB 2001-08-16) Further subtypes based on constraints on SPR for
; big numbers (they're all int4- on the SPR after man, except oku).

card-with-specifier4 := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int4- ].

card-no-object-with-specifier4 := card-no-object-with-specifier & card-with-specifier4.

card-with-object-with-specifier4 := card-with-object-with-specifier & card-with-specifier4.

card-with-specifier4x := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int4x ].

card-no-object-with-specifier4x := card-no-object-with-specifier & card-with-specifier4x.

card-with-object-with-specifier4x := card-with-object-with-specifier & card-with-specifier4x.



; (ERB 2001-08-16) Further subtypes for constraints on SPR for juu, hyaku,
; and sen that takes 2-9 SPR, can stand alone, can be SPR of man, etc. 

card-with-specifier1 := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int1 ].

card-no-object-with-specifier1 := card-no-object-with-specifier & card-with-specifier1.

card-with-object-with-specifier1 := card-with-object-with-specifier & card-with-specifier1.

; (ERB 2001-08-16) For sen that takes ichi as SPR, can be SPR of man, etc.
; can't stand alone.

card-with-specifier_ichi := card-with-specifier &
[ SYNSEM.LOCAL.CAT [ HEAD.ST-ALONE -,
                     VAL.SPR.FIRST.LOCAL.CAT.HEAD int_ichi ]].

card-no-object-with-specifier_ichi := card-no-object-with-specifier & card-with-specifier_ichi.

card-with-object-with-specifier_ichi := card-with-object-with-specifier & card-with-specifier_ichi.

; (ERB 2001-08-06) Subtypes for numbers of different values:

card_ichi := card-value &
             [ SYNSEM [ LOCAL.CAT.HEAD int_ichi,
			LKEYS.KEYREL.CARG "1" ]].

card1 := card-value &
             [ SYNSEM.LOCAL.CAT.HEAD int1 ].

card2 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int2 ].

card3 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int3 ].

card4 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int4 ].

; (ERB 2001-08-16) For the sen that doesn't need a SPR, can be COMPS
; of man, but not SPR of man.

card4z := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int4z ].

card5 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int5 ].

; (ERB 2001-08-21) For ersatz numbers.
card5x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int5x ].

card9 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int9 ].

; (ERB 2001-08-21) For ersatz numbers.
card9x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int9x ].

card13 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int13 ].

; (ERB 2001-08-21) For ersatz numbers.
card13x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int13x ].

card17 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int17 ].

card21 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int21 ].

; (ERB 2001-08-06) Cross-classified subtypes inheriting from both
; card-value and card-j-valence hierarchies.

card_ichi_no_valence := card_ichi & card-no-object-no-specifier.
card_1_no_valence := card1 & card-no-object-no-specifier.
card_2_no_valence := card2 & card-no-object-no-specifier.
card_3_no_valence := card3 & card-no-object-no-specifier.

; (ERB 2001-08-16) For sen that takes no SPR, can't be SPR of man, etc.
card_4_no_valence := card4z & card-no-object-no-specifier.

; (ERB 2001-08-21) For ersatz numbers.
card_4e_no_valence := card4 & card-no-object-no-specifier.
card_5x_no_valence := card5x & card-no-object-no-specifier.
card_9x_no_valence := card9x & card-no-object-no-specifier.
card_13x_no_valence := card13x & card-no-object-no-specifier.

card_2_object_only := card2 & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int1- ].

card_3_object_only := card3 & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int2- ].

; (ERB 2001-08-16) For sen that takes no SPR, can't be SPR of man, etc.
card_4_object_only := card4z & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3-].
  
card_2_spr_only := card2 & card-no-object-with-specifier1.
card_3_spr_only := card3 & card-no-object-with-specifier1.
card_4_spr_only := card4 & card-no-object-with-specifier1.
card_4_spr_only_2 := card4 & card-no-object-with-specifier_ichi.
card_5_spr_only := card5 & card-no-object-with-specifier4.
card_9_spr_only := card9 & card-no-object-with-specifier4x.
card_13_spr_only := card13 & card-no-object-with-specifier4.
card_17_spr_only := card17 & card-no-object-with-specifier4.
card_21_spr_only := card21 & card-no-object-with-specifier4.

card_2_spr_object := card2 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int1- ].

card_3_spr_object := card3 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int2- ].
  
card_4_spr_object := card4 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3- ].

card_4_spr_object_2 := card4 & card-with-object-with-specifier_ichi &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3- ].

; (ERB 2001-08-16) Either kind of sen okay as COMPS.

card_5_spr_object := card5 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int4x ].

card_9_spr_object := card9 & card-with-object-with-specifier4x &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int5- ].

card_13_spr_object := card13 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int9- ].

card_17_spr_object := card17 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int13- ].

card_21_spr_object := card21 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int17- ].

; (ERB 2001-12-05) For 半 in 二年半.  I'm not sure there's
; anything else in this class.

han-lex := lexical_sign-word &
[ SYNSEM [ LOCAL [ CAT [ HEAD han_head,
                         VAL saturated ],
		   ARG-S < >,
                   CONT card-sem-type &
                       [ HOOK.LTOP #top,
                         RELS <! #key !>]],
	    LKEYS.KEYREL #key & [ LBL #top,
				     CARG ".5" ],
           NON-LOCAL [ QUE <! !>,
                    AFFIX <! !> ]]].

;;;;;;;;;;;;;;;;;;;;;;;;;Date expressions;;;;;;;;;;;;;;;;;;;;;;

; ERB (2001-09-24) Overhauling the date expressions.  The general
; plan is treat them as nouns, which take up to three arguments:
; a determiner (この、その、あの、どの）
; an OBJ2 (月 for 日 and 年 for 月)
; an integer as OBJ (1-12 for 月、1-31 for 日、unlimited for 年)
; The first two of these are optional, although ordered.
; The third is obligatory, and must occur right next to the head.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-10-06) date_noun_head-avm instead of ordinary_noun_head-avm,
; because the behaviour in compounds and adjuncts is different:
; 今年三月

date-lex := n-lex & 
[ SYNSEM [ LOCAL [ CAT [ HEAD date_noun_head-avm,
                         VAL [SPR.FIRST #spr &
					[OPT + ,
					LOCAL [ CAT.HEAD det_head,
						CONT det-sem-type &
							 [ HOOK.INDEX ref-ind]]],
			      COMPS #comps,
			      SUBJ null]],
		   ARG-S < #spr . #comps >,
                   CONT date-sem-type & [RELS.LIST.FIRST #key],
                   CTXT.BACKGROUND <! !> ],
	    LKEYS.KEYREL #key,
           NON-LOCAL [QUE <! !>,
                   AFFIX <! !>]]].

; (MS 2003-12-19) Matrix 0.6

date-with-int-lex := date-lex &
                 [ SYNSEM [ LOCAL.CAT.VAL [ COMPS < [OPT - ,
						     LOCAL [ CAT [ HEAD int_head,
								   VAL saturated ],
							     CONT.HOOK.LTOP #h]] >],
			    LKEYS.KEYREL.NUMBER #h ]].

; ERB (2001-08-28) To accomodate Chasen's parsing of 八月 etc as one word


date-no-int-lex := date-lex &
               [ SYNSEM [ LOCAL.CAT.VAL [COMPS 0-1-list ],
			  LKEYS [ ALTKEYREL const-relation &
					    [ LBL #hand ],
				  KEYREL.NUMBER #hand ]]].

; (MS 2004-12-02) For generation, these need PRED values for the prep-mod-relation.

date-with-object2-lex := date-lex &
                         [ SYNSEM.LOCAL [ CAT.VAL [ COMPS < [OPT - ,
							     LOCAL [ CAT.VAL saturated,
                                                                        CONT.HOOK.INDEX #objind ]] >],
					  CONT [ RELS.LIST.REST.FIRST prep-mod-relation &
                                                                       [ PRED 'prep,
									 ARG2 #selfind,
                                                                         ARG1 #objind,
                                                                         LBL #h2 ],
                                                HOOK [LTOP #h2,
						      INDEX #selfind ]]]].

date-no-object2-lex := date-lex &
                      [ SYNSEM.LOCAL.CAT.VAL.COMPS 0-1-list].

date-with-object2-with-int-lex := date-with-object2-lex & date-with-int-lex &
                                  [ SYNSEM.LOCAL.CONT [ RELS <! relation, relation !> ]].

date-no-object2-with-int-lex := date-no-object2-lex & date-with-int-lex &
                                [ SYNSEM.LOCAL.CONT [ RELS <! relation !> ]].

; ERB (2001-08-28) For 八月 etc as single words.

date-with-object2-no-int-lex := date-with-object2-lex & date-no-int-lex &
                                 [ SYNSEM [LOCAL.CONT.RELS <! relation, relation, #altkey !>,
						 LKEYS.ALTKEYREL #altkey ]].

date-no-object2-no-int-lex := date-no-object2-lex & date-no-int-lex &
                              [ SYNSEM [LOCAL.CONT.RELS <! relation, #altkey !>,
					LKEYS.ALTKEYREL #altkey ]].



nichi-lex := date-lex &
             [ SYNSEM.LKEYS.KEYREL dofm-relation ].

gatsu-lex := date-lex &
             [ SYNSEM.LKEYS.KEYREL mofy-relation ].

toshi-lex := date-lex &
             [ SYNSEM.LKEYS.KEYREL yofc-relation     ].

date-ersatz-lex := date-no-object2-no-int-lex &
                   [ SYNSEM.LKEYS [KEYREL.PRED 'dateersatz,
				   ALTKEYREL.CARG 'ersatz ]].

nichi-no-object2-lex := nichi-lex & date-no-object2-with-int-lex.
gatsu-no-object2-lex := gatsu-lex & date-no-object2-with-int-lex.
toshi-no-object2-lex := toshi-lex & date-no-object2-with-int-lex.

nichi-with-object2-lex := nichi-lex & date-with-object2-with-int-lex &
                         [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY mofy_rel ] >].

gatsu-with-object2-lex := gatsu-lex & date-with-object2-with-int-lex &
                         [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel ] >].

; ERB (2001-08-28) For 八月 etc as single words.

1gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "1" ]].

2gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "2" ]].

3gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "3" ]].

4gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "4" ]].

5gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "5" ]].

6gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "6" ]].

7gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "7" ]].

8gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "8" ]].

9gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "9" ]].

10gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "10" ]].

11gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "11" ]].

12gatsu-with-object2-lex := gatsu-lex & date-with-object2-no-int-lex &
                          [ SYNSEM [ LOCAL.CAT.VAL.COMPS <  [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >,
                                           LKEYS.ALTKEYREL.CARG "12" ]].

1gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "1" ]].

2gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "2" ]].

3gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "3" ]].

4gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "4" ]].

5gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "5" ]].

6gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "6" ]].

7gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "7" ]].

8gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "8" ]].

9gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "9" ]].

10gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "10" ]].

11gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "11" ]].

12gatsu-no-object2-lex := gatsu-lex & date-no-object2-no-int-lex &
                          [ SYNSEM [ LKEYS.ALTKEYREL.CARG "12" ]].

;;;;;;;;;;; Other date expressions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (ERB 2001-10-04)  Making a separate type for date nouns,
; as they are semantically already different from ordinary nouns
; and might also have different subcategorization.
; (MS 2001-11-29) Giving those another head type, in order to prevent overgeneration of the adv_np rule.

date-n-lex := n-lex &
              [ SYNSEM [ LOCAL [ CAT [ HEAD date_noun_head-avm,
                                       VAL noun_sc & [SPR.FIRST #spr]],
				 ARG-S < #spr >,
                                 CONT date-noun-sem-type & [HOOK.INDEX #i,
							    RELS <! #key !>],
                                 CTXT.BACKGROUND <! !> ],
			 LKEYS.KEYREL #key &  [ARG0 #i],
                         NON-LOCAL [QUE <! !>,
                                 AFFIX <! !>]]].

; (ERB 2001-10-04) Both of these kinds of nouns can be used
; as adverbs on their own, but only the former can be marked with ni.

; 来年、再来年、来月、来週、前日、前月、翌日

date-noun-lex := date-n-lex &
[ SYNSEM.LKEYS.KEYREL future-date-relation ].


date-noun-minusbar-lex := date-noun-lex &
			  [SYNSEM.LOCAL.BAR -].

; (MS 2005-08-17) This is necessary to prevent spurious ambiguity:
; 間 (kan) is a noun_mod-lex-r and 間 (aida) a date-noun-plusbar-lex.
; The date-noun-plusbar-lex cannot be part of a compound!

date-noun-plusbar-lex := date-noun-lex &
			  [SYNSEM.LOCAL.BAR +].

; 去年、今月、毎日、本日

date-noun-adv-lex := date-n-lex &
[ SYNSEM [LOCAL.CAT.HEAD.FIN -,
	  LKEYS.KEYREL non-future-date-relation ]]. 


date-noun-adv-minusbar-lex := date-noun-adv-lex &
			      [SYNSEM.LOCAL.BAR -].

;;;;;;;;;;;;;;;;;;;;;;;;;Disjunctions for LKB;;;;;;;;;;;;;;;;;;

; (ERB 2001-01-07) Need a type grouping together saps and
; sentence-valid.

utt-valid := final_head.

sentence-valid := utt-valid.

temporal-noun_head := noun_head-avm &
                      [J-SPEC null,
                       QUANTIFIABLE -].

;<TT>
; (TT 2003-08-14) pred-noun 「為」に動詞句を修飾させるため

; temporal-or-nadv_head  := noun_head-avm &
; 		      [QUANTIFIABLE -, 
; 		       J-SPEC null].

; temporal-noun_head := temporal-or-nadv_head.


; nadv_head := temporal-or-nadv_head &
; 	     [MOD null].

; (TT 2003-08-14) <！>要修正: とりあえず、RELATIVE-CLAUSE-RULE で解析が通るようにした。
;                 本来は HEAD-SPECIFIER-RULE を使うべき。

; nadv-lex := n-lex & noun_head-avm &
;               [ SYNSEM [ LOCAL [ CAT [ HEAD nadv_head,
;                                        VAL noun_sc & [SPR.FIRST #spr]],
; 				 ARG-S < #spr >,
; 				 KEYS.KEY #key &  [ARG0 #i],
;                                  CONT nadv-sem-type & [HOOK.INDEX #i,
; 							    RELS.LIST.FIRST #key],
;                                  CTXT.BACKGROUND <! !> ],
; 			 NON-LOCAL [QUE <! !>,
; 				    AFFIX <! !>]]].

; nadv-lex := n-lex & noun_head-avm &
;        [SYNSEM.LOCAL [CAT [HEAD nadv_head, 
; 			   VAL.SPR.FIRST.LOCAL [CAT [HEAD verb_head & [MAIN-PRD bool,
; 								       MODUS uttmodus,
;                                                                         SMOD unmarked],
; 						     VAL saturated],
;                                                  KEYS [KEY.LBL #verb-hand],
;                                                  BAR +]],
;                       CONT  nom-pred-sem-type &
;                           [RELS <! [ARG0 #i,
;                                      LBL #nom-hand,
;                                      ARG1 #prpstn-hand],
;                                   quant-rel & [ARG0 #i, PRED 'udef,
;                                                 RSTR #restr],
;                                   prpstn_rel & [LBL #prpstn-hand,
;                                                 MARG #soa] !>,
;                            HOOK [LTOP #nom-hand],
;                            HCONS <! qeq &
;                                    [HARG #restr,
;                                     LARG #nom-hand],
;                                    [HARG #soa,
;                                     LARG #verb-hand] !> ]]].

;;;</TT>


adj-or-adv_head :< final_head.

numbers_head :< final_head.


;;;;;;;;;;;;;;LEXICAL PRINCIPLES;;;;;;;;;;;;;;;


subj-honor-ctxt := j-ctxt &
                   [C-INDICES.SPEAKER #sp,
                    BACKGROUND <! subj-honor_rel &
                                   [HONORER #sp,
                                    POLARITY bool] !>].





;;;;;;;;;;;;;;VERBAL ENDINGS;;;;;;;;;;;;;;;


; (ERB 2002-01-02) I've made some changes to verbal endings for
; the sake of getting VN + kudasai.  My first idea was to treat
; this kudasai as an sap, like te+kudasai.  This didn't work because
; of sentences with modifiers (including topic-wa, conjunction, etc.)
; that were looking to modify a sentence_valid head.  So, as a 
; second try, making kudasai in VN + kudasai parallel to nasai in
; tabenasai.  This entails adding a vn-vend-rule like the 
; vstem-vend-rule and making most verbal endings require [VN -],
; while the new kudasai requires [VN +].  Because the new kudasai
; is an eventual subtype of v-end-lex, I need to move the constraint
; identifying VN and SPR.VN to appropriate subtypes.

; (ERB 2002-01-14) Likewise the constraint identifying the KEY.LBL
; and LTOP needs to be moved to subtypes.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-24) We need unificable SHON information between v-end and v-stem.


v-end-lex := lexical_sign-affix &
             [SYNSEM j-synsem &
                     [LOCAL [CAT [HEAD v-end_head &
                                       [H-TENSE #tense,
                                        AUX #aux,
					ADJ #adj,
					FORMAL.SHON #shon],
				  VAL [SPR obl-1-arg &
					    [FIRST [LOCAL [CAT [HEAD verb_head & [AUX #aux,
										  ADJ #adj,
										  H-TENSE #tense,
										  FORMAL.SHON #shon],
							       VAL [SUBJ #sbj,
								    COMPS #comps]],
							  ARG-S #arg-s,
							   CONT [HOOK #hook],
							  BAR -]]],
				       SUBJ #sbj,
				       COMPS #comps]],
			     ARG-S #arg-s,
			     CONT verb-sem-type &
				 [HOOK #hook & [INDEX  event & 
						      [E [TENSE #tense]]]],
                             BAR -,
                             NUCL nucl_plus],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]]].

; (MS 2002-1-9) This needs a subject: 雨が降りそうだ
; (MS 2003-10-08) Problems with Matrix 0.5?
; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-03) The PRED value should be copied into the relation for indexing.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

; (FCB 2005-04-09) in order to allow a handle as ARG1
; change na-adj-sem-type-basic to pred-sem-type, relation type to arg1-relation

na-end-lex := lexical_sign-word &
              [J-NEEDS-AFFIX -,
	       SYNSEM j-synsem &
                      [LOCAL [CAT [HEAD na-adj_head & [MODUS indicative,
						       MOD null],
                                   VAL [SUBJ #sbj,
					COMPS #comps,
					 SPR obl-1-arg & 
					     [FIRST [LOCAL [CAT.VAL [SUBJ #sbj,
								    COMPS #comps],
							    CONT [HOOK [XARG #xarg,
									LTOP #adjhand]]],
						     LEX +]]]],
			      CONT pred-sem-type &
				  [HOOK [LTOP #hand,
					  INDEX #event,
					  XARG #xarg],
				   RELS <! #key !>,
				   HCONS <! qeq & [HARG #arghd, LARG #adjhand] !>]],
		       LKEYS.KEYREL #key & arg1-relation &
			     [ARG0 #event,
			      ARG1 handle & #arghd ,
			      LBL #hand],
		       NON-LOCAL [QUE <! !>,
                               AFFIX <! !>]],
	       INFLECTED +,
	       LMORPH-BIND-TYPE i-or-shortadj-morph].

na-varg-end-lex := na-end-lex &
			[SYNSEM.LOCAL [CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD verb_head & 
								       [VN -,
									FORMAL.AHON -]]].
na-varg-negspr-end-lex := na-varg-end-lex &
			  [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS negative].


na-naarg-end-lex :=  na-end-lex &
		     [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-20) This is used for na-adjectives that can have ni-marking and then become adverbs,
; such as 元気になる

naadj2adv-end-lex := lexical_sign-word &
                     [J-NEEDS-AFFIX -,
		      SYNSEM j-synsem &
                             [LOCAL [CAT [HEAD case-adv_head & [J-POSTHEAD left],
					  VAL obj-arg &
					       [COMPS #comps & [FIRST [OPT - ,
								       LOCAL [CAT [HEAD na-adj_head,
										   VAL.UNSAT +],
									      CONT [RELS <! #key & [ARG1 #xarg] !>,
										    HOOK [LTOP #tophand,
											  INDEX #ind]]]]]]],
				     ARG-S #comps,
				     CONT [HOOK [LTOP #tophand,
						 XARG #xarg,
 						 INDEX #ind],
 					   RELS <! !>,
                                            HCONS <!  !>]],
 			      LKEYS.KEYREL #key & [ LBL #tophand],
 			      NON-LOCAL [QUE <! !>,
 					 AFFIX <! !>]],
                       INFLECTED +].




; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (FCB 2005-06-27) Added ARG0 to message 
; FIXME should be able to combine with v-op-end-lex in some way
naadj2v-end-lex := lexical_sign-word &
              [SYNSEM j-synsem &
                      [LOCAL [CAT [HEAD v-op-end_head & [MODUS indicative],
                                   VAL [SUBJ #sbj,
					COMPS #comps,
					 SPR obl-1-arg & 
					     [FIRST [LOCAL [CAT.VAL [SUBJ #sbj,
								     COMPS #comps],
							    CONT [HOOK [XARG #xarg, 
									INDEX #adj-index,
									LTOP #adj-hand]]],
						     LEX +]]]],
			      ARG-S < #sbj . #comps >,
			      BAR -,
			      CONT [HOOK [LTOP #top,
					  INDEX #event & [E.MOOD indicative],
					  XARG #xarg],
				    RELS <! #key,
					   message &
                                          [PRED proposition_m_rel,
					   LBL #h6,
					   ARG0 #adj-index,
					   MARG #h7] !>,
                                    HCONS <! qeq & [HARG #h7, LARG #adj-hand] !>]],
		       LKEYS.KEYREL #key & [PRED 'seem,
						ARG1 #xarg,
						ARG2 #h6,
						LBL #top,
						ARG0 #event],
                       NON-LOCAL [QUE <! !>,
                               AFFIX <! !>],
		       MODIFIED.PERIPH +],
	       INFLECTED -,
	       J-NEEDS-AFFIX +,
	       LMORPH-BIND-TYPE shortadj-morph,
 	       STEMTYPE c-stem].


; (ERB 2001-10-24) For K2Y machinery, I'd like this to have special
; rel, viz neg_rel.

; (ERB 2001-11-28) Replace KEY.LBL with LTOP.

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.
; (MS 2004-12-22) no MOD-IND/MOD-HAND


v-neg-end-lex := v-noncaus-op-end-lex &
                 [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MODUS negative,
							    KEYS.KEY #negrel],
				      VAL.SPR.FIRST.LOCAL [CONT [HOOK [LTOP #v-hd,
								       INDEX #event]]]],
				 CONT [RELS <! neg-relation &  #keyrel & [ARG1 #neg-arg,
									  PRED #negrel,
									  LBL #top] !>,
				       HOOK [LTOP #top,
					     INDEX #event & [E.MOOD indicative]],
				       HCONS <! qeq & [LARG #v-hd,
							HARG #neg-arg] !>]],
			  LKEYS.KEYREL #keyrel]].

v-neg-polite-present-end-lex := v-neg-end-lex &
				[SYNSEM.LOCAL [CAT.HEAD [C-MOD null,
							 H-TENSE present,
							 FORMAL.AHON +],
					       CONT.HOOK.INDEX.E.MOOD indicative]].

v-neg-plain-present-end-lex := v-neg-end-lex &
				[SYNSEM.LOCAL.CAT.HEAD [C-MOD null,
							 H-TENSE present,
							 FORMAL.AHON -,
							 COP-ARG -,
							 FIN +]].


v-neg-polite-present-simple-end-lex := v-neg-polite-present-end-lex &
				       [J-NEEDS-AFFIX -,
					SYNSEM.LOCAL.CAT.HEAD [MOD null,
							       FIN +,
							       MARK null,
							       J-SPEC null]].
							       

v-neg-polite-present-end-imorph-lex := v-neg-polite-present-simple-end-lex &
				       [LMORPH-BIND-TYPE i-morph].

v-neg-polite-present-end-amorph-lex := v-neg-polite-present-simple-end-lex &
				       [LMORPH-BIND-TYPE a-morph].

v-neg-polite-past-end-lex := v-neg-end-lex &
			     [J-NEEDS-AFFIX -,
			      SYNSEM.LOCAL [CAT.HEAD [MOD null,
						      C-MOD null,
						      H-TENSE past,
						      MARK null,
						      J-SPEC null,
						      FIN +,
						      FORMAL.AHON +]]].

v-neg-polite-past-end-imorph-lex := v-neg-polite-past-end-lex &
				       [LMORPH-BIND-TYPE i-morph].

v-neg-polite-past-end-taispec-lex := v-neg-polite-past-end-lex &
				     [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY tai_rel,
				      LMORPH-BIND-TYPE a-morph].

v-neg-polite-past-end-adjspec-lex := v-neg-polite-past-end-lex &
				     [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD i-adj-stem_head,
				      LMORPH-BIND-TYPE a-morph].

v-neg-polite-present-spr-end-lex := v-neg-polite-present-end-lex &
				    [J-NEEDS-AFFIX -,
				     SYNSEM.LOCAL.CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
									  BAR +]] >,
							    MARK null,
							     FIN +,
							    J-POSTHEAD rels,
							    J-SPEC < [LOCAL.CAT.HEAD noun_head] >]],
				     LMORPH-BIND-TYPE a-morph].

v-neg-plain-present-spr-end-lex := v-neg-plain-present-end-lex &
				   [J-NEEDS-AFFIX -,
				     SYNSEM.LOCAL.CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
									  BAR +]] >,
							    MARK null,
							     FIN +,
							    J-POSTHEAD rels,
							    J-SPEC < [LOCAL.CAT.HEAD noun_head] >]],
				     LMORPH-BIND-TYPE a-morph].

v-neg-polite-present-tai-end-lex := v-neg-polite-present-spr-end-lex &
				    [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LKEYS.KEYREL tai-relation].


v-neg-polite-present-adjspr-end-lex := v-neg-polite-present-spr-end-lex &
				    [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD i-adj-stem_head].


v-neg-polite-present-namark-end-lex := v-neg-polite-present-end-lex &
				       [SYNSEM.LOCAL.CAT.HEAD [MOD null,
							       MARK.FIRST.LOCAL.CAT.HEAD na-adj_head,
							       J-SPEC null,
							       FIN -],
					LMORPH-BIND-TYPE a-morph,
					RMORPH-BIND-TYPE shortadj-morph].


v-finite-present-plain-negative-end-lex := v-neg-end-lex &
					   [J-NEEDS-AFFIX -,
					    SYNSEM.LOCAL [CAT [HEAD [H-TENSE present,
								     MOD < [LOCAL [CAT.HEAD noun_head,
										   BAR +]] >,
								     MARK null,
								     C-MOD null,
								     J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
								     FIN +,
								     J-POSTHEAD rels,
								     FORMAL.AHON -]]],
					    LMORPH-BIND-TYPE a-morph,
					    STEMTYPE adj-stem,
					    INFLECTED +].

v-neg-te-plain-end-lex := v-neg-end-lex &
			  [J-NEEDS-AFFIX -,
			   SYNSEM [LOCAL [CAT [HEAD [FIN -,
						     H-TENSE te,
						     MOD null,
						     MARK null,
						     COP-ARG -,
						     C-MOD.FIRST.LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
									BAR +],
						     J-POSTHEAD coord,
						     FORMAL.AHON -]]]],
			   LMORPH-BIND-TYPE a-or-aa-morph].

v-neg-te-plain-aamorph-end-lex := v-neg-te-plain-end-lex &
				  [LMORPH-BIND-TYPE aa-morph].

v-neg-te-plain-amorph-end-lex := v-neg-te-plain-end-lex &
				  [LMORPH-BIND-TYPE a-morph].




v-naide-end-lex := v-neg-end-lex &
		   [J-NEEDS-AFFIX -,
		    SYNSEM [LOCAL [CAT [HEAD [FIN -,
					      H-TENSE tensed,
					      J-SPEC < [LOCAL [CAT.HEAD verb_head &
									[AUX aux_plus],
							       BAR +],
							LEX +] >,
					      MARK null,
					      COP-ARG -,
					      MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
							    BAR +]] >,
					      J-POSTHEAD coord,
					      FORMAL.AHON -],
					VAL.SPR.FIRST.LOCAL.CAT.VAL.UNSAT bool],
				   CONT.HOOK.INDEX.E.MOOD indicative]],
            LMORPH-BIND-TYPE a-morph].

; (ERB 2002-01-14) HCONS <! !> no longer true of all subtypes.  Move
; this to v-simple-end-lex.  Same for identifying LTOP of SPR with LTOP.
; Might as well move all the semantic stuff down.

; (ERB 2002-01-14) It looks like v-simple-end-lex-super and v-end-lex
; could actually be conflated.

; (MS 2003-05-13) This is what I actually did.

;v-simple-end-lex-super := v-end-lex &
;[SYNSEM [LOCAL [CAT.VAL [SPR.FIRST.LOCAL.CAT.VAL [SUBJ #sbj,
;						  COMPS #comps],
;			 SUBJ #sbj,
;			 COMPS #comps]]]].

; (ERB 2002-01-11) Most v-simple-end-lex subtypes are SMOD unmarked,
; the exception being the kudasai-vn-end-1 and its ilk.

; (MS 2002-01-16) There are more exceptions: NASAI!

; (ERB 2002-01-14) Making kudasai-vn-end more semantically contentful,
; so move semantic constraints here.

; (ERB 2002-01-15) Take MOD-IND and MOD-HAND from SPR, like LTOP and
; IND.  (immediate motivation is "VN+negai+masu" where "negai" is
; doing something special with MOD-IND and MOD-HAND.

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND

v-simple-end-lex := v-end-lex &
[ SYNSEM [LOCAL [CAT [HEAD [SMOD smod,
			    KEYS.KEY #key],
                     VAL.SPR.FIRST [LOCAL [CONT [HOOK [LTOP #top,
						       INDEX #event]],
					   CAT.HEAD.KEYS.KEY #key]]],
		
                CONT [HOOK [INDEX #event,
			    LTOP #top],
                      HCONS <! !>]],
	  LKEYS.KEYREL [ARG0 #event,
			LBL #top]]].

; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

; (ERB 2002-01-02) Also moving the constraint VN = SPR.VN here.

; (ERB 2002-01-21) Make supertype for nasai that doesn't inherit
; SMOD umarked so that v-tense-end-lex can still have this constraint.
; (It's useful for constraining utterance-rule-2e and the nonprop
; conjunctions.)

v-tense-end-lex-super := v-simple-end-lex &
                   [SYNSEM [LOCAL [CAT [ HEAD.VN #vn,
                                        VAL.SPR.FIRST.LOCAL.CAT.HEAD.VN #vn & - ],
                                  CONT.RELS <! !>,
                                  CTXT.BACKGROUND <! !>],
			    MODIFIED.PERIPH -]].

; (ERB 2002-01-22) Keep v-tense-end-lex from undergoing adj 
; inflectional rules.

v-tense-end-lex := v-tense-end-lex-super &
                   [ SYNSEM.LOCAL.CAT.HEAD.SMOD unmarked,
                     STEMTYPE otherstem ].



; (MS 2002-12-02) Cleaning up the verbal endings: common features for tense endings
;(CH 2003-08-14)
; "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... & [MAIN-PRD +] ..>"
;    --> "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... ..>"
; 「Vて〜な様子」などがacceptされる
;

; (MS 2004-04-02) changed C-MOD verb_head to sentence-valid, to allow also excl's in the sentence coordination.
; (MS 2004-07-09) took AHON - out, to account for まして. Instead, co-indexed AHON of the C-MOD
; with AHON of the HEAD to allow S-mashite...masu and S-te...ta, but not S-mashite...ta.



;(CH 2005-03-10)
; ad hoc solution to parse 「太郎がボールを進んで打つ」「太郎がボールを続けて打つ」.
; I'm not sure if this is correct...
; I intended to make this somewhat parallel to intersective adverbs like 素早く.
; Ideally the subject of 打つ should control that of 進む or 続ける.
; But adjuncts like 進んで or 続けて cannot be gapped in JACY, and thus the subject of 進む
; or 続ける should be a zero pronoun. However, zpro_ref-ind and full_ref-ind (太郎) are incompatible.
; Therefore, the control relation would not be easy to develop unless we introduce an additional
; head-adjunct-rule-type.
; [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD utt-valid] prevents this from modifying utterance.
; [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.COP -] prevents this from modifying copula verbs
; including those that are derived from NP via empty-cop-rule.
; (MS 2005-05-24) This adds massive ambiguity in all cases where there is a
; verb in te form (such as: 食べてもいい). 


te-adjunct-lex := v-tense-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM [LOCAL [CAT [HEAD [FIN -,
			    MARK null,
			    COP-ARG -,
			    C-MOD null,
			    MOD <[LOCAL intersective_mod &
					[CAT.HEAD utt-valid & [COP -],
					 CONT.HOOK [LTOP #handel,
						    INDEX #ind]]]>,
			    J-POSTHEAD left]],
		 CONT [HOOK [INDEX #ind & [E.MOOD indicative]]]],
	  LKEYS.KEYREL [ARG0 #ind,
			LBL #handel],
	  NON-LOCAL.QUE <! !>]].


te-adjunct-lex-t := te-adjunct-lex &
		     [LMORPH-BIND-TYPE t-morph].

te-adjunct-lex-d := te-adjunct-lex &
		     [LMORPH-BIND-TYPE nd-morph].


te-end-lex-basic := v-tense-end-lex &
	      [J-NEEDS-AFFIX -,
            SYNSEM.LOCAL [CAT [HEAD [FIN -,
                                     MARK null,
                                     COP-ARG -,
                                     C-MOD < [LOCAL [CAT [HEAD sentence-valid & [FORMAL.AHON #ahon]],
						     BAR +]] >,
                                     MOD null,
                                     J-POSTHEAD coord,
				     FORMAL.AHON #ahon]],
                          CONT.HOOK.INDEX.E.MOOD indicative]].


v-te-end-lex := te-end-lex-basic &
	      [SYNSEM.LOCAL.CAT [HEAD [J-SPEC < [LOCAL [CAT.HEAD verb_head & [AUX aux_plus],
						      BAR +],
					       LEX +,
					       MODIFIED.PERIPH -] >,
				       MODUS #modus,
				       H-TENSE tensed],
				 VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS #modus]].

v-te-end-tmorph-lex := v-te-end-lex &
		       [LMORPH-BIND-TYPE t-morph].

v-te-end-ndmorph-lex := v-te-end-lex &
		       [LMORPH-BIND-TYPE nd-morph].

v-te-end-ahon-lex := v-te-end-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +,
		      LMORPH-BIND-TYPE i-morph].



v-coord-end-lex := te-end-lex-basic &
		   [SYNSEM.LOCAL.CAT.HEAD [J-SPEC null,
					   FORMAL.AHON -,
					   MODUS indicative]].

v-coord-end-tmorph-lex := v-coord-end-lex &
			  [LMORPH-BIND-TYPE t-morph].

v-coord-end-ndmorph-lex := v-coord-end-lex &
			  [LMORPH-BIND-TYPE nd-morph].


comma-coord-end-lex := v-coord-end-lex &
		       [SYNSEM [LOCAL.CAT.HEAD.J-SPEC null,
				LKEYS.KEYREL adj-relation & [PRED 'comma]],
			LMORPH-BIND-TYPE i-or-t-morph].
		

v-indicative-tense-end-lex :=   v-tense-end-lex &
             [J-NEEDS-AFFIX -,
              SYNSEM.LOCAL [CAT [HEAD [MOD <[LOCAL [CAT.HEAD noun_head,
                                                        BAR +]]>,
                                       C-MOD null,
                                       MARK null,
                                       FIN +,
                                       COP-ARG +,
                                       J-POSTHEAD rels,
                                       MODUS #modus],
                                 VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS #modus],
                            CONT.HOOK.INDEX.E.MOOD indicative]]. 

;(MS 2005-11-10) getting rid of skip files.

v-present-tense-end-lex :=  v-indicative-tense-end-lex &
			    [SYNSEM.LOCAL.CAT.HEAD [H-TENSE present,
						    FORMAL.AHON +,
						    J-SPEC < [LOCAL.CAT.HEAD exceptional_noun_head] >],
			     LMORPH-BIND-TYPE i-morph].

v-past-tense-end-lex :=  v-indicative-tense-end-lex &
			    [SYNSEM.LOCAL.CAT.HEAD [H-TENSE past,
						    J-SPEC < [LOCAL.CAT.HEAD nom_head] >]].

v-past-tense-end-ahon-lex := v-past-tense-end-lex &
			     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +,
			      LMORPH-BIND-TYPE i-morph].
			     
v-past-tense-end-minusahon-lex := v-past-tense-end-lex &
			     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -,
			      INFLECTED +].

v-past-tense-end-minusahon-tmorph-lex := v-past-tense-end-minusahon-lex &
					 [LMORPH-BIND-TYPE t-morph].

v-past-tense-end-minusahon-ndmorph-lex := v-past-tense-end-minusahon-lex &
					 [LMORPH-BIND-TYPE nd-morph].


v-consultative-tense-end-lex := v-tense-end-lex &
				[J-NEEDS-AFFIX -,
				 SYNSEM.LOCAL [CAT.HEAD [MOD null,
							 C-MOD null,
							 H-TENSE present,
							 MARK null,
							 COP-ARG -,
							 J-SPEC null,
							 FIN +,
							 MODUS consultative]]].

v-consultative-tense-polite-end-lex := v-consultative-tense-end-lex &
				       [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

v-consultative-tense-plain-end-lex := v-consultative-tense-end-lex &
				       [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].


v-consultative-tense-imorph-end-lex := v-consultative-tense-end-lex &
				       [LMORPH-BIND-TYPE i-morph].

v-consultative-tense-omorph-end-lex := v-consultative-tense-end-lex &
				       [LMORPH-BIND-TYPE o-morph].

v-consultative-tense-polite-imorph-end-lex := v-consultative-tense-polite-end-lex & v-consultative-tense-imorph-end-lex.

v-consultative-tense-plain-imorph-end-lex := v-consultative-tense-plain-end-lex & v-consultative-tense-imorph-end-lex.

v-consultative-tense-plain-omorph-end-lex := v-consultative-tense-plain-end-lex & v-consultative-tense-omorph-end-lex.


v-imperative-tense-end-lex := v-tense-end-lex-super &
                 [J-NEEDS-AFFIX -,
		  LMORPH-BIND-TYPE i-morph,
                  SYNSEM.LOCAL.CAT [HEAD [MODUS simple-imperative,
                                          MOD null,
                                          COP-ARG -,
                                          C-MOD null,
                                          H-TENSE present,
                                          MARK null, 
                                          J-SPEC null,
					  SMOD imp,
                                          FIN +]]].


; (ERB 2001-11-12) As an experiment, saying that the ARG1 of
; tai is always first or second person.  This is somewhat justified 
; on the grounds that if you're talking about someone else, you're
; supposed to say -tagaru.  It should help cut down on attachment
; ambiguity in sentences like "ginkou ga doko ni aru no ka shiritai"
; where we don't want ginkou showing up as the subject of shiritai.
; Also, I suspect that the target domain should have lower than 
; average uses of third-person tai (as opposed to novels or other
; cases with usual perspective-taking).

; (ERB 2001-11-19) Something in this type (or its supertypes) is causing
; a label problem.  I suspect it has to do with identifying the KEY 
; with the KEY of the SPR.  If we need to keep this for adjunct attachment
; purposes, then we will have to make tai-end-lex not inherit from
; lexical-sign_word and do something special in the k2y code to make
; sure it doesn't get lost.

; (ERB 2001-11-19) I'm not sure KEY identification is the way to go
; for the adjunct attachment problem anyway, as adjuncts should really
; be looking at LTOP and INDEX and not KEY. 

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (FCB 2005-06-27) Added ARG0 to message 

tai-end-lex-basic := v-noncaus-op-end-lex &
               [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [KEYS.KEY #pred],
                                   VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #ohand,
								    INDEX #o-index,
								    XARG #sbjind]]]],
                              CONT [RELS <! tai-relation & #key & [ARG1 #sbjind,
								   ARG2 #chand,
								   LBL #top,
								   ARG0 #event,
								   PRED #pred],
                                           message &
                                          [PRED proposition_m_rel,
					   LBL #chand,
					   ARG0 #o-index,
					   MARG #soa] !>,
                                    HOOK [INDEX #event,
					  LTOP #top],
                                    HCONS <! qeq & [LARG #ohand,
                                                     HARG #soa] !>],
                              CTXT subj-honor-ctxt &
                                  [BACKGROUND <! subj-honor_rel &
                                               [HONORED #sbjind,
                                                BEARER #event,
						POLARITY -] !>]],
			LKEYS.KEYREL #key],
                LMORPH-BIND-TYPE i-morph].

taku-end-lex := tai-end-lex-basic &
           [J-NEEDS-AFFIX -,
            INFLECTED +,
            SYNSEM.LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
                                                BAR +]] >, 
                                     H-TENSE te,
                                     J-POSTHEAD coord,
                                     MARK null,
                                     COP-ARG -,
                                    J-SPEC < [LOCAL [CAT.HEAD verb_head & [AUX aux_plus],
                                                 BAR +],
					      LEX +] >,
                                     FIN -,
                                     FORMAL [SHON -],
                                     MODUS voluntative]]]].

tai-end-lex := tai-end-lex-basic &
	       [SYNSEM.LOCAL [CAT.HEAD [MODUS voluntative,
				       MOD < [LOCAL [CAT.HEAD noun_head,
						  BAR +]] >,
				       H-TENSE present,
					C-MOD null,
				       J-POSTHEAD rels,
				       MARK null,
				       J-SPEC.FIRST.LOCAL.CAT.HEAD nom_head,
				       FIN +,
				       FORMAL.AHON +]],
		J-NEEDS-AFFIX -,
		INFLECTED +].

tai-minusshon-end-lex := tai-end-lex &
			 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON -].

tai-notyetend-lex :=  tai-end-lex-basic &
		      [J-NEEDS-AFFIX +,
		       INFLECTED -,
		       SYNSEM [LOCAL.CAT.HEAD [MOD null,
					       C-MOD null],
			       MODIFIED.PERIPH +]].

tai-notyetend-adjstem-lex := tai-notyetend-lex &
			     [STEMTYPE adj-stem].

tai-notyetend-cstem-lex := tai-notyetend-lex &
			     [STEMTYPE c-stem].


; (ERB 2001-09-06) Currently the MARG of the main prpstn in conditional sentences
; QEQs an unbound handle.  I'm hoping to fix this by exposing the handle of the
; if_then_rel.

;(CH 2003-08-14) MODIFIED VERSION
; 関係節中に条件節が生起できるようにした。
; "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... & [MAIN-PRD +] ..>"
;    --> "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... ..>"
;(CH 2003-08-22)
; "SYNSEM.LOCAL.CAT.HEAD.MOD null"
;    --> "SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT.HEAD verb_head,
; 
; (FCB 2005-06-27) Added ARG0 to message 
v-cond-end-lex  :=  v-noncaus-op-end-lex &
                    [SYNSEM [LOCAL [CAT [HEAD v-cond-end_head & [C-MOD < [LOCAL [CAT [HEAD verb_head],
                                                                           BAR +,
                                                                           CONT.HOOK [LTOP #main,
										      INDEX #ind]]] >,
                                                              MOD < [LOCAL [CAT.HEAD verb_head,
									    BAR +],
								     LEX bool] >,
                                                              MARK null,
                                                              J-SPEC null,
								 J-POSTHEAD left,
                                                              COP-ARG -,
                                                              MODUS conditional,
								 MAIN-PRD -,
                                                              FIN -],
                                        VAL.SPR.FIRST.LOCAL [CAT.HEAD.MAIN-PRD -,
							      CONT.HOOK [LTOP #subord,
									 INDEX #ind]]],
				    
                                   CONT [HOOK [INDEX #ind,
					       LTOP #tophand],					       
                                          RELS <! subord-relation & #key &
                                                [PRED "if_then_rel",
						 LBL #tophand,
                                                 R-HNDL #main,
                                                 L-HNDL #subord],
                                                message &
						[PRED proposition_m_rel,
						 LBL #main,
						 ARG0 #ind,
						 MARG #prpstnsoa1],
                                                message &
						[PRED proposition_m_rel,
						 LBL #subord,
						 ARG0 #ind,
                                                 MARG #prpstnsoa2] !>,
                                         HCONS <! qeq & [LARG #main,
                                                          HARG #prpstnsoa1],
                                                 qeq & [LARG #subord,
                                                        HARG #prpstnsoa2] !>]],
			     LKEYS.KEYREL #key],
		     J-NEEDS-AFFIX -].

v-cond-end-pastspr-lex := v-cond-end-lex &
			  [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE past].

v-cond-end-presentspr-lex := v-cond-end-lex &
			  [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE present].

v-cond-end-polite-lex := v-cond-end-lex &
			 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

v-cond-end-plain-lex := v-cond-end-lex &
			 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

v-cond-end-ind-lex := v-cond-end-lex &
			 [SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative].

v-cond-end-imorph-lex := v-cond-end-lex &
			 [LMORPH-BIND-TYPE i-morph].

v-cond-end-tmorph-lex := v-cond-end-lex &
			 [LMORPH-BIND-TYPE t-morph].

v-cond-end-ndmorph-lex := v-cond-end-lex &
			 [LMORPH-BIND-TYPE nd-morph].

v-cond-end-condmorph-lex := v-cond-end-lex &
			 [LMORPH-BIND-TYPE cond-morph].


v-cond-end-pastspr-polite-lex := v-cond-end-pastspr-lex & v-cond-end-polite-lex.

v-cond-end-pastspr-polite-imorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-imorph-lex.

v-cond-end-pastspr-polite-ind-imorph-lex :=  v-cond-end-pastspr-polite-imorph-lex & v-cond-end-ind-lex.

v-cond-end-pastspr-plain-lex := v-cond-end-pastspr-lex & v-cond-end-plain-lex.

v-cond-end-pastspr-plain-tmorph-lex := v-cond-end-pastspr-plain-lex & v-cond-end-tmorph-lex.

v-cond-end-pastspr-plain-ndmorph-lex := v-cond-end-pastspr-plain-lex & v-cond-end-ndmorph-lex.

v-cond-end-pastspr-polite-tmorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-tmorph-lex.

v-cond-end-pastspr-polite-ndmorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-ndmorph-lex.

v-cond-end-presentspr-imorph-lex := v-cond-end-presentspr-lex & v-cond-end-imorph-lex.

; (MS 2001-11-22) RARERU needs an ARG1, if it shall be able to combine with TAI.

; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message 
rareru-end-lex :=  v-noncaus-op-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MARK < [MODIFIED.PERIPH -] >,
					    KEYS.KEY #pred,
					    MODUS potential],
		      VAL.SPR.FIRST [LOCAL.CONT [HOOK [XARG #arg1,
						       INDEX #o-index,
						       LTOP #ohand]]]],
		 CONT [RELS <! rareru-relation &  [ARG1 #arg1,
						   ARG2 #chand,
						   LBL #top,
						   ARG0 #event,
						   PRED #pred],
			     message &
			     [PRED proposition_m_rel,
			      LBL #chand,
			      ARG0 #o-index,
			      MARG #soa] !>,
		       HOOK [INDEX #event,
			     LTOP #top],
		       HCONS <! qeq & [LARG #ohand,
				       HARG #soa] !>]],
			MODIFIED.PERIPH +],
  INFLECTED -]. 

 rareru-end-imorph-lex := rareru-end-lex &
			  [LMORPH-BIND-TYPE i-morph,
			   STEMTYPE v-stem].

rareru-end-condmorph-lex := rareru-end-lex &
			  [LMORPH-BIND-TYPE cond-morph].

rareru-end-condexcmorph-lex := rareru-end-lex &
			  [LMORPH-BIND-TYPE cond-exceptional-morph].



; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

v-op-end-lex := lexical_sign-word &
             [SYNSEM j-synsem &
                     [LOCAL [CAT [HEAD verbend_head-unmarked &
                                       [H-TENSE #tense,
                                        VN #vn,
                                        AUX #aux],
                                  VAL [SPR obl-1-arg &
					   [FIRST.LOCAL [CAT [HEAD verb_head & [AUX #aux,
									       VN #vn & - ]],
							 BAR -]]]],
                             CONT verb-sem-type &
                                 [HOOK [INDEX event &
					      [E [TENSE #tense]]]],
                             BAR -,
                             NUCL nucl_plus],
		      LEX +,
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]]].

v-noncaus-op-end-lex := v-op-end-lex &
                        [SYNSEM.LOCAL [CAT.VAL [SUBJ #sbjval,
						COMPS #compsval,
						SPR.FIRST.LOCAL [CAT.VAL [SUBJ #sbjval,
									 COMPS #compsval],
								 CONT.HOOK.XARG #xarg,
								 ARG-S #args]],
				       CONT.HOOK.XARG #xarg,
				       ARG-S #args]].

naru-noncaus-end-lex := v-noncaus-op-end-lex &
	    [INFLECTED -,
	     LMORPH-BIND-TYPE a-morph,
	     STEMTYPE c-stem,
	     SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MODUS indicative],
				 VAL.SPR.FIRST.LOCAL.CONT [HOOK [LTOP #arg-h,
								 INDEX #mod-i],
							     MOD-HAND #mod-h]],
			    CONT [HOOK [INDEX #event,
					LTOP #hd],
				  MOD-HAND #mod-h,
				  MOD-IND #mod-i,
				  RELS <! #key !>,
				  HCONS <! !>]],
		     LKEYS.KEYREL #key & adv-relation &
			   [LBL #hd,
			    ARG1 #arg-h,
			    ARG0 #event],
		     MODIFIED.PERIPH +]].

nai-noncaus-end-lex := v-noncaus-op-end-lex &
           [J-NEEDS-AFFIX +,
	    INFLECTED -,
	    LMORPH-BIND-TYPE a-morph,
	    STEMTYPE adj-stem,
	    SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MARK.FIRST [MODIFIED.PERIPH -,
							    LOCAL.CAT.HEAD verbend_head],
						      J-SPEC null,
						      COP-ARG -],
			       VAL.SPR.FIRST.LOCAL [CONT [MOD-HAND #modhd,
							  HOOK.LTOP #v-hd,
							  MOD-IND #event]]],
			  CONT [RELS <! #key & [ARG1 #neg-arg,
						 LBL #top] !>,
				HOOK [LTOP #top,
				      INDEX #event & [E.MOOD indicative]],
				MOD-HAND #modhd,
				MOD-IND #event,
				HCONS <! qeq & [LARG #v-hd,
						 HARG #neg-arg] !>]],
		    LKEYS.KEYREL #key & neg-relation,
		    MODIFIED.PERIPH +]].

; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message 
; (FCB 2005-06-27)  this seems to be covered by adj2v-end-lex.
; prpstn-introducing-end-lex := v-noncaus-op-end-lex &
; 			      [SYNSEM [LOCAL [CAT [HEAD v-op-end_head,
; 						  VAL.SPR.FIRST.LOCAL.CONT.HOOK [XARG #arg1,
; 										 INDEX #v-index,
; 										 LTOP #v-h]],
					     
; 					     CONT [HOOK.INDEX #index,
; 						   RELS <! #key,
; 							   message &
; 							 [PRED proposition_m_rel,
; 							  LBL #prpstn-h,
; 							  ARG0 #v-index,
; 							  MARG #soa] !>,
; 						   HCONS  <! qeq & [HARG #soa, LARG #v-h] !> ]],
; 				       LKEYS.KEYREL #key &
; 					     [ARG1 #arg1,
; 					      ARG2 #prpstn-h,
; 					      ARG0 #index]]].



; (TT 2003-09-03) lex type を *-obj-* と *-obj2-* に
;                 v2-stem-lex を接続可能にするため

; (MS 2003-12-19) Matrix 0.6

; (MS 2004-11-22) The cause-relation should not include the wo-complement.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

caus-trans-obj-end-lex := v-op-end-lex &
                [SYNSEM [LOCAL [CAT [HEAD caus-end_head & 
					  [MOD < [LOCAL [CAT.HEAD noun_head,
							 BAR +]] >,
					   C-MOD null,
					   J-POSTHEAD rels],
				     VAL [SPR obl-1-arg &
					      [FIRST [LOCAL [CONT [HOOK [LTOP #hand,
									 XARG #causee]],
							     CAT [HEAD verb-stem_head,
								  VAL sbj-obj-arg &
								       [UNSAT +,
									COMPS 1-list & [FIRST #obj-val]]]]]],
					  SUBJ [FIRST [OPT + ,
						       LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
							      CONT.HOOK.INDEX #causer]]],
					  COMPS < #obj-val,
						  [LOCAL [CAT.HEAD overt-case-p_head & [CASE ni],
							  CONT.HOOK.INDEX #causee]] >]],
				CONT [HOOK [INDEX #event,
					    LTOP #top,
					    XARG #causer],
				      RELS <! #key & [PRED 'cause], 
					     message &
					    [PRED proposition_m_rel,
					     LBL #prpstn-hd, 
					     MARG #prpstn-soa] !>,
				      HCONS <! qeq & [HARG #prpstn-soa, LARG #hand] !> ]],
			 LKEYS.KEYREL arg123-relation & #key & [ARG1 #causer,
								 ARG2 #causee,
								 ARG3 #prpstn-hd,
								 ARG0 #event,
								 LBL #top],
			 MODIFIED.PERIPH +],
		 STEMTYPE v-stem,
		 INFLECTED -].

caus-trans-obj-passcmorph-end-lex := caus-trans-obj-end-lex &
				     [LMORPH-BIND-TYPE pass-c-stem-morph].

caus-trans-obj-passvmorph-end-lex := caus-trans-obj-end-lex &
				     [LMORPH-BIND-TYPE pass-v-stem-morph].


; (MS 2005-09-28) A second reading of the causative ending propagates the verb stem INDEX,
; such that this can be accessed by adverbs (to account for ambiguity in expressions like "花子が紀子に学校で走らせた")

caus-trans-obj-scope-end-lex := v-op-end-lex &
                [INFLECTED -,
		 STEMTYPE v-stem,
		 SYNSEM [MODIFIED.PERIPH +,
			 LOCAL [CAT [HEAD caus-end_head &
					  [MOD < [LOCAL [CAT.HEAD noun_head,
                                                 BAR +]] >,
					   C-MOD null,
					   J-POSTHEAD rels],
				     VAL [SPR obl-1-arg &
					      [FIRST [LOCAL [CONT [HOOK [LTOP #v-hand,
									 INDEX #v-event,
									 XARG #causee]],
							     CAT [HEAD verb-stem_head,
								  VAL sbj-obj-arg &
								       [UNSAT +,
									COMPS 1-list & [FIRST #obj-val]]]]]],
					  SUBJ [FIRST [OPT + ,
						       LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
							      CONT.HOOK.INDEX #causer]]],
					  COMPS < #obj-val,
						  [LOCAL [CAT.HEAD overt-case-p_head & [CASE ni],
							  CONT.HOOK.INDEX #causee]] >]],
				CONT [HOOK [INDEX #v-event,
					    LTOP #c-hand,
					    XARG #causer],
				      RELS <! #key & [PRED 'cause], 
					     message &
					    [PRED proposition_m_rel,
					     LBL #prpstn-hd, 
					     MARG #prpstn-soa] !>,
				      HCONS <! qeq & [HARG #prpstn-soa, LARG #v-hand] !> ]],
			 LKEYS.KEYREL arg123-relation & #key & [ARG1 #causer,
								 ARG2 #causee,
								 ARG3 #prpstn-hd,
								ARG0 event,
								LBL #c-hand]]].

caus-trans-obj-scope-passcmorph-end-lex := caus-trans-obj-scope-end-lex &
				     [LMORPH-BIND-TYPE pass-c-stem-morph].

caus-trans-obj-scope-passvmorph-end-lex := caus-trans-obj-scope-end-lex &
				     [LMORPH-BIND-TYPE pass-v-stem-morph].


;caus-trans-obj2-end-lex := v-op-end-lex &
;                [SYNSEM [LOCAL [CAT [HEAD caus-end_head,
;				     VAL [SPR obl-1-arg &
;					      [FIRST.LOCAL [CONT [HOOK [LTOP #hand,
;									XARG #causee]],
;							     CAT [HEAD verb-stem_head,
;								  VAL sbj-obj-arg &
;								       [UNSAT +,
;									COMPS 1-list & [FIRST #obj-val]]]]],
;					  SUBJ [FIRST [OPT + ,
;						       LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
;							      CONT.HOOK.INDEX #causer]]],
;					  COMPS < #obj-val & [LOCAL.CONT.HOOK.INDEX #object], 
;						  [LOCAL [CAT.HEAD overt-case-p_head & [CASE ni],
;							  CONT.HOOK.INDEX #causee]] >]],
;				CONT [HOOK [INDEX #event,
;					    LTOP #top],
;				      MOD-IND #event,
;				      MOD-HAND #top,
;				      RELS <! #key & [PRED 'cause], 
;					     message &
;					    [PRED proposition_m_rel,
;					     LBL #prpstn-hd, 
;					     MARG #prpstn-soa] !>,
;				      HCONS <! qeq & [HARG #prpstn-soa, LARG #hand] !> ]],
;			 LKEYS.KEYREL arg1234-relation & #key & [ARG1 #causer,
;							  ARG2 #causee,
;							  ARG3 #object,
;							  ARG4 #prpstn-hd,
;							  ARG0 #event,
;							  LBL #top]]].


; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (MS 2005-09-21) linked the SPR-SUBJ to the complement.

caus-intrans-end-lex := v-op-end-lex &
                [SYNSEM [LOCAL [CAT [HEAD caus-end_head &
					  [MOD < [LOCAL [CAT.HEAD noun_head,
							 BAR +]] >,
					   C-MOD null,
					   J-POSTHEAD rels,
					   J-SPEC < [LOCAL.CAT.HEAD noun_head] >],
				     VAL [SUBJ.FIRST [OPT + ,
						      LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
							     CONT.HOOK.INDEX #causer]],
					  COMPS 1-list & < [OPT + ,
							    LOCAL [CAT.HEAD overt-case-p_head & [CASE wo-or-ni],
								   CONT.HOOK.INDEX #causee]] >,
					  SPR obl-1-arg &
						     [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
									      INDEX #caused,
									       XARG #causee],
								   CAT [HEAD verb-stem_head,
									VAL [UNSAT +,
									     SUBJ.FIRST.LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
											       CONT.HOOK.INDEX #causee],
									     COMPS null]]]]]],
				CONT [HOOK [INDEX #event & #caused,
					    LTOP #top,
					    XARG #causer],
				      RELS <!  #key & [PRED 'cause], 
                                               message &
					    [PRED proposition_m_rel,
					     LBL #prpstn-hd, 
					     ARG0 #caused,
					     MARG #prpstn-soa] !>,
				      HCONS <! qeq & [HARG #prpstn-soa, LARG #hand] !> ]],
			 LKEYS.KEYREL arg123-relation & #key & [ARG1 #causer,
								ARG2 #causee,
								ARG3 #prpstn-hd,
								ARG0 #event,
								LBL #top]],
		 INFLECTED -,
		 STEMTYPE v-stem].

caus-intrans-passcmorph-end-lex := caus-intrans-end-lex &
				   [ LMORPH-BIND-TYPE pass-c-stem-morph ].

caus-intrans-passvmorph-end-lex := caus-intrans-end-lex &
				   [ LMORPH-BIND-TYPE pass-v-stem-morph ].


; (MS 2005-09-21) A second reading of the causative ending propagates the verb stem LTOP and INDEX,
; such that this can be accessed by adverbs (to account for ambiguity in expressions like "花子が紀子に学校で走らせた")

caus-intrans-scope-end-lex := v-op-end-lex &
                [INFLECTED -,
		 STEMTYPE v-stem,
		 SYNSEM [MODIFIED.PERIPH +,
			 LOCAL [CAT [HEAD caus-end_head &
					  [MOD < [LOCAL [CAT.HEAD noun_head,
							 BAR +]] >,
					   C-MOD null,
					   J-POSTHEAD rels,
					   J-SPEC < [LOCAL.CAT.HEAD noun_head] >],
				     VAL [SUBJ.FIRST [OPT + ,
						      LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
							     CONT.HOOK.INDEX #causer]],
					  COMPS 1-list & < [OPT + ,
							    LOCAL [CAT.HEAD overt-case-p_head & [CASE wo-or-ni],
								   CONT.HOOK.INDEX #causee]] >,
					  SPR obl-1-arg &
						     [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
									      INDEX #caused,
									       XARG #causee],
								   CAT [HEAD verb-stem_head,
									VAL [UNSAT +,
									     SUBJ.FIRST.LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
											       CONT.HOOK.INDEX #causee],
									     COMPS null]]]]]],
				CONT [HOOK [INDEX #event & #caused,
					    LTOP #hand,
					    XARG #causer],
				      RELS <!  #key & [PRED 'cause], 
                                               message &
					    [PRED proposition_m_rel,
					     LBL #prpstn-hd, 
					     ARG0 #caused,
					     MARG #prpstn-soa] !>,
				      HCONS <! qeq & [HARG #prpstn-soa, LARG #hand] !> ]],
			 LKEYS.KEYREL arg123-relation & #key & [ARG1 #causer,
								ARG2 #causee,
								ARG3 #prpstn-hd,
								ARG0 #event]]].

caus-intrans-scope-passvmorph-end-lex := caus-intrans-scope-end-lex &
					 [LMORPH-BIND-TYPE pass-v-stem-morph].

caus-intrans-scope-passcmorph-end-lex := caus-intrans-scope-end-lex &
					 [LMORPH-BIND-TYPE pass-c-stem-morph].




; (MS 2004-12-22) no MOD-IND/MOD-HAND

pass-end-lex :=  v-op-end-lex &
                 [SYNSEM [LOCAL [CAT [HEAD pass-end_head,
                                     VAL.SPR obl-1-arg],
                                CONT [HOOK [LTOP #top]]],
			  LKEYS.KEYREL.LBL #top,
			  MODIFIED.PERIPH +]].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?
; (MS 2004-11-15) UNSAT + on the SPR to prevent spurious ambiguity in the case of
; ditransitive passives (置かれた)
; (MS 2004-11-18) Added PASS + to the event Index, such that this appears in the MRS. 
; Access ARG-S instead of RELS.LIST.FIRST.
; (MS 2004-11-30) It is too strict to say that the valence of the SPR should be sbj-obj-arg. 
; There could be a SPR (in case of causative-passive).
; (MS 2004-12-14) The SPR must be [LIGHT -], because we have a new rule for light passives.
; (FCB 2005-07-22) Added 

simple-pass-end-lex :=   pass-end-lex &
               [SYNSEM [LOCAL [CAT [HEAD simple-pass-end_head,
				    VAL [SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
							    CONT.HOOK.INDEX #surfsbjind]],
					 COMPS 1-list & < [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
								  CONT.HOOK.INDEX #surfobjind]] >,
					 SPR.FIRST [LOCAL [CONT [HOOK [INDEX #event,
								       LTOP #hand,
								       XARG #surfobjind]],
							   ARG-S < [LOCAL.CONT.HOOK.INDEX #surfobjind],
								   [LOCAL.CONT.HOOK.INDEX #surfsbjind] >,
							   CAT [VAL [UNSAT +,
								    SUBJ opt-1-arg,
								    COMPS 1-list &
									   < [LOCAL [CAT.HEAD case-p_head & 
											      [CASE wo]]] > 
									   ],
								HEAD.LIGHT -]]]],
				    HEAD.KEYS.KEY pass_rel],
			      
			       CONT [RELS <! !>,
				     HOOK.INDEX #event & [E.PASS +],
				     HCONS <! !>],
			       CTXT.EMPATHY.EMPEE #surfsbjind],
			LKEYS.KEYREL pass-relation &  [LBL #hand]],
		LMORPH-BIND-TYPE pass-morph,
		INFLECTED -,
		STEMTYPE v-stem].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?
; (MS 2004-11-12) This seems to have mixed ARG2 and ARG3 in the arg123-relation.
; I have corrected that.
; (MS 2004-11-15) UNSAT + to prevent spurious ambiguity. 
; (MS 2004-11-20) Access ARG-S instead of RELS.LIST.FIRST!
; (MS 2004-11-22) Restricted to SPRs with sbj-obj-obj2-arg, namely ditransitives.



ditrans-pass-end-ganini-lex :=   pass-end-lex &
               [SYNSEM [LOCAL [CAT [VAL [UNSAT +,
					 SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
                                                             CONT.HOOK.INDEX #surfsbjind]],
                                         COMPS < #objval & [LOCAL.CONT.HOOK.INDEX #surfobjind],
						 [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
                                                             CONT.HOOK.INDEX #surfobj2ind]] >,
					 SPR.FIRST [ LOCAL [CONT [HOOK [INDEX #event,
									XARG #surfobj2ind,
									LTOP #hand]],
							    CAT.VAL sbj-obj-obj2-arg & [UNSAT +],
							    ARG-S < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
									    CONT.HOOK.INDEX #surfobj2ind]],
								    [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE wo],
									    CONT.HOOK.INDEX #surfsbjind]],
								    #objval & [LOCAL [CAT.HEAD case-p_head & [CASE ni],
										      CONT.HOOK.INDEX #surfobjind]] >]]],
				    HEAD.KEYS.KEY pass_rel],
				    
				   CONT [RELS <! !>,
					 HOOK.INDEX #event & [E.PASS +],
					 HCONS <! !>],
			       CTXT.EMPATHY.EMPEE #surfsbjind],
			LKEYS.KEYREL pass-relation & [LBL #hand]],
		LMORPH-BIND-TYPE pass-morph,
		INFLECTED -,
		STEMTYPE v-stem].

ditrans-pass-end-ganini-passcmorph-lex := ditrans-pass-end-ganini-lex &
					  [LMORPH-BIND-TYPE pass-c-stem-morph].

ditrans-pass-end-ganini-passvmorph-lex := ditrans-pass-end-ganini-lex &
					  [LMORPH-BIND-TYPE pass-v-stem-morph].



; (MS 2004-11-25) There is a second type of ditransitive passives:
; 田中がフランシスによってボールを当てられた
; These keep the wo-argument.


ditrans-pass-end-ganiwo-lex :=   pass-end-lex &
               [SYNSEM [LOCAL [CAT [VAL [UNSAT +,
					 SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
                                                             CONT.HOOK.INDEX #surfsbjind]],
                                         COMPS < #objval & [LOCAL.CONT.HOOK.INDEX #surfobjind],
						 [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
                                                             CONT.HOOK.INDEX #surfobj2ind]] >,
					 SPR.FIRST [ LOCAL [CONT [HOOK [INDEX #event,
									XARG #surfobj2ind,
									LTOP #hand]],
							    CAT.VAL sbj-obj-obj2-arg & [UNSAT +],
							    ARG-S < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
									    CONT.HOOK.INDEX #surfobj2ind]],
								    #objval & [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE wo],
										      CONT.HOOK.INDEX #surfobjind]],
								    [LOCAL [CAT.HEAD case-p_head & [CASE ni],
										      CONT.HOOK.INDEX #surfsbjind]] >]]],
				    HEAD.KEYS.KEY pass_rel],
				    
				   CONT [RELS <! !>,
					 HOOK.INDEX #event & [E.PASS +],
					 HCONS <! !>],
			       CTXT.EMPATHY.EMPEE #surfsbjind],
			LKEYS.KEYREL pass-relation & [LBL #hand]],
		LMORPH-BIND-TYPE pass-morph,
		INFLECTED -].

ditrans-pass-end-ganiwo-passcmorph-lex := ditrans-pass-end-ganiwo-lex &
					  [LMORPH-BIND-TYPE pass-c-stem-morph].

ditrans-pass-end-ganiwo-passvmorph-lex := ditrans-pass-end-ganiwo-lex &
					  [LMORPH-BIND-TYPE pass-v-stem-morph].



;(MS-2001-11-06) Emily wants the adversative passive not to add any semantics to the RELS. That's why I take the KEY out of the RELS and make the HCONS empty. But I am not sure if this is right: watashi ga otouto ni keeki wo taberareta.???

; (MS 2003-12-19) Matrix 0.6

;  (MS 2004-11-12) I had to bind the ARG2 of the adversative relation. It seems to me that the ARG2 should be the event, rather than
; the ARG1 of the verb. Then, we have only one adversative relation, with ARG1 (the surface subject) and ARG2 (the event).

adversative-pass-end-lex := pass-end-lex &
			    [SYNSEM [LOCAL [CAT [HEAD simple-pass-end_head,
						 VAL [SUBJ 1-list & < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
									      CONT.HOOK.INDEX #surfsbjind]] >,
						      SPR 1-list & <  [LOCAL [CAT.VAL.UNSAT +,
									      CONT.HOOK.LTOP #sprhd]] >],
						 HEAD.KEYS.KEY pass_rel],
					    CONT [RELS <! #key !>,
						  HOOK [XARG #surfsbjind,
							INDEX #event],
						 HCONS <!  !>]],
				     LKEYS.KEYREL #key & adversative-relation & [ARG1 #surfsbjind,
										 ARG2 #sprhd,
										 ARG0 #event]],
			     LMORPH-BIND-TYPE pass-morph].
						     



adversative-intrans-pass-end-lex := adversative-pass-end-lex &
                [SYNSEM [LOCAL [CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
							 BAR +]] >,
					   J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					   FIN +,
					   J-POSTHEAD rels,
					   C-MOD null,
					   FORMAL.AHON -],
				     VAL [COMPS opt-1-arg & < [LOCAL [CAT.HEAD case-p_head & [CASE ni],
								      CONT.HOOK.INDEX #surfobjind]]>,
					 SPR < [LOCAL [CAT.VAL sbj-arg,
						       CONT.HOOK [XARG #surfobjind]]] >]],
			       CTXT.EMPATHY.EMPEE #surfobjind]],
		 STEMTYPE v-stem].

adversative-intrans-pass-passvmorph-end-lex := adversative-intrans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-v-stem-morph].

adversative-intrans-pass-passcmorph-end-lex := adversative-intrans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-c-stem-morph].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?

adversative-trans-pass-end-lex := adversative-pass-end-lex &
                [SYNSEM [LOCAL [CAT [VAL [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #surfsbjind,
					 COMPS opt-2-args & < #obj & [LOCAL [CAT.HEAD case-p_head & [CASE wo]]] ,
								[LOCAL [CAT.HEAD case-p_head & [CASE ni],
									CONT.HOOK.INDEX #surfobjind2]] >,
					  SPR < [LOCAL [CAT.VAL sbj-obj-arg & [COMPS.FIRST #obj],
							CONT [HOOK [XARG #surfobjind2]]]] >]],
			       
			       CTXT.EMPATHY.EMPEE #surfsbjind]],
		 INFLECTED -,
		 STEMTYPE v-stem].

adversative-trans-pass-passvmorph-end-lex := adversative-trans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-v-stem-morph].

adversative-trans-pass-passcmorph-end-lex := adversative-trans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-c-stem-morph].



; (MS 2004-11-20) Passive ending for light verbs. This one is tricky, because we need to access
; the argument structure of the specifier of the specifier (namely, the VN). ARG-S is the right place
; to access these!



lightverb-pass-end-lex :=   pass-end-lex &
               [SYNSEM [LOCAL [CAT [VAL [SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
							    CONT.HOOK.INDEX #surfsbjind]],
					 COMPS 1-list & < [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
								  CONT.HOOK.INDEX #surfobjind]] >,
					 SPR.FIRST [LOCAL [CONT [HOOK [INDEX #event,
								       LTOP #hand,
								       XARG #surfobjind]],
							   CAT.VAL light_transitive & [UNSAT +,
										       SPR.FIRST.LOCAL.CAT.VAL sbj-obj-arg],
							   ARG-S < [LOCAL.CONT.HOOK.INDEX #surfobjind],
								   [LOCAL.CONT.HOOK.INDEX #surfsbjind] >]]],
				    HEAD.KEYS.KEY pass_rel],
			      
			       CONT [RELS <! !>,
				     HOOK [INDEX #event & [E.PASS +],
					   LTOP #hand,
					   XARG #surfsbjind],
				     HCONS <! !>],
			       CTXT.EMPATHY.EMPEE #surfobjind],
			LKEYS.KEYREL pass-relation &  [LBL #hand]],
		LMORPH-BIND-TYPE pass-c-stem-morph,
		INFLECTED -,
		STEMTYPE v-stem].

; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

; (ERB 2002-01-02) Also moving the constraint VN = SPR.VN here.

; (MS 2002-11-19) The coindexation of the subject must be moved to the semantics.

;v-honorific-end-lex := v-simple-end-lex &
;[SYNSEM.LOCAL [CAT [HEAD [ VN #vn,
;                           FORMAL.SHON + ],
;                    VAL.SPR.FIRST.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;								    CONT.HOOK.INDEX #2],
;                                               HEAD.VN #vn & - ]],
;               CONT [HOOK.INDEX #3,
;                     RELS <! !>],
;               CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
;                                                   [HONORED #2,
;                                                    BEARER #3,
;                                                    POLARITY +] !>]]].

; (MS 2003-12-19) Matrix 0.6

v-honorific-end-lex := v-simple-end-lex &
[SYNSEM [LOCAL [CAT [HEAD [ VN #vn,
			    FORMAL [SHON +,
				    AHON -],
			    MOD < [LOCAL [CAT.HEAD noun_head,
					  BAR +]] >,
			    J-POSTHEAD rels,
			    J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
			    FIN +,
			    C-MOD null,
			    MODUS indicative],
                    VAL.SPR.FIRST [LOCAL [CAT.HEAD.VN #vn & -,
					  CONT.HOOK.XARG #2]]],
               CONT [HOOK.INDEX #3,
                     RELS <! !>],
               CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                   [HONORED #2,
                                                    BEARER #3,
                                                    POLARITY +] !>]],
	 MODIFIED.PERIPH +],
 INFLECTED -,
 LMORPH-BIND-TYPE pass-v-stem-morph,
 STEMTYPE v-stem].

; (ERB 2001-11-14) This doesn't get "gohan wo tabechatta" because it requires
; tabe to pick up its arguments before combining, and tabe can't combine with
; the head-subj rule (it still needs an affix).

; (ERB 2001-11-14) Also changing the semantics to match the current version
; of shimau.  Should be changed when shimau gets changed to aspect only.

; (ERB 2001-11-19) Difficult merge here.  I'm going to start with Melanie's version
; and see if there are any changes left to work in.

; (ERB 2001-11-19) Adding back 11-14 changes... (the ending raises all of the 
; arguments; arg4only semantics).


; (ERB 2001-11-19) This version gets られちゃった but not
; non-subj arguments.


; (ERB 2001-11-19) This version gets arguments (ご飯をたべちゃった) but doesn't
; combine with passive.

; (ERB 2001-12-05) I think Melanie fixed it so it does combine with passive.
; There is some spurious ambiguity because the vend-vend rule can combine
; either られ and ちゃっ first or ちゃっ and た  first.

; (ERB 2001-12-05) Changing the semantics to be like "pure" aspect auxes
; now that I've changed shimau.  (Should bring teru in line with teiru, too!)


; (MS & FCB 2003-10-29) STEMTYPE otherstem included, but stops it working FIXME!!!


v-contracted-aux-end-lex := v-op-end-lex &
[SYNSEM [LOCAL [CAT [HEAD contracted-aux_head & [MODUS #modus],
		     VAL [SUBJ  #subjval,
                          COMPS #compsval,
			  SPR obl-1-arg &
				[FIRST [LOCAL [CONT.HOOK #hook,
					       CAT [HEAD [AUX aux_minus,
							  MODUS #modus],
						    VAL [SUBJ #subjval,
							 COMPS #compsval]]]]]]],
		CONT [RELS <! !>,
		      HOOK #hook,
		      HCONS <!  !>]],
	 MODIFIED.PERIPH +],
 INFLECTED bool,
 STEMTYPE otherstem].

v-contracted-aux-progressive-end-lex := v-contracted-aux-end-lex &
					[J-NEEDS-AFFIX +,
					 LMORPH-BIND-TYPE t-morph,
					 SYNSEM.LOCAL [CONT.HOOK.INDEX.E [ ASPECT progressive,
									   MOOD #modus],
						       CAT.HEAD.MODUS #modus]].



v-contracted-aux-terminative-end-lex := v-contracted-aux-end-lex &
					[J-NEEDS-AFFIX -,
					 INFLECTED -,
					 SYNSEM.LOCAL [CAT.HEAD.COP-ARG -,
						       CONT [HOOK.INDEX.E [MOOD indicative,
									   ASPECT terminative]]]].

v-contracted-aux-terminative-tmorph-end-lex := v-contracted-aux-terminative-end-lex &
					       [LMORPH-BIND-TYPE t-morph].

v-contracted-aux-terminative-ndmorph-end-lex := v-contracted-aux-terminative-end-lex &
					       [LMORPH-BIND-TYPE nd-morph].


;(MS 01-09-19) If the top-handle should be the handle of the subord_rel, we have problems with the restriction that LTOP = KEY.LBL.
; (MS 02-11-19) Shift the restriction on the subject to the semantics.
; (MS 2004-11-08) AUX aux_minus on the SPR seems to be too strict: 帰って来やすい

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND

v2adj-end-lex := v-op-end-lex &
[SYNSEM [LKEYS.KEYREL #key,
	 LOCAL [CAT [HEAD.MODUS indicative,
		     VAL [SPR.FIRST [OPT - ,
				     LOCAL [CAT [HEAD  verb-stem_head & [MAIN-PRD -,
									 COP -,
									 VN -,
									 AUX aux],
						 VAL [SUBJ #verbsbj & null,
						      COMPS #verbcomps]],
					    CONT.HOOK [LTOP #verbhd, INDEX #verbindex]]],
			  SUBJ #verbsbj,
			  COMPS #verbcomps]],
		CONT [HOOK [LTOP #adjhd,
			    INDEX #ind],
		      RELS <! arg12-relation & #key & [LBL #adjhd,
						  ARG0 #ind,
						  ARG2 #prpstn-hd],
			    message &
			    [PRED proposition_m_rel,
			     LBL #prpstn-hd,
			     ARG0 #verbindex,
			     MARG #soa] !>,
		      HCONS <! qeq & [HARG #soa, LARG #verbhd] !>]]]].

v2adj-nmod-end-lex := v2adj-end-lex &
		      [SYNSEM [LOCAL.CAT.HEAD [H-TENSE present,
					       MODUS indicative,
					       MOD < [LOCAL [CAT [HEAD noun_head,
								  VAL.SPR 1-list],
							     BAR +]] >,
					       J-POSTHEAD rels,
					       MARK null,
					       VN -,
					       C-MOD null,
					       J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					       FIN +,
					       FORMAL.AHON -]],
		       J-NEEDS-AFFIX -,
		       INFLECTED -,
		       LMORPH-BIND-TYPE i-morph].

v2adj-nmod-maybeend-lex := v2adj-end-lex &
		      [SYNSEM [LOCAL.CAT.HEAD [H-TENSE present,
						  MODUS indicative,
						  MOD < [LOCAL [CAT [HEAD noun_head,
								     VAL.SPR 1-list],
								BAR +]] >,
						  J-POSTHEAD rels,
						  MARK null,
						  VN -,
						  C-MOD null,
						  J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
						  FIN +,
						  FORMAL.AHON -],
			       MODIFIED.PERIPH +],
			  J-NEEDS-AFFIX bool,
			  INFLECTED bool,
			  LMORPH-BIND-TYPE i-morph].

v2adj-nmod-maybeend-lex-v1 := v2adj-nmod-maybeend-lex &
			      [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & [FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
													     CONT.HOOK.INDEX #verbobj]]]]],
				       LKEYS.KEYREL.ARG1 #verbobj]].

v2adj-nmod-maybeend-lex-v2 := v2adj-nmod-maybeend-lex &
			      [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST #verbobj,
									CAT.VAL.COMPS null]]],
				       LKEYS.KEYREL.ARG1 #verbobj]].




v2adj-end-lex-v1 := v2adj-end-lex &
[SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & 
							[FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
								      CONT.HOOK.INDEX #verbobj]]]]],
	 LKEYS.KEYREL.ARG1 #verbobj]].

v2adj-notyetend-lex-v1 := v2adj-end-lex-v1 &
			  [J-NEEDS-AFFIX +,
			   LMORPH-BIND-TYPE i-morph].

v2adj-notyetend-lex-v2 := v2adj-end-lex-v2 &
			  [J-NEEDS-AFFIX +,
			   LMORPH-BIND-TYPE i-morph,
			   SYNSEM.MODIFIED.PERIPH +].




v2adj-end-v1-nmod-lex := v2adj-nmod-end-lex &
			 [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & 
										 [FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
											       CONT.HOOK.INDEX #verbobj]]]]],
				  LKEYS.KEYREL.ARG1 #verbobj]].
			 

v2adj-end-lex-v2 := v2adj-end-lex &
[SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST.ARG2 #verbobj,
					  CAT.VAL.COMPS null]]],
	 LKEYS.KEYREL.ARG1 #verbobj]].


v2adj-end-v2-nmod-lex := v2adj-nmod-end-lex &
			 [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST.ARG2 #verbobj,
							     CAT.VAL.COMPS null]]],
				  LKEYS.KEYREL.ARG1 #verbobj]].

; (MS 2004-12-22) no MOD-IND/MOD-HAND

v2na-end-lex := v-op-end-lex &
[J-NEEDS-AFFIX -,
 LMORPH-BIND-TYPE i-morph,
 SYNSEM [LKEYS.KEYREL #key & [ARG0 #event,
                                 LBL #top,
				 ARG4 #h2],
	 LOCAL [CAT [HEAD na-adj-end_head & [MAIN-PRD -],
		     VAL [SUBJ #sbjval,
			  COMPS #compsval,
			  SPR.FIRST [OPT - ,
				     LOCAL [CONT.HOOK.LTOP #h1,
					    CAT [VAL [COMPS #compsval,
						     SUBJ #sbjval],
						 HEAD.MAIN-PRD -]]]]],
               CONT [HOOK [INDEX #event,
			   LTOP #top],
                     RELS <! #key !>,
                     HCONS <! qeq & [HARG #h2,LARG #h1] !>]]]].

;"出来るだけ", "食べられるだけ"

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)
; (MS 2004-12-22) no MOD-IND/MOD-HAND

                                                 
v2adv-end-lex := lexical_sign-word &
               [SYNSEM  j-synsem & [LOCAL [CAT [HEAD adv_head-avm & [MOD < [LOCAL scopal_mod & 
									     [CONT.HOOK [LTOP #handel,
											 INDEX #ind],
									      CAT.HEAD.MODUS voluntative]] >,
								     COP-ARG +,
								   J-POSTHEAD left],
					      VAL obj-arg &
						   [COMPS.FIRST [OPT - ,
								 LOCAL [CAT [HEAD verb_head &
									     [FIN +,
									      ADJ -,
									      FORMAL.AHON -,
									      MAIN-PRD -],
									VAL saturated],
									NUCL nucl_plus]]]],
					 CONT scopal-adv-sem-type &
					     [HOOK.INDEX #ind, 
					      RELS <! #key !>]],
				    LKEYS.KEYREL #key & adv-relation & [LBL #handel],
				    NON-LOCAL [QUE <! !>,
					       AFFIX <! !>]],
		INFLECTED +,
		LMORPH-BIND-TYPE mai-morph].     

;(CH 2005-04-09) added [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.BAR -].
v2n-end-lex :=  nom-lex &
		[SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
			 LOCAL [CAT.VAL nom_sc & [SPR.FIRST [LOCAL [CAT [HEAD verb_head &
									      [MODUS infinitive,
									       ADJ -,
									       FORMAL.AHON -,
									       VN -,
									       MAIN-PRD -],
									 VAL saturated],
								    BAR -,
								    CONT.HOOK [LTOP #v-hd,
									       INDEX #v-index],
								    NUCL nucl_plus]]],
				CONT nom-pred-sem-type &
						  [RELS <! #key &
							 [ARG1 #prpstn-hd,
							  ARG0 #kata-index,
							  LBL #kata-hd],
							    quant-relation & 
							    [PRED def_rel,
							     ARG0 #kata-index,
							     RSTR #def-restr],
							    message &
							 [PRED proposition_m_rel,
							  LBL #prpstn-hd,
							  ARG0 #v-index,
							  MARG #prpstn-soa] !>,
						   HOOK.INDEX #i,
						   HCONS <! qeq & [HARG #prpstn-soa,LARG #v-hd],
							     qeq & [HARG #def-restr, LARG #kata-hd] !>]]]].

							    




; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (FCB 2005-06-27)  this seems to be covered by adj2v-end-lex.
; adj2v-end-lex := prpstn-introducing-end-lex &
; 		 [SYNSEM [LKEYS.KEYREL [PRED 'seem,
; 					    LBL #top],
; 			  LOCAL [CAT [HEAD v-op-end_head & [KEYS.KEY seem_rel],
; 				      VAL.SPR.FIRST.LOCAL.CAT.HEAD.ADJ +],
; 				 CONT [HOOK [LTOP #top,
; 					     INDEX.E.MOOD indicative]]],
; 			  MODIFIED.PERIPH +],
; 		  J-NEEDS-AFFIX +,
; 		  LMORPH-BIND-TYPE shortadj-morph,
; 		  STEMTYPE c-stem].
				       

; (MS 2004-12-22) no MOD-IND/MOD-HAND
; (FCB 2005-06-27)  this seems to be covered by adj2v-end-lex.
; garu-end-lex := prpstn-introducing-end-lex &
;                [SYNSEM [LKEYS.KEYREL [LBL #top,
; 				      PRED 'seem],
; 			LOCAL [CAT [HEAD.KEYS.KEY seem_rel],
;                               CONT [HOOK [LTOP #top,
; 					  INDEX.E.MOOD indicative]]],
; 			MODIFIED.PERIPH +],
; 		J-NEEDS-AFFIX +,
;                 LMORPH-BIND-TYPE i-morph,
; 		STEMTYPE c-stem].

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.
; (MS 2004-12-22) no MOD-IND/MOD-HAND


mai-end-lex := v-noncaus-op-end-lex &
               [SYNSEM [LKEYS.KEYREL #key & neg-relation & [LBL #top, 
							    PRED 'neg_rel,
							    ARG1 #h3],
			LOCAL [CAT [HEAD v-op-end_head &
					 [MODUS indicative,
                                          MOD null,
                                          C-MOD null,
                                          H-TENSE present,
                                          MARK null,
                                          J-SPEC null,
                                          FIN +],
                                   VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #h1,
								    INDEX #i1,
								    XARG #x1]]]],
                              CONT [HOOK [INDEX #event,
					  LTOP #top],
                                    RELS <! #key,
                                             want2-relation & [LBL #h3,
                                                          ARG0 #event,
                                                          ARG1 #x1,
                                                          ARG2 #h6],
					  message &
					  [PRED proposition_m_rel,
					   LBL #h6,
					   ARG0 #i1,
					   MARG #h7] !>,
                                    HCONS <! qeq & [HARG #h7,
                                                     LARG #h1] !>]]],
		J-NEEDS-AFFIX -,
		LMORPH-BIND-TYPE mai-morph].

beki-end-lex:= v-noncaus-op-end-lex &
               [SYNSEM [LKEYS.KEYREL #key & scopal-adv-relation & [PRED '_beki_a_rel,
								   ARG0 #ind,
								   ARG1 #h3],
			LOCAL [CAT [HEAD v-op-end_head &
					 [MODUS indicative,
                                          MOD null,
                                          C-MOD null,
                                          H-TENSE present,
                                          MARK null,
                                          J-SPEC null,
                                          FIN +],
                                   VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #h1,
								    INDEX #ind]]]],
                              CONT [HOOK [INDEX #ind],
                                    RELS <! #key !>,
                                    HCONS <! qeq & [HARG #h3,
                                                     LARG #h1] !>]]],
		J-NEEDS-AFFIX -,
		LMORPH-BIND-TYPE beki-morph].

 


; (ERB 2002-01-07) Need to add SMOD value to keep this from being
; the right conjunct of an s-conj-lex (as opposed to s-conj-nonprop-lex).

; (ERB 2002-01-11) Make sure this doesn't inherit SMOD unmarked.

; (ERB 2002-01-14) For nonprop conjunctions, make this more like
; kudasai-hiragana-sap, i.e., it contributes the imp_rel and does
; the right thing with the handle.  Should therefore also be SMOD decl.
; (Previously RELS & HCONS <! !> and SMOD imp.)

; (ERB 2002-01-14) These constraints are getting far to complicated
; to leave on the lexical entries themselves.  Making supertype here.

; (MS 2002-01-16) Added restrictions on subcategorization. 
; (MS 2003-12-17) Adapting to Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND

kudasai-vn-end := v-end-lex &
[J-NEEDS-AFFIX -,
 SYNSEM [LOCAL [CAT [HEAD [MODUS polite-imperative,
                          MOD null,
                          COP-ARG -,
                          C-MOD null,
                          H-TENSE present,
                          MARK null, 
                          J-SPEC null,
                          FIN +,
                          VN -],
		    VAL [SPR.FIRST [LOCAL [CAT [HEAD.VN +],
					   CONT [HOOK [LTOP #sprh,
						       INDEX #ind]]]]]],
	       CONT [HOOK [LTOP #top,
			   INDEX #ind],
                     RELS <! message & [PRED command_m_rel,
                                         LBL #top,
					 ARG0 #ind,
                                         MARG #soah] !>,
                     HCONS <! qeq & [LARG #sprh,
                                      HARG #soah] !> ]]]].


                   
;;;;;;;;;;;;;;VERBAL STEMS;;;;;;;;;;;;;;;

; (MS 2004-01-13) Experimenting with BAR bool instead of BAR -.
; (MS 2004-11-05) But that introduces spurious ambiguity with the
; unary-vstem-vend-rule.

verb-stem-lex-base  := v-lex & 
              [SYNSEM [LOCAL [CAT.HEAD verb-stem_head,
                              BAR bool]],
               J-NEEDS-AFFIX +,
               INFLECTED -].

verb-stem-lex-super := verb-stem-lex-base.

verb-stem-lex := verb-stem-lex-super &
              [SYNSEM [LKEYS.KEYREL [ ARG0 #ind,
				      LBL #top,
				      PRED #pred],
		       LOCAL [CAT.HEAD.KEYS.KEY #pred,
			      CONT simple-verb-sem-type &
				      [HOOK [INDEX #ind,
					     LTOP #top]]]]].

v-stem-lex := verb-stem-lex & lexical_sign-word &
[SYNSEM [LKEYS.KEYREL #key,
	 LOCAL [CAT.HEAD v-stem_head,
		CONT [RELS.LIST.FIRST #key]]]].

v-nonop-stem-lex := v-stem-lex &
                    [SYNSEM [LOCAL.CONT verb-sem-type &
                                             [HOOK.INDEX event,
                                              RELS <! #key !>,
                                              HCONS <! !>],
			     LKEYS.KEYREL #key]].

v-sbj-comps-stem-lex := v-nonop-stem-lex &
		   [SYNSEM.LOCAL [CAT.VAL [SUBJ.FIRST #sbj,
					   COMPS #comps],
				  ARG-S < #sbj . #comps >]].




intrans-stem-lex := v-nonop-stem-lex &
                    [SYNSEM [LKEYS.KEYREL [ARG1 #sbjind],
			     LOCAL [CAT [HEAD [COP -],
                                        VAL intransitive &
                                             [SUBJ #sbj & [FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]]],
				    CONT  [HOOK.XARG #sbjind],
				    ARG-S #sbj ]]].

intrans-nohon-stem-lex := intrans-stem-lex & 
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

intrans-shon-stem-lex  := intrans-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]],
                             NON-LOCAL.QUE <! !>]].

intrans-minusshon-stem-lex  := intrans-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                     [HONORED #2,
                                                      BEARER #3,
                                                      POLARITY -] !>]],
                             NON-LOCAL.QUE <! !>]].

intrans-c2-stem-lex := intrans-nohon-stem-lex & [STEMTYPE c2-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-c2-stem-minusbar-lex := intrans-c2-stem-lex &
		       [SYNSEM.LOCAL.BAR -].
intrans-c-stem-lex := intrans-nohon-stem-lex & [STEMTYPE c-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-c-stem-normorph-lex := intrans-c-stem-lex &
			       [RMORPH-BIND-TYPE nomorphbind].



intrans-c-stem-wh-lex  := intrans-nohon-stem-lex & [STEMTYPE c-stem,
                                                    SYNSEM [LOCAL.CONT.HOOK.LTOP #top,
                                                            NON-LOCAL.QUE <! #top !>]].
intrans-v-stem-lex := intrans-nohon-stem-lex & [STEMTYPE v-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].
intrans-v-stem-normorph-lex := intrans-v-stem-lex &
			       [RMORPH-BIND-TYPE nomorphbind].

intrans-v-stem-bar-lex := intrans-v-stem-lex &
			  [SYNSEM.LOCAL.BAR +].

intrans-v-stem-normorph-bar-lex := intrans-v-stem-normorph-lex & intrans-v-stem-bar-lex.

intrans-kurusuru-stem-lex := intrans-nohon-stem-lex & [STEMTYPE kurusuru-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-shon-c2-stem-lex := intrans-shon-stem-lex & [STEMTYPE c2-stem].
intrans-shon-c-stem-lex := intrans-shon-stem-lex & [STEMTYPE c-stem].
intrans-shon-v-stem-lex := intrans-shon-stem-lex & [STEMTYPE v-stem].
intrans-shon-kurusuru-stem-lex := intrans-shon-stem-lex & [STEMTYPE kurusuru-stem].

intrans-minusshon-c2-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE c2-stem].
intrans-minusshon-c-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE c-stem].
intrans-minusshon-v-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE v-stem].
intrans-minusshon-kurusuru-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-10-18) I need these verbs to have a special KEY type
; so that the k2y machinery can recognize them.  Currently, they
; are getting arg3_rel-super by type inference, and this isn't specific
; enough.
;
; (MS 2003-07-10) Due to adapations to the matrix, ARG2 is changed to ARG1.

;intransarg3-stem-lex := v-nonop-stem-lex &
;                    [SYNSEM.LOCAL [CAT [HEAD [COP -],
;                                        SUBCAT intransitive &
;                                             [VAL.SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
;                                        KEYS  [KEY [ARG2 #sbjind]]]].

;intransarg2-stem-lex := v-nonop-stem-lex &
;                    [SYNSEM [LOCAL [CAT [HEAD [COP -],
;                                        VAL intransitive &
;                                             [SUBJ.FIRST #sbj & [LOCAL.CONT [HOOK.INDEX #sbjind]]]],
;                                        CONT  [HOOK.XARG #sbjind],
;				    ARG-S < #sbj > ],
;			      LKEYS.KEYREL arg1-relation &
;                                                   [ARG1 #sbjind],
;                             NON-LOCAL.QUE <! !>]].
;
;intransarg2-nohon-stem-lex := intransarg2-stem-lex & 
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;intransarg2-shon-stem-lex  := intransarg2-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY +] !>]]].
;
;intransarg2-minusshon-stem-lex  := intransarg2-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
;                                                     [HONORED #2,
;                                                      BEARER #3,
;                                                      POLARITY -] !>]]].
;
;intransarg2-c2-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-c-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE c-stem].
;intransarg2-v-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE v-stem].
;intransarg2-kurusuru-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE kurusuru-stem].
;
;intransarg2-shon-c2-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-shon-c-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE c-stem].
;intransarg2-shon-v-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE v-stem].
;intransarg2-shon-kurusuru-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE kurusuru-stem].
;
;intransarg2-minusshon-c2-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-minusshon-c-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE c-stem].
;intransarg2-minusshon-v-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE v-stem].
;intransarg2-minusshon-kurusuru-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE kurusuru-stem].
;

v1-stem-lex := v-sbj-comps-stem-lex &
                  [SYNSEM [LKEYS.KEYREL [ARG1 #sbjind,
					    ARG2 #objind],
			   LOCAL [CAT [HEAD [COP -,
                                            MODUS mood],
                                      VAL ga-wo_transitive &
                                             [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
					      COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
                                 CONT [HOOK.XARG #sbjind]]]].

v1-nohon-stem-lex := v1-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v1-shon-stem-lex  := v1-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
						       POLARITY +] !>]],                              
			      NON-LOCAL.QUE <! !>]].

v1-minusshon-stem-lex  := v1-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                     [HONORED #2,
                                                      BEARER #3,
                                                      POLARITY -] !>]],
                              NON-LOCAL.QUE <! !>]].

v1-c2-stem-lex := v1-nohon-stem-lex & [STEMTYPE c2-stem,
                                       SYNSEM.NON-LOCAL.QUE <! !>].
v1-c-stem-lex := v1-nohon-stem-lex & [STEMTYPE c-stem,
                                      SYNSEM.NON-LOCAL.QUE <! !>].
v1-c-stem-normorph-lex := v1-c-stem-lex &
			  [RMORPH-BIND-TYPE nomorphbind].

v1-v-stem-lex := v1-nohon-stem-lex & [STEMTYPE v-stem,
                                      SYNSEM.NON-LOCAL.QUE <! !>].

v1-v-stem-normorph-lex := v1-v-stem-lex &
			  [RMORPH-BIND-TYPE nomorphbind].

v1-v-stem-bar-lex := v1-v-stem-lex &
		     [SYNSEM.LOCAL.BAR +].

v1-v-stem-normorph-bar-lex := v1-v-stem-normorph-lex & v1-v-stem-bar-lex.

; (MS 2002-05-19) ageru sets the empathy to its agent.

v1-v-stem-arg1emp-lex := v1-v-stem-lex &
			 [SYNSEM [LKEYS.KEYREL.ARG1 #arg1,
				  LOCAL.CTXT.EMPATHY.EMPEE #arg1]].

v1-kurusuru-stem-lex := v1-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v1-kurusuru-nonquest-stem-lex := v1-kurusuru-stem-lex &
				 [SYNSEM.NON-LOCAL.QUE <! !>].

v1-kurusuru-quest-stem-lex := v1-kurusuru-stem-lex &
				 [SYNSEM [NON-LOCAL.QUE <!#top !>,
					  LOCAL.CONT.HOOK.LTOP #top]].

v1-kurusuru-overtargs-stem-lex := v1-kurusuru-stem-lex &
				  [SYNSEM.LOCAL.CAT.VAL [SUBJ.FIRST.LOCAL.CAT.HEAD.PTYPE overt,
							 COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE overt]].

v1-kurusuru-nonquest-overtargs-stem-lex := v1-kurusuru-overtargs-stem-lex & v1-kurusuru-nonquest-stem-lex.

v1-c2-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE c2-stem].
v1-c-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE c-stem].
v1-v-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE v-stem].
v1-kurusuru-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE kurusuru-stem].


v1-c2-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE c2-stem].
v1-c-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE c-stem].
v1-v-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE v-stem].
v1-kurusuru-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2004-07-06) v1a with obligatory wo-comp is not used any more.

v2-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-ni_transitive &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                              CONT [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                        NON-LOCAL.QUE <! !>]].

v2-nohon-stem-lex := v2-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2-shon-stem-lex  := v2-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
							       CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2-minusshon-stem-lex  := v2-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


v2-c2-stem-lex := v2-nohon-stem-lex & [STEMTYPE c2-stem].
v2-c-stem-lex := v2-nohon-stem-lex & [STEMTYPE c-stem].
v2-v-stem-lex := v2-nohon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-stem-lex := v2-nohon-stem-lex & [STEMTYPE infinitive-stem].

; (SF 2003-08-28) 
v2-kurusuru-stem-lex := v2-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v2-c2-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE c2-stem].
v2-c-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE c-stem].
v2-v-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE infinitive-stem].


v2-c2-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE c2-stem].
v2-c-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE c-stem].
v2-v-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE infinitive-stem].

; (ERB 2002-02-14) This had the subject's index linked to ARG2, not
; ARG1.  Changing it to ARG1.  Nothing was explicitly saying arg123-relation,
; so now it's just arg12-relation.

; (MS 2004-12-20) Just identify the COMPS...LTOP with the KEYREL...LBL, not go via COMPS..MOD..LTOP.
; 元気になる
; (FCB and CH 2005-03-12) super type for subject-complement verbs v2a and v2b
; (and Dan and all) added a proposition, cleaned up the MRS
v-sc-stem-lex := v-stem-lex &
		 [SYNSEM [LOCAL [CAT [HEAD.COP -,
				      VAL.SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
				 CONT [HOOK [XARG #sbjind,
					     INDEX event],
				       RELS.LIST < #key,
						   message &
						   [PRED proposition_m_rel,
						    LBL #phand,
						    MARG #soa ], ... >,
				       HCONS  <! qeq & [HARG #soa] !> ]],
			  LKEYS.KEYREL arg1-relation & #key &
				[ARG1 #phand],
			  NON-LOCAL.QUE <! !>]].

; (MS 2005-05-24) Try to make the complement obligatory, to avoid ambiguity.
; as in 病気になる
; (MS 2005-10-20) But this way, V-ばならない doesn't work any more!

v-sc-n-stem-lex := v-sc-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL ga-to-ni_transitive2 &
			  [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			   COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #compind]],
		 CONT [RELS <! relation, 
			     relation & [ARG0 #copind],
			     [PRED 'cop_id_rel,
			      ARG0 event & #copind,
			      ARG1 #sbjind,
			      ARG2 #compind,
			      LBL #chand] !>,
		       HCONS  <! [LARG #chand] !> ]]]].

v-sc-a-stem-lex := v-sc-stem-lex &
 [SYNSEM.LOCAL [CAT [VAL naru_adv_transitive &
			 [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			  COMPS.FIRST.LOCAL.CONT.HOOK [XARG #sbjind,
						       INDEX #cindex,
						       LTOP #chand]]],
		CONT [RELS <! relation,
			    relation &  [ARG0 #cindex]!>,
		      HCONS  <! [LARG #chand] !> ]]].


v2a-nohon-stem-lex := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2a-shon-stem-lex  := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2a-minusshon-stem-lex  := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


v2a-c2-stem-lex := v2a-nohon-stem-lex & [STEMTYPE c2-stem].
v2a-c-stem-lex := v2a-nohon-stem-lex & [STEMTYPE c-stem].
v2a-v-stem-lex := v2a-nohon-stem-lex & [STEMTYPE v-stem].

v2a-c2-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE c2-stem].
v2a-c-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE c-stem].
v2a-v-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE v-stem].

v2a-c2-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE c2-stem].
v2a-c-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE c-stem].
v2a-v-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE v-stem].

; (MS 2004-03-22) added to parse 男になる with a copula semantics embedded.

v2b-nohon-stem-lex := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2b-shon-stem-lex  := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2b-minusshon-stem-lex  := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

; (FCB and CH 2005-03-12) This can only be 成る (c-stem)

v2b-c-stem-lex := v2b-nohon-stem-lex & [STEMTYPE c-stem].

v2b-c-shon-stem-lex := v2b-shon-stem-lex & [STEMTYPE c-stem].


; (FCB and CH 2005-03-12) for complement suru 
; (do-parse-tty "彼 が 鉛 を 銀 に し た") "he made lead into silver"
; (FCB 2005-03-22) added in proposition (like v-sc-stem-lex)
; FIXME: could still reify a bit with v-sc-stem-lex
; FIXME: should maybe not be PRED 'cop_id_rel, but something similar
; (FCB 2005-06-15) Added ARG0 to messages

v-soc-stem-lex := v-stem-lex &
 [SYNSEM [LOCAL [CAT [HEAD.COP -,
		      VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind],
		 CONT [HOOK [XARG #sbjind,
			     INDEX event ],
		       RELS.LIST <  #key,
			       message & 
			       [PRED proposition_m_rel,
				LBL #phand,
				MARG #soa ], ...  >,
		       HCONS  <! qeq & [HARG #soa] !> ]],
	  LKEYS.KEYREL arg12-relation & #key &
		[ARG1 #sbjind,
		 ARG2 #phand],
	  NON-LOCAL.QUE <! !>]].

v-soc-adv-stem-lex := v-soc-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL suru_adv_ditransitive &
			[COMPS < [LOCAL.CONT.HOOK.INDEX #objind],
				 [LOCAL.CONT.HOOK [XARG  #objind,
						   INDEX #cindex,
						   LTOP  #chand]] >] ,
		CONT [RELS <! relation, relation &
			    [ARG0 #cindex] !>,
		      HCONS  <! [LARG #chand] !> ]]].

v-soc-noun-stem-lex := v-soc-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL suru_noun_ditransitive &
			[COMPS < [LOCAL.CONT.HOOK.INDEX #objind],
				 [LOCAL.CONT.HOOK.INDEX #compind] >],
		CONT [RELS <! relation, 
			    relation &
			    [ARG0 #cindex],
			    [PRED 'cop_id_rel,
			     ARG0 event & #cindex,
			     ARG1 #objind,
			     ARG2 #compind,
			     LBL #chand] !>,
		      HCONS  <! [LARG #chand] !>]]].

;; plus honorification SCO-noun
v-soc-noun-nohon-stem-lex := v-soc-noun-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v-soc-noun-shon-stem-lex  := v-soc-noun-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].
;; plus honorification SCO-adv
v-soc-adv-nohon-stem-lex := v-soc-adv-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v-soc-adv-shon-stem-lex  := v-soc-adv-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].
; (FCB and CH 2005-03-12) This can be する なさる (c-stem)

;する
v-soc-noun-kurusuru-stem-lex := v-soc-noun-nohon-stem-lex & [STEMTYPE kurusuru-stem].
v-soc-adv-kurusuru-stem-lex := v-soc-adv-nohon-stem-lex & [STEMTYPE kurusuru-stem].

;なさる
v-soc-noun-c2-shon-stem-lex := v-soc-noun-shon-stem-lex & [STEMTYPE c2-stem].
v-soc-adv-c2-shon-stem-lex := v-soc-adv-shon-stem-lex & [STEMTYPE c2-stem].
            

v5-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-to_transitive2 &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.LTOP #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                           CONT verb-sem-type &
                                         [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                        NON-LOCAL.QUE <! !>]].


v5-nohon-stem-lex := v5-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v5-shon-stem-lex  := v5-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v5-minusshon-stem-lex  := v5-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v5-c2-stem-lex := v5-nohon-stem-lex & [STEMTYPE c2-stem].
v5-c-stem-lex := v5-nohon-stem-lex & [STEMTYPE c-stem].
v5-v-stem-lex := v5-nohon-stem-lex & [STEMTYPE v-stem].

v5-c2-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE c2-stem].
v5-c-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE c-stem].
v5-v-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE v-stem].


v5-c2-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE c2-stem].
v5-c-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE c-stem].
v5-v-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE v-stem].

; (ERB 2001-11-14) QUE values inside of embedded questions
; should be able to be bound off at the embedded clause.  For
; now I'm assuming that they are necessarily bound off.  Short
; run solution is a non-branching rule that binds it off. To
; force the rule to apply, these verbs must select for QUE <! !>
; empty complements.

v5a-stem-lex := v-sbj-comps-stem-lex  &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-to_transitive1 &
                                      [COMPS.FIRST [ LOCAL.CONT [HOOK.LTOP #objind],
						     NON-LOCAL.QUE <! !> ],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			       CONT verb-sem-type &
				   [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
				      ARG2 #objind],
                        NON-LOCAL.QUE <! !>]].


v5a-nohon-stem-lex := v5a-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v5a-shon-stem-lex  := v5a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v5a-minusshon-stem-lex  := v5a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v5a-c2-stem-lex := v5a-nohon-stem-lex & [STEMTYPE c2-stem].
v5a-c-stem-lex := v5a-nohon-stem-lex & [STEMTYPE c-stem].
v5a-v-stem-lex := v5a-nohon-stem-lex & [STEMTYPE v-stem].
v5a-kurusuru-stem-lex := v5a-nohon-stem-lex & 
			 [STEMTYPE kurusuru-stem,
			  SYNSEM [LOCAL.CAT.VAL [SUBJ.FIRST.LOCAL.CAT.HEAD.PTYPE overt,
						 COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE overt],
				  NON-LOCAL.QUE <! !>]].

v5a-c2-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE c2-stem].
v5a-c-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE c-stem].
v5a-v-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE v-stem].
v5a-kurusuru-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE kurusuru-stem].


v5a-c2-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE c2-stem].
v5a-c-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE c-stem].
v5a-v-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE v-stem].
v5a-kurusuru-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2004-06-01) V7 seems not to be in use any more.
; (MS 2005-10-26) We need that for daisuru (題する - entitle).

v7-stem-lex  := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-wo-toni-ditransitive &
                                      [COMPS < [LOCAL.CONT [HOOK.INDEX #objind]],
					       [LOCAL.CONT [HOOK.INDEX #obj2ind]] >,
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                           CONT verb-sem-type &
                                         [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
                                               ARG2 #objind,
                                               ARG3 #obj2ind],
                        NON-LOCAL.QUE <! !>]].

v7-nohon-stem-lex := v7-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v7-shon-stem-lex  := v7-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v7-minusshon-stem-lex  := v7-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2 ]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v7-c2-stem-lex := v7-nohon-stem-lex & [STEMTYPE c2-stem].
v7-c-stem-lex := v7-nohon-stem-lex & [STEMTYPE c-stem].
v7-v-stem-lex := v7-nohon-stem-lex & [STEMTYPE v-stem].
v7-kurusuru-stem-lex := v7-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v7-c2-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE c2-stem].
v7-c-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE c-stem].
v7-v-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE v-stem].

v7-c2-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE c2-stem].
v7-c-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE c-stem].
v7-v-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE v-stem].

;(MS 2004-06-01) I don't think we need this any more.

;aru-stem-lex := intrans-stem-lex &
;               [SYNSEM.NON-LOCAL.QUE <! !>].
;
;
;aru-nohon-stem-lex := aru-stem-lex &
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;
;aru-c2-stem-lex := aru-nohon-stem-lex & [STEMTYPE c2-stem].
;aru-c-stem-lex := aru-nohon-stem-lex & [STEMTYPE c-stem].
;aru-v-stem-lex := aru-nohon-stem-lex & [STEMTYPE v-stem].

;aru-c2-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE c2-stem].
;aru-c-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE c-stem].
;aru-v-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE v-stem].

;aru-c2-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE c2-stem].
;aru-c-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE c-stem].
;aru-v-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE v-stem].

; (MS 2004-08-24) ARG2 is now linked to LTOP, not the INDEX.


v3-stem-lex := v-sbj-comps-stem-lex &
              [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                  VAL ga-to_transitive1 &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.LTOP #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			      CONT [HOOK.XARG #sbjind]],
		       LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                       NON-LOCAL.QUE <! !>]].

v3-nohon-stem-lex := v3-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v3-shon-stem-lex  := v3-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v3-minusshon-stem-lex  := v3-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v3-c-stem-lex := v3-nohon-stem-lex & [STEMTYPE c-stem].
v3-c2-stem-lex := v3-nohon-stem-lex & [STEMTYPE c2-stem].
v3-v-stem-lex := v3-nohon-stem-lex & [STEMTYPE v-stem].

v3-c-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE c-stem].
v3-c2-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE c2-stem].
v3-v-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE v-stem].

v3-c-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE c-stem].
v3-c2-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE c2-stem].
v3-v-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE v-stem].

v4-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL ditransitive &
                         [COMPS < [LOCAL.CONT [HOOK.INDEX #objind]],
				  [LOCAL.CONT [HOOK.INDEX #obj2ind]] >,
			  SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
	 LKEYS.KEYREL [ARG1 #sbjind,
			   ARG2 #objind,
			   ARG3 #obj2ind],
         NON-LOCAL.QUE <! !>]].

v4-nohon-stem-lex := v4-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v4-shon-stem-lex  := v4-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v4-minusshon-stem-lex  := v4-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v4-c-stem-lex := v4-nohon-stem-lex & [STEMTYPE c-stem].
v4-c2-stem-lex := v4-nohon-stem-lex & [STEMTYPE c2-stem].
v4-v-stem-lex := v4-nohon-stem-lex & [STEMTYPE v-stem].

v4-c-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE c-stem].
v4-c2-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE c2-stem].
v4-v-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE v-stem].

v4-c-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE c-stem].
v4-c2-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE c2-stem].
v4-v-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE v-stem].



v6-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL ga-to-ni_transitive1 &
                         [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
			  SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
	 LKEYS.KEYREL [ARG1 #sbjind,
			   ARG2 #objind],
         NON-LOCAL.QUE <! !>]].


v6-nohon-stem-lex := v6-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v6-shon-stem-lex  := v6-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v6-minusshon-stem-lex  := v6-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v6-c-stem-lex := v6-nohon-stem-lex & [STEMTYPE c-stem].
v6-c2-stem-lex := v6-nohon-stem-lex & [STEMTYPE c2-stem].
v6-v-stem-lex := v6-nohon-stem-lex & [STEMTYPE v-stem].

v6-c-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE c-stem].
v6-c2-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE c2-stem].
v6-v-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE v-stem].

v6-c-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE c-stem].
v6-c2-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE c2-stem].
v6-v-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE v-stem].


;v8: sbj-narg_transitive

v8-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LKEYS.KEYREL [ARG1 #sbjind,
                           ARG2 #objind],
	 LOCAL [CAT [HEAD.COP -,
                     VAL sbj-narg_transitive &
                              [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
			       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
         NON-LOCAL [ROBUST +]]].


v8-nohon-stem-lex := v8-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v8-shon-stem-lex  := v8-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                                         [HONORED #2,
                                                                          BEARER #3,
                                                                          POLARITY +] !>]],
                              NON-LOCAL.QUE <! !>]].

v8-minusshon-stem-lex  := v8-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]],
                              NON-LOCAL.QUE <! !>]].

v8-c-stem-lex := v8-nohon-stem-lex & [STEMTYPE c-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-c2-stem-lex := v8-nohon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-v-stem-lex := v8-nohon-stem-lex & [STEMTYPE v-stem,SYNSEM.NON-LOCAL.QUE <! !>].

v8-c-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE c-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-c2-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-v-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE v-stem].

;(MS 2005-11-11) getting rid of skip files.

v8-c-minusshon-stem-lex := v8-minusshon-stem-lex & 
			   [STEMTYPE c-stem,
			    SYNSEM [NON-LOCAL.QUE <! !>,
				    LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VN -]].

v8-c2-minusshon-stem-lex := v8-minusshon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-v-minusshon-stem-lex := v8-minusshon-stem-lex & [STEMTYPE v-stem,SYNSEM.NON-LOCAL.QUE <! !>].

v8-c-stem-wh-lex  := v8-nohon-stem-lex & [STEMTYPE c-stem,
                                          SYNSEM [LOCAL.CONT.HOOK.LTOP #top,
                                                  NON-LOCAL.QUE <! #top !>]].

; (SF 2003) introduces v9-stem-lex
; (MS 2003-11-19) but this seems not to be in use. 

;v9-stem-lex := v-sbj-comps-stem-lex &
;               [SYNSEM [LOCAL [CAT [HEAD.COP -,
;				    VAL ni-ga_transitive &
;                                      [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
;				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
;			       KEYS.KEY [ARG1 #sbjind,
;					 ARG2 #objind],
;                              CONT [HOOK.XARG #sbjind]],
;                        NON-LOCAL.QUE <! !>]].
;
;v9-nohon-stem-lex := v9-stem-lex &
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;v9-shon-stem-lex  := v9-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;							       CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor-rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY +] !>]]].
;
;v9-minusshon-stem-lex  := v9-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor-rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY -] !>]]].
;
;
;v9-c2-stem-lex := v9-nohon-stem-lex & [STEMTYPE c2-stem].
;v9-c-stem-lex := v9-nohon-stem-lex & [STEMTYPE c-stem].
;v9-v-stem-lex := v9-nohon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-stem-lex := v9-nohon-stem-lex & [STEMTYPE infinitive-stem].
;
;v9-c2-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE c2-stem].
;v9-c-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE c-stem].
;v9-v-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE infinitive-stem].
;
;v9-c2-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE c2-stem].
;v9-c-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE c-stem].
;v9-v-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE infinitive-stem].




mental-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [ LKEYS.KEYREL [ARG1 #sbjind,
					  ARG2 #objind],
			 LOCAL [CAT [HEAD.COP -,
                                   VAL mental_state_transitive &
                                        [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
					 SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			       CONT [HOOK.XARG #sbjind]],
                        NON-LOCAL.QUE <! !>]].

mental-nohon-stem-lex := mental-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

mental-shon-stem-lex  := mental-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2 ]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

mental-minusshon-stem-lex  := mental-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


mental-c-stem-lex := mental-nohon-stem-lex & [STEMTYPE c-stem].
mental-c2-stem-lex := mental-nohon-stem-lex  & [STEMTYPE c2-stem].
mental-v-stem-lex := mental-nohon-stem-lex & [STEMTYPE v-stem].

mental-c-shon-stem-lex := mental-shon-stem-lex & [STEMTYPE c-stem].
mental-c2-shon-stem-lex := mental-shon-stem-lex  & [STEMTYPE c2-stem].
mental-v-shon-stem-lex := mental-shon-stem-lex & [STEMTYPE v-stem].

mental-c-minusshon-stem-lex := mental-minusshon-stem-lex & [STEMTYPE c-stem].
mental-c2-minusshon-stem-lex := mental-minusshon-stem-lex  & [STEMTYPE c2-stem].
mental-v-minusshon-stem-lex := mental-minusshon-stem-lex & [STEMTYPE v-stem].

to_intrans-stem-lex := v-nonop-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL to_intransitive-opt &
                         [COMPS.FIRST #comp & [LOCAL.CONT.HOOK [LTOP #arghndl,
								XARG #xarg]]]],
               CONT [HOOK.XARG #xarg],
               CTXT.BACKGROUND <! !>,
		ARG-S < #comp >],
	 LKEYS.KEYREL.ARG1 #arghndl,
         NON-LOCAL.QUE <! !>]].




to_intrans-c-stem-lex := to_intrans-stem-lex & [STEMTYPE c-stem].
to_intrans-c2-stem-lex := to_intrans-stem-lex & [STEMTYPE c2-stem].
to_intrans-v-stem-lex := to_intrans-stem-lex & [STEMTYPE v-stem].

to_intrans-c-stem-normorph-lex := to_intrans-c-stem-lex  &
			  [RMORPH-BIND-TYPE nomorphbind].


cop-id-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD cop-id-stem_head &
			  [H-TENSE #tense],
                    VAL cop-id_transitive &
                         [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind,
			  SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind]],
		CONT verb-sem-type &
                   [HOOK [LTOP #hand,
			  INDEX  #ind &
			       [E [TENSE #tense]],
			  XARG #sbjind],
                    RELS.LIST.FIRST [LBL  #hand]],
		CTXT.BACKGROUND <! !>],
	 LKEYS.KEYREL equal-relation &
		    [PRED 'cop_id_rel,
                            LBL #hand,
                            ARG1 #sbjind,
                            ARG2 #objind,
                            ARG0 #ind]]].

cop-id-noquest-stem-lex := cop-id-stem-lex &
			    [ SYNSEM.NON-LOCAL.QUE <! !>].

cop-id-noquest-c2stem-lex := cop-id-noquest-stem-lex &
			     [STEMTYPE c2-stem].

cop-id-ordinary-stem-lex := cop-id-noquest-stem-lex &
			    [ SYNSEM.LOCAL.CAT.HEAD.MOD null].

cop-id-ordinary-dastem-lex := cop-id-ordinary-stem-lex &
			      [STEMTYPE da-stem].

cop-id-ordinary-desustem-lex := cop-id-ordinary-stem-lex &
			      [STEMTYPE desu-stem].


cop-id-conditional-stem-lex:= cop-id-ordinary-stem-lex &
			      [ SYNSEM.LOCAL.CAT.HEAD.MODUS conditional,
				STEMTYPE da-stem].

cop-id-ordinary-daiquest-stem-lex := cop-id-ordinary-desustem-lex &
				     [SYNSEM.LOCAL [CAT [HEAD [MOD null,
							       J-SPEC null,
							       MARK null,
							       FORMAL.AHON -],
							 VAL.COMPS.FIRST [NON-LOCAL.QUE <! handle !>]]]].

cop-id-quest-stem-lex := cop-id-stem-lex &
			 [SYNSEM [LOCAL [CAT [HEAD [MODUS indicative,
						    MOD null,
						   J-SPEC null,
						   SMOD quest,
						   MARK null,
						   FORMAL.AHON -],
					      VAL.COMPS.FIRST.LOCAL.CAT.HEAD ordinary_noun_head],
					 CONT.HOOK.LTOP #h],
				  NON-LOCAL.QUE <! #h !>],
			  STEMTYPE desu-stem].

cop-id-quest-stem-noquestincomp-lex := cop-id-quest-stem-lex &
				 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.QUE <! !>].

cop-id-quest-stem-masc-lex := cop-id-quest-stem-lex &
			      [SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN masc].

cop-id-quest-stem-fem-lex := cop-id-quest-stem-lex &
			      [SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN fem].

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

cop-id-neg-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
			  [MODUS negative],
                    VAL cop-id_transitive & [COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #objind],
					     SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind]]],
		CONT [HOOK [LTOP #neg-hand,
			   XARG #sbjind],
                     RELS <! neg-relation & #key & [LBL #neg-hand,ARG1 #arg, PRED 'neg_rel],
                              equal-relation & 
                                         [PRED 'cop_id_rel,
                                          LBL #cop-hand,
                                          ARG1 #sbjind,
                                          ARG2 #objind]!>,
                    HCONS <! qeq & [HARG #arg, LARG #cop-hand] !>],
               CTXT.BACKGROUND <! !>,
		ARG-S < #sbj . #comps >],
	 LKEYS.KEYREL #key,
         NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].


; (ERB 2002-01-28) To reduce ambiguity, disallow conjoined Ss as
; complement of copula, by requiring NUCL not_fin_conj.

cop-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
                          COP +,
                          H-TENSE #tense,
                          VN -,
                          AUX aux_minus,
                          LIGHT -,
                          ADJ -],
                    VAL cop-stem_transitive & [COMPS #comps & [FIRST [LOCAL [CONT.HOOK #hook,
									    CAT.HEAD.H-TENSE #tense,
									    NUCL not_fin_conj]]]]],
		CONT [HOOK #hook & [LTOP #hand],
		      RELS <! !>,
		      HCONS <! !>],
		CTXT.BACKGROUND <! !>,
		ARG-S #comps],
	 LKEYS.KEYREL.LBL #hand,
	 NON-LOCAL.QUE <! !>]].

; (ERB 2001-11-07) Types added strictly for ranking purposes.
; I want to be able to prefer the N/NO + cop entries, without having
; to list them all in japanese.set.  n-cop-stem-lex is the type for these
; guys.  reg-cop-stem-lex is the type for the other entries of the copula
; that (a) are not inflecting and (b) make no semantic contribution.

n-cop-stem-lex := cop-stem-lex.
reg-cop-stem-lex := cop-stem-lex & [SYNSEM.LKEYS.KEYREL arg1-ev-relation].

reg-cop-stem-desustem-lex := reg-cop-stem-lex &
			     [STEMTYPE desu-stem].

reg-cop-stem-dastem-lex := reg-cop-stem-lex &
			     [STEMTYPE da-stem].

reg-cop-stem-c2stem-lex := reg-cop-stem-lex &
			     [STEMTYPE c2-stem].

 
reg-cop-stem-indicative-lex := reg-cop-stem-lex &
			       [SYNSEM.LOCAL.CAT.HEAD.MODUS indicative].

reg-cop-stem-nomod-lex := reg-cop-stem-lex & 
			  [SYNSEM.LOCAL.CAT.HEAD.MOD null].

reg-cop-stem-indicative-desustem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-desustem-lex.

reg-cop-stem-indicative-dastem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-dastem-lex.

reg-cop-stem-indicative-c2stem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-c2stem-lex.

reg-cop-stem-indicative-dastem-nomod-lex := reg-cop-stem-indicative-dastem-lex & reg-cop-stem-nomod-lex.


reg-cop-stem-indicative-dastem-nmod-lex := reg-cop-stem-indicative-dastem-lex & 
					   [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL [CAT.HEAD noun_head,
										CONT.HOOK.INDEX #ind]] >,
						    LKEYS.KEYREL.ARG1 #ind]].
reg-cop-stem-fem-lex := reg-cop-stem-lex &
			[SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN fem,
			 STEMTYPE desu-stem].


reg-cop-stem-nomod-fem-lex := reg-cop-stem-nomod-lex & reg-cop-stem-fem-lex.

reg-cop-stem-nomod-desustem-lex := reg-cop-stem-nomod-lex & reg-cop-stem-desustem-lex.

; (ERB 2001-10-25) Using type neg_rel instead of PRED 'neg_rel.
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

cop-neg-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
                          COP +,
                          H-TENSE #tense,
                          VN -,
                          AUX aux_minus,
                          LIGHT -,
                          MODUS negative,
                          ADJ +],
		     VAL cop-stem_transitive & 
			  [COMPS #comps & [FIRST [LOCAL [CONT.HOOK [INDEX #ind,
								     LTOP #objhd],
							 CAT.HEAD.H-TENSE #tense]]]]],
		CONT [HOOK [LTOP #hand,
			    INDEX #ind],
                     RELS <! #key & neg-relation & [LBL #hand,ARG1 #arg, PRED 'neg_rel] !>,
                    HCONS <! qeq & [HARG #arg, LARG #objhd] !>],
               CTXT.BACKGROUND <! !>,
		ARG-S #comps],
	 LKEYS.KEYREL #key,
         NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].

; (MS 2003-06-23) ではない
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

cop-neg-lex := nonaux-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
			  J-POSTHEAD left,
                          MARK null,
                          SMOD unmarked,
			  MODUS negative,
                          COP +,
                          H-TENSE #tense],
                    VAL cop_transitive & [COMPS #comps & [FIRST [LOCAL [CONT [HOOK #hook & [INDEX #ind,
											    LTOP #objhd]],
								       CAT.HEAD.H-TENSE #tense,
								       NUCL not_fin_conj]]]]],
	       
	       CONT [HOOK #hook & [LTOP #hand,
				   INDEX #ind],
		     RELS <! #key & neg-relation & [ARG1 #arg, PRED 'neg_rel]  !>,
		     HCONS <! qeq & [HARG #arg, LARG #objhd] !>],
	       CTXT.BACKGROUND <! !>,
	       ARG-S #comps,
	       BAR +],
	 LKEYS.KEYREL #key & [LBL #hand]],
 INFLECTED +,
 J-NEEDS-AFFIX -,
 STEMTYPE adj-stem].


; (ERB 2001-12-20) This wasn't saying enough about it's MOD-IND
; and MOD-HAND.

; (ERB 2002-01-14) SMOD unmarked to constrain nonprop GA.

; (ERB 2002-01-28) To reduce ambiguity, disallow conjoined Ss as
; complement of copula, by requiring NUCL not_fin_conj.  (This isn't
; usually an issue because of the constraint on MAIN-PRD, but it
; seems to be coming up for DEKIRU at least.)

; (MS 2003-12-19) Matrix 0.6

; (MS 2004-08-25) I now call them cop-light-lex.
; (MS 2004-12-22) no MOD-IND/MOD-HAND

; (MS 2005-06-20) These should take their FORMAL information from their complements: yoroshii deshou.


cop-light-lex := nonaux-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
			   MARK null,
			   SMOD unmarked,
			   COP +,
			   H-TENSE #tense,
			   FORMAL #form],
                    VAL  cop_transitive & [COMPS #comps & [FIRST [LOCAL [CONT [HOOK #hook],
									 CAT.HEAD [H-TENSE #tense,
										   FORMAL #form],
									 NUCL not_fin_conj]]]]],
	       
	       CONT [HOOK #hook,
		     RELS <! !> ,
		     HCONS <! !>],
	       CTXT.BACKGROUND <! !>,
	       ARG-S #comps,
	       BAR +]],
 INFLECTED +,
 J-NEEDS-AFFIX -].



; (ERB 2001-11-07) Types added strictly for ranking purposes.
; I want to be able to prefer the N/NO + cop entries, without having
; to list them all in japanese.set.  n-cop-lex is the type for these
; guys.  reg-cop-lex is the type for the other entries of the copula
; that (a) are not inflecting and (b) make no semantic contribution.

; (ERB 2002-02-12) n-cop-lex are (so far) all [C-MOD null], so put
; that constraint here.  (I think it used to be on cop-lex, but
; that doesn't work for deshitara.)  Also, all are MOD none and say
; the same thing about H-TENSE.

n-cop-lex := cop-light-lex &
[SYNSEM.LOCAL.CAT [HEAD [H-TENSE #tense,
                         MODUS #mood,
                         MOD null,
                         C-MOD null],
                   VAL.COMPS.FIRST.LOCAL.CAT.HEAD [H-TENSE #tense,
                                                  MODUS #mood]]].


reg-cop-lex := cop-light-lex.


reg-cop-lex-indicative := reg-cop-lex &
			  [SYNSEM.LOCAL.CAT.HEAD [MODUS indicative,
						   MOD null,
						  C-MOD null]].


reg-cop-lex-subjunctive := reg-cop-lex &
			  [SYNSEM.LOCAL [CONT.HOOK.INDEX.E.MOOD subjunctive,
					 CAT.HEAD [MOD null,
						   C-MOD null]]].

;でしょう
reg-cop-lex-subjunctive-polite := reg-cop-lex-subjunctive &
				  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

;だろう
reg-cop-lex-subjunctive-plain := reg-cop-lex-subjunctive &
				  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].



reg-cop-lex-indicative-nonfinite := reg-cop-lex &
				 [SYNSEM.LOCAL.CAT.HEAD [MODUS indicative,
							 MOD null,
							 FIN -,
							 MAIN-PRD -,
							 J-SPEC null,
							 VN -,
							 C-MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD +],
									 BAR +]]>]].

reg-cop-lex-indicative-finite := reg-cop-lex-indicative &
				 [SYNSEM.LOCAL.CAT.HEAD.FIN +].


reg-cop-lex-indicative-plain := reg-cop-lex-indicative &
				[SYNSEM.LOCAL.CAT [HEAD.FORMAL.AHON -,
						   VAL.COMPS.FIRST [NON-LOCAL.QUE <! handle !>,
								    LOCAL.CAT.HEAD adv_head]]].


reg-cop-lex-conditional := reg-cop-lex &
			   [SYNSEM.LOCAL [CAT.HEAD [MAIN-PRD -,
						    MODUS conditional,
						    C-MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD +],
								    BAR +]] >,
						    J-SPEC null,
						    FIN -,
						    H-TENSE present,
						    VN -,
						    MOD null]]].



; (MS 2004-11-17) Not all auxiliaries have a key relation. That's why I took this
; out here.

aux-top-stem-lex := verb-stem-lex & lexical_sign-word &
              [SYNSEM [LOCAL [CAT [HEAD aux-stem_head &
                                        [H-TENSE #tense]],
                              CONT [HOOK.INDEX [E [TENSE #tense]]]],
                       NON-LOCAL.QUE <! !>,
		       MODIFIED.PERIPH +]].


; (FCB 2005-06-27) Added ARG0 to message  FIXME: should refactor with 3 others
; (MS 2005-11-09) These all unify ARG1 with EMPEE.

aux-obj-id-stem-lex := aux-top-stem-lex &
                  [SYNSEM [LOCAL [CAT [VAL aux_transitive &
                                            [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
					     COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #obj2ind],
					     SPR.FIRST.LOCAL.CONT.HOOK [LTOP #ohand, INDEX #oindex]],
				       HEAD.AUX complex_aux],
                                 CONT [RELS diff-list & <! #key,
							 message &
							 [PRED proposition_m_rel,
							  LBL #chand,
							  ARG0 #oindex,
							  MARG #soa] !>,
                                       HOOK.INDEX #event,
                                       HCONS <! qeq & [LARG #ohand,
                                                        HARG #soa] !> ],
				  CTXT.EMPATHY.EMPEE #sbjind,
				  ARG-S < #sbj . #comps >],
			   LKEYS.KEYREL #key & arg123-relation &
                                             [ARG1 #sbjind,
                                              ARG2 #obj2ind,
                                              ARG3 #chand,
                                              ARG0 #event]]].
                                                  

aux-obj-id-v-stem-lex := aux-obj-id-stem-lex & [STEMTYPE v-stem].
aux-obj-id-c-stem-lex := aux-obj-id-stem-lex & [STEMTYPE c-stem].
aux-obj-id-c2-stem-lex := aux-obj-id-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-kurusuru-stem-lex := aux-obj-id-stem-lex & [STEMTYPE kurusuru-stem].


aux-obj-id-minus_shon-stem-lex := aux-obj-id-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                              VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                      CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

aux-obj-id-minus_shon-v-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE v-stem].
aux-obj-id-minus_shon-c-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE c-stem].
aux-obj-id-minus_shon-c2-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-minus_shon-kurusuru-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

aux-obj-id-shon-stem-lex := aux-obj-id-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2 ]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

aux-obj-id-shon-v-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE v-stem].
aux-obj-id-shon-c-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE c-stem].
aux-obj-id-shon-c2-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-shon-kurusuru-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-12-28) For VN + itadaku, etc.
; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message  FIXME: should refactor with 3 others
light-obj-id-stem-lex := aux-top-stem-lex &
			 [SYNSEM [LOCAL [CAT.VAL light-aux_transitive &
						 [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
						  COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #obj2ind],
						  SPR.FIRST.LOCAL.CONT.HOOK  [LTOP #ohand, INDEX #oindex]],
					 CONT [RELS diff-list & <! #key,
								 message &
								 [PRED proposition_m_rel,
								  LBL #chand,
								  ARG0 #oindex,
								  MARG #soa] !>,
					       HOOK.INDEX #event,
					       HCONS <! qeq & [LARG #ohand,
							       HARG #soa] !> ],
					 ARG-S < #sbj . #comps >],
				  LKEYS.KEYREL #key & arg123-relation &
					[ARG1 #sbjind,
					 ARG2 #obj2ind,
					 ARG3 #chand,
					 ARG0 #event]]].
                                                  

light-obj-id-v-stem-lex := light-obj-id-stem-lex & [STEMTYPE v-stem].
light-obj-id-c-stem-lex := light-obj-id-stem-lex & [STEMTYPE c-stem].
light-obj-id-c2-stem-lex := light-obj-id-stem-lex & [STEMTYPE c2-stem].
light-obj-id-kurusuru-stem-lex := light-obj-id-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-arg1emp-stem-lex := light-obj-id-stem-lex &
				 [SYNSEM [LKEYS.KEYREL [ARG1 #ind],
					  LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-obj-id-arg1emp-v-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE v-stem].
light-obj-id-arg1emp-c-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE c-stem].
light-obj-id-arg1emp-c2-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-obj-id-arg1emp-kurusuru-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-minus_shon-stem-lex := light-obj-id-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

light-obj-id-minus_shon-v-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE v-stem].
light-obj-id-minus_shon-c-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE c-stem].
light-obj-id-minus_shon-c2-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE c2-stem].
light-obj-id-minus_shon-kurusuru-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-minus_shon-arg1emp-stem-lex := light-obj-id-minus_shon-stem-lex &
					 [SYNSEM [LKEYS.KEYREL [ARG1 #ind],
						   LOCAL.CTXT.EMPATHY.EMPEE #ind]].   

light-obj-id-minus_shon-arg1emp-v-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE v-stem].
light-obj-id-minus_shon-arg1emp-c-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-obj-id-minus_shon-arg1emp-c2-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-obj-id-minus_shon-arg1emp-kurusuru-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].




light-obj-id-shon-stem-lex := light-obj-id-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

light-obj-id-shon-v-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE v-stem].
light-obj-id-shon-c-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE c-stem].
light-obj-id-shon-c2-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE c2-stem].
light-obj-id-shon-kurusuru-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE kurusuru-stem].



; (MS 2003-12-19) Matrix 0.6
; (MS 2004-11-17) Some aspect auxiliaries add a relation (見る, みせる)
; (MS 2005-11-08) The aspect is modal in all cases.

 complex-aspect-stem-lex  := aux-top-stem-lex &
[SYNSEM [LOCAL [CAT [VAL aspect_transitive &
                          [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
			   SPR.FIRST.LOCAL [CAT.VAL.SUBJ.FIRST #sbj,
					    CONT.HOOK [LTOP #ohand, INDEX #oindex]]],
		     HEAD.AUX aspect_aux],
		CONT [RELS diff-list & <! #key,
				       message &
				       [PRED proposition_m_rel,
					LBL #chand,
					ARG0 #oindex,
					MARG #soa] !>,
                     HOOK.INDEX #event & [E.ASPECT modal],
                     HCONS <! qeq & [LARG #ohand,
                                      HARG #soa] !> ],
	       ARG-S < #sbj >],
	 LKEYS.KEYREL #key & arg12-relation &
                           [ARG1 #sbjind,
                            ARG2 #chand,
                            ARG0 #event]]].


complex-aspect-v-stem-lex := complex-aspect-stem-lex & [STEMTYPE v-stem].
complex-aspect-c-stem-lex := complex-aspect-stem-lex & [STEMTYPE c-stem].
complex-aspect-c2-stem-lex := complex-aspect-stem-lex & [STEMTYPE c2-stem].
complex-aspect-kurusuru-stem-lex := complex-aspect-stem-lex & [STEMTYPE kurusuru-stem].

complex-aspect-minus_shon-stem-lex := complex-aspect-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
							       CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

complex-aspect-minus_shon-v-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE v-stem].
complex-aspect-minus_shon-c-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE c-stem].
complex-aspect-minus_shon-c2-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE c2-stem].
complex-aspect-minus_shon-kurusuru-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

complex-aspect-shon-stem-lex := complex-aspect-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

complex-aspect-shon-v-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE v-stem].
complex-aspect-shon-c-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE c-stem].
complex-aspect-shon-c2-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE c2-stem].
complex-aspect-shon-kurusuru-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE kurusuru-stem].


; (MS 2004-11-17) This one now links the first complement of the verb to the ARG1 of the complex.
; (MS 2005-11-08) These seem all to have perfective aspect.

aspect-stem-lex  := aux-top-stem-lex &
[SYNSEM [LOCAL [CAT [VAL aspect_transitive &
                          [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
			   SPR.FIRST.LOCAL [CAT.VAL sbj-obj-arg & [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind],
					    CONT.HOOK [INDEX #event,
						       LTOP #ltop,
						       XARG zpro_ref-ind]]],
		     HEAD.AUX aspect_aux],
		CONT [HOOK [INDEX #event & [E.ASPECT perfective],
			    LTOP #ltop],
		      RELS <! !>,
		      HCONS <! !> ],
	       ARG-S < #sbj >]]].


aspect-v-stem-lex := aspect-stem-lex & [STEMTYPE v-stem].
aspect-c-stem-lex := aspect-stem-lex & [STEMTYPE c-stem].
aspect-c2-stem-lex := aspect-stem-lex & [STEMTYPE c2-stem].
aspect-kurusuru-stem-lex := aspect-stem-lex & [STEMTYPE kurusuru-stem].

aspect-minus_shon-stem-lex := aspect-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
							       CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

aspect-minus_shon-v-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE v-stem].
aspect-minus_shon-c-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE c-stem].
aspect-minus_shon-c2-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE c2-stem].
aspect-minus_shon-kurusuru-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

aspect-shon-stem-lex := aspect-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

aspect-shon-v-stem-lex := aspect-shon-stem-lex & [STEMTYPE v-stem].
aspect-shon-c-stem-lex := aspect-shon-stem-lex & [STEMTYPE c-stem].
aspect-shon-c2-stem-lex := aspect-shon-stem-lex & [STEMTYPE c2-stem].
aspect-shon-kurusuru-stem-lex := aspect-shon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-11-12) I think the real solution for the aspect auxiliaries
; (shimau, iru, aru, and maybe some others) is to make them contribute no
; relation but rather provide information about E.ASPECT of their specifier.
; This type is an interim solution to make them raising verbs -- that is, they
; contribute one place (arg4only) relations.

; (ERB 2001-11-12) This is a first pass at making "pure" aspect auxiliaries.
; The current motivation is "iru", which Monique has just come across, and
; which just looks silly right now with "iru_rel".  The idea here is that
; the pure aspect auxiliaries don't contribute a relation of their own but
; rather stamp some info into the E.ASPECT of the verb.  For now, they'll have
; underspecified KEY values, but we might find that we want them to raise
; the KEY of their SPR.  They certainly raise the handle & event.

; (ERB 2001-11-12) This idea requires more changes that I thought, because
; the te forms are currently [ TENSE te ] which doesn't unify with 
; [ TENSE present ].   Try making te form (as opposed to other [ TENSE te ]
; things) [ TENSE tensed ].  This will probably overgenerate.

; (ERB 2001-11-12) Don't want this inheriting from aux-top-stem-lex, 
; because that type puts the key on the liszt.  Adding the rest of the
; constraints directly in here.  Not making this lexical_sign-word, for
; now.  (No real KEY, don't need a WLINK.)

; (MS 2004-11-09) E.TENSE should come from the aspect auxiliary, other things in INDEX
; from the content verb: 食べなくている

; (MS 2004-12-01) Why do we need INSTLOC here? Take it out.
; (MS 2005-01-11) The XARG should be identified with the verb, otherwise
; we get a reading where the aspect verb undergoes zero pronominalization,
; while the main verb doesn't (友達を三人待っています)
; (FCB 2005-05-06) added restriction: SPR.FIRST.LOCAL.CAT.HEAD v-end_head 
; to stop overgeneration (勉強 し いる)


pure-aspect-stem-lex := verb-stem-lex &
 [SYNSEM [ LOCAL [CAT [ HEAD aux-stem_head & 
			     [ H-TENSE #tense,
			       AUX aspect_aux],
			VAL pure-aspect_transitive &
			     [SUBJ.FIRST #sbj,
			      SPR.FIRST.LOCAL [ CAT.HEAD v-end_head,
						CONT.HOOK [ LTOP #ohand,
							    INDEX #event & [SORT #sort,
									    E.MOOD #mood],
							    XARG #xarg]]]],
		  CONT [RELS <! !>,
			HOOK [INDEX [ E [TENSE #tense,
					MOOD #mood],
				     SORT #sort],
			     XARG #xarg,
			     LTOP #ohand],
                       HCONS <! !> ],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL [PRED 'aspect,
			ARG0 #event],
	  MODIFIED.PERIPH +,
	  NON-LOCAL.QUE <! !>]].

pure-aspect-perfprog-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT perfect_progressive ].

pure-aspect-inceptive-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT inceptive ].

pure-aspect-progressive-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT progressive ].

pure-aspect-terminative-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT terminative ].

pure-aspect-prospective-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT prospective ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-perfprog-v-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-c-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-c2-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE c2-stem].
pure-aspect-perfprog-kurusuru-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-perfprog-minus_shon-stem-lex := pure-aspect-perfprog-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-perfprog-minus_shon-v-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-minus_shon-c-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-minus_shon-c2-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-perfprog-minus_shon-kurusuru-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-perfprog-shon-stem-lex := pure-aspect-perfprog-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-perfprog-shon-v-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-shon-c-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-shon-c2-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-perfprog-shon-kurusuru-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-inceptive-v-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE v-stem].
pure-aspect-inceptive-c-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE c-stem].
pure-aspect-inceptive-c2-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-kurusuru-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-inceptive-minus_shon-stem-lex := pure-aspect-inceptive-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-inceptive-minus_shon-v-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-inceptive-minus_shon-c-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-inceptive-minus_shon-c2-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-minus_shon-kurusuru-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-inceptive-shon-stem-lex := pure-aspect-inceptive-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-inceptive-shon-v-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-inceptive-shon-c-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-inceptive-shon-c2-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-shon-kurusuru-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-progressive-v-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE v-stem].
pure-aspect-progressive-c-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE c-stem].
pure-aspect-progressive-c2-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-kurusuru-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-progressive-minus_shon-stem-lex := pure-aspect-progressive-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-progressive-minus_shon-v-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-progressive-minus_shon-c-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-progressive-minus_shon-c2-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-minus_shon-kurusuru-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-progressive-shon-stem-lex := pure-aspect-progressive-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-progressive-shon-v-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-progressive-shon-c-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-progressive-shon-c2-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-shon-kurusuru-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE kurusuru-stem].
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-terminative-v-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE v-stem].
pure-aspect-terminative-c-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-c2-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-kurusuru-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-terminative-minus_shon-stem-lex := pure-aspect-terminative-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-terminative-minus_shon-v-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-terminative-minus_shon-c-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-minus_shon-c2-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-minus_shon-kurusuru-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-terminative-shon-stem-lex := pure-aspect-terminative-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-terminative-shon-v-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-terminative-shon-c-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-shon-c2-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-shon-kurusuru-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-prospective-v-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE v-stem].
pure-aspect-prospective-c-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE c-stem].
pure-aspect-prospective-c2-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE c2-stem].
pure-aspect-prospective-kurusuru-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-prospective-minus_shon-stem-lex := pure-aspect-prospective-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-prospective-minus_shon-v-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-prospective-minus_shon-c-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-prospective-minus_shon-c2-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-prospective-minus_shon-kurusuru-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-prospective-shon-stem-lex := pure-aspect-prospective-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-prospective-shon-v-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-prospective-shon-c-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-prospective-shon-c2-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-prospective-shon-kurusuru-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message  FIXME: should refactor with 3 others
perspective-stem-lex  := aux-top-stem-lex &
[SYNSEM [LOCAL [CAT [VAL perspective_transitive & [COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #obj2ind],
						 SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
						 SPR.FIRST.LOCAL.CONT.HOOK [LTOP #ohand, INDEX #oindex]],
		     HEAD.AUX complex_aux],
               CONT [RELS diff-list & <! #key,
				       message &
				       [PRED proposition_m_rel,
					LBL #chand,
					ARG0 #oindex,
					MARG #soa] !>,
                     HOOK.INDEX #event,
                     HCONS <! qeq & [LARG #ohand,
                                      HARG #soa] !> ],
	       ARG-S < #sbj . #comps >],
	 LKEYS.KEYREL #key & arg123-relation &
                           [ARG1 #sbjind,
                            ARG2 #obj2ind,
                            ARG3 #chand,
                            ARG0 #event]]].

perspective-arg1emp-stem-lex := perspective-stem-lex &
				[SYNSEM [LKEYS.KEYREL.ARG1 #ind,
					 LOCAL.CTXT.EMPATHY.EMPEE #ind]].

perspective-arg2emp-stem-lex := perspective-stem-lex &
				[SYNSEM [LKEYS.KEYREL.ARG2 #ind,
					 LOCAL.CTXT.EMPATHY.EMPEE #ind]].


perspective-arg1emp-v-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-c-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-c2-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-kurusuru-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].



perspective-arg1emp-minus_shon-stem-lex := perspective-arg1emp-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

perspective-arg1emp-minus_shon-v-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-minus_shon-c-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-minus_shon-c2-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-minus_shon-kurusuru-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


perspective-arg1emp-shon-stem-lex := perspective-arg1emp-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

perspective-arg1emp-shon-v-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-shon-c-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-shon-c2-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-shon-kurusuru-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE kurusuru-stem].

perspective-arg2emp-v-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-c-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-c2-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-kurusuru-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].



perspective-arg2emp-minus_shon-stem-lex := perspective-arg2emp-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

perspective-arg2emp-minus_shon-v-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-minus_shon-c-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-minus_shon-c2-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-minus_shon-kurusuru-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


perspective-arg2emp-shon-stem-lex := perspective-arg2emp-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

perspective-arg2emp-shon-v-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-shon-c-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-shon-c2-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-shon-kurusuru-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE kurusuru-stem].


; (ERB 2001-12-28) For VN + itadaku, etc.
; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message  FIXME: should refactor with 3 others
light-perspective-stem-lex  := aux-top-stem-lex &
[SYNSEM [LOCAL [CAT.VAL light-perspective_transitive & [SUBJ < #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind] >,
						       COMPS #comps & < [LOCAL.CONT.HOOK.INDEX #obj2ind] >,
						       SPR < [LOCAL.CONT.HOOK [LTOP #ohand, INDEX #oindex]] >],
               CONT [RELS diff-list & <! #key,
				       message &
				       [PRED proposition_m_rel,
					LBL #chand,
					ARG0 #oindex,
					MARG #soa] !>,
                     HOOK.INDEX #event,
                     HCONS <! qeq & [LARG #ohand,
                                      HARG #soa] !> ],
		ARG-S < #sbj . #comps >],
	 LKEYS.KEYREL #key & arg123-relation &
	       [ARG1 #sbjind,
		ARG2 #obj2ind,
		ARG3 #chand,
		ARG0 #event]]].

; (MS 2003-12-16) For more types in the lexicon

light-perspective-arg2emp-stem-lex := light-perspective-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG2 #obj2ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #obj2ind]].

light-perspective-arg1emp-stem-lex := light-perspective-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].


light-perspective-v-stem-lex := light-perspective-stem-lex & [STEMTYPE v-stem].
light-perspective-c-stem-lex := light-perspective-stem-lex & [STEMTYPE c-stem].
light-perspective-c2-stem-lex := light-perspective-stem-lex & [STEMTYPE c2-stem].
light-perspective-kurusuru-stem-lex := light-perspective-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-arg2emp-v-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE v-stem].
light-perspective-arg2emp-c-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE c-stem].
light-perspective-arg2emp-c2-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-arg2emp-kurusuru-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].
light-perspective-arg1emp-v-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-arg1emp-c-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-arg1emp-c2-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-arg1emp-kurusuru-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-minus_shon-stem-lex := light-perspective-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

light-perspective-minus_shon-arg1emp-stem-lex := light-perspective-minus_shon-stem-lex &
						 [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
							  LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-perspective-minus_shon-v-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE v-stem].
light-perspective-minus_shon-c-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE c-stem].
light-perspective-minus_shon-c2-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE c2-stem].
light-perspective-minus_shon-kurusuru-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-minus_shon-arg1emp-v-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-minus_shon-arg1emp-c-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-minus_shon-arg1emp-c2-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-minus_shon-arg1emp-kurusuru-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


light-perspective-shon-stem-lex := light-perspective-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

; (MS 2003-12-16) For more types in the lexicon

light-perspective-shon-arg2emp-stem-lex := light-perspective-shon-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG2 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-perspective-shon-arg1emp-stem-lex := light-perspective-shon-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].



light-perspective-shon-v-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-c-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE c-stem].
light-perspective-shon-c2-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-kurusuru-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-shon-arg2emp-v-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-arg2emp-c-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE c-stem].
light-perspective-shon-arg2emp-c2-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-arg2emp-kurusuru-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].
light-perspective-shon-arg1emp-v-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-arg1emp-c-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-shon-arg1emp-c2-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-arg1emp-kurusuru-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


base-adj-stem-lex := verb-stem-lex-base &
[SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
                          [H-TENSE #tense]],
                CONT [HOOK.INDEX event &
                            [E [TENSE #tense]]]],
         NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].

; (ERB 2001-11-12) When I removed lexical_sign-word from v-lex to
; preserve no+dop types from the [WLINK nelist] constraint, i adjectives
; got left with no labels.  Trying this type as a place to put them
; back in.  (one type up --- base-adj-stem-lex --- would also include
; nai-adj).
; (MS 2005-05-11) This should combine HEAD.KEYS.KEYREL with PRED, shouldn't it?
; Otherwise we get garu-sbj-change-rule for i-adj.

adj-stem-lex := base-adj-stem-lex & lexical_sign-word &
[SYNSEM [LOCAL [CONT simple-verb-sem-type &
		     [RELS <! #key !>,
		      HCONS <! !>,
		      HOOK [INDEX #ind,
			 LTOP #top]],
		CAT.HEAD.KEYS.KEY #keyrel],
	 LKEYS.KEYREL #key & [ ARG0 #ind,
			       PRED #keyrel,
				 LBL #top]],
 STEMTYPE adj-stem].

; (ERB 2001-11-12) Replacing PRED 'aru with exist_rel.
; (MS 2001-11-19) Making the SUBJ optional. It has to be tested, whether this leads to spurious ambiguities.
; (ERB 2002-01-10) Trying to cut back on ambiguity in ではない sentences.
; Two different でs are modifying ない because it is MAIN-PRD bool.
; Try MAIN-PRD +.  ... That doesn't work because のです requires
; MAIN-PRD - on its OBJ.  But, I've required that the MOD.MAIN-PRD
; of pobj は and the MOD.MAIN-PRD of its object be the same, and this
; might do the trick since は only wants to modify MAIN-PRD + things.

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.
; (MS 2004-12-21) these are for nai that takes ga  and nai that 
; takes ga - n : 花子は問題がない、問題ない

base-i-adj-neg-stem-lex := base-adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [ MODUS negative ],
		     VAL [SUBJ.FIRST [OPT + ,
				       LOCAL [CAT.HEAD case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #inst]]]],
		CONT [HOOK [INDEX #event,
			    XARG #inst,
			   LTOP #top],
		      RELS <! neg-relation & #key &
			    [ARG1 #arghd, 
			     LBL #top],
			    [PRED 'exist,
			     LBL #aru_hd,
			     ARG0 #event,
			     ARG1 #inst]!>,
		      HCONS <! qeq & [HARG #arghd,
				      LARG #aru_hd] !>]],
	 LKEYS.KEYREL #key]].


i-adj-neg-stem-lex := base-i-adj-neg-stem-lex &
		      [SYNSEM.LOCAL.CAT.VAL sbj-arg].

i-adj-nocase-neg-stem-lex := base-i-adj-neg-stem-lex &
		      [SYNSEM.LOCAL [CAT.VAL sbj-obj-arg & 
					     [COMPS.FIRST [OPT - ,
							   LOCAL [CAT [HEAD ordinary_noun_head,
								       VAL saturated],
								  CONT.HOOK.INDEX #compsind]]],
				     CONT.RELS.LIST.REST.FIRST.ARG2 #compsind]].


i-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
                    VAL adj_sc &
                         [SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #inst]]],
		CONT.HOOK.XARG #inst],
	 LKEYS [KEYREL arg1-relation &
			 [ARG1 #inst]]]].

; (MS 2005-06-20) For honorific adjectives like yoroshii.

i-adj-hon-stem-lex := i-adj-stem-lex &
		      [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-11-09) To get rid of skip files.

i-adj-minusshon-stem-lex := i-adj-stem-lex &
		      [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON -].

eval-i-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL.CAT [HEAD.MODUS indicative,
                    VAL eval-adj_sc &
                         [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #inst]],
               LKEYS [KEYREL arg1-relation &
                         [ARG1 #inst]]]].

;for rashii, in e.g. 食べるらしい

eval-obl-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & [FIRST.LOCAL.CAT.HEAD verb_head]].

; for ii, in e.g. 食べていい

eval-opt-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS opt-1-arg & 
						       [FIRST.LOCAL.CAT.HEAD verb_head & [H-TENSE te, FIN -]]].

; (MS 2005-11-09) Subtype to get rid of skip files

eval-opt-i-adj-minusshon-stem-lex := eval-opt-i-adj-stem-lex &
				     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON - ].



;for rashii, in e.g. 静からしい

naarg-obl-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & [FIRST.LOCAL.CAT.HEAD na-adj_head]].


;;; (FCB 2004-06-25) new type for 子供らしい 子供っぽい


cop-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
		     VAL cop-id_transitive &
				[SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbj,
				 COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #nom]],
		CONT.HOOK.XARG #sbj],
	 LKEYS [KEYREL arg1-relation &
		       [ARG1 #sbj,
			ARG2 #nom]]]].

n-obl-i-adj-stem-lex := cop-adj-stem-lex &
   [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & 
			       [FIRST.LOCAL.CAT.HEAD noun_head]].




;generic types for CHASEN connection

; (ERB 2001-10-23) This type had an unbound HCONS value.  Adding
; that constraint.

generic-i-adj-lex := v-lex & lexical_sign-word & 
             [SYNSEM [LOCAL [CAT [HEAD i-adj_head &
                                      [H-TENSE #tense],
                                 VAL adj_sc &
				       [SUBJ.FIRST [LOCAL.CONT.HOOK [INDEX #inst,
								     LTOP #handle]]]],
                            CONT simple-verb-sem-type &
                                [HOOK [INDEX event & #ind & 
					     [E [TENSE #tense]],
				       LTOP #handle]],
                            BAR -],
		      LKEYS.KEYREL adj-relation &
                                       [ARG1 #inst,
					ARG0 #ind,
                                        LBL #handle],
                      NON-LOCAL [QUE <! !>]],
              INFLECTED +].



generic_adj_te_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE t-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.H-TENSE te] > ],
 J-NEEDS-AFFIX +].

generic_adj_past_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE t-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.H-TENSE past] > ],
 J-NEEDS-AFFIX +].

generic_adj_a_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE a-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head,
 J-NEEDS-AFFIX +].


; (ERB 2001-10-23) This type had an unbound HCONS value.  Adding
; that constraint.

; (ERB 2002-01-15) I don't see why this type should have adj_rel...
; assuming that's reserved for attributive adjectives and that the
; generic entry should be predicative.  Changing to arg1-relation.

generic_adj_i_infl-lex  :=  v-lex & lexical_sign-word &
[RMORPH-BIND-TYPE u-morph,
 SYNSEM [LOCAL [CAT [HEAD i-adj_head &
                         [H-TENSE #tense & present,
                          MOD < [LOCAL [CAT.HEAD noun_head,
                                      BAR +],
                               MODIFIED.PERIPH -] >,
                          MARK null,
                          J-SPEC.FIRST.LOCAL.CAT.HEAD noun_head,
                          FIN +,
                          FORMAL.AHON -],
                    VAL adj_sc &
                         [SUBJ.FIRST [LOCAL.CONT.HOOK [INDEX #inst,
						       LTOP #handle]]]],
                CONT simple-verb-sem-type &
                   [HOOK [INDEX event & #ind &
				[E [TENSE #tense]],
			  LTOP #handle],
                    HCONS <! !>]],
	 LKEYS.KEYREL arg1-relation &
                          [ARG0 #ind,
			   ARG1 #inst, 
                           LBL #handle],
         NON-LOCAL.QUE <! !>],
 J-NEEDS-AFFIX -].




generic_adj_kere_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE cond-morph,
 J-NEEDS-AFFIX +,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.MODUS conditional] > ]].


generic_adj_short_infl-lex  := generic-i-adj-lex &
[RMORPH-BIND-TYPE shortadj-morph,
 J-NEEDS-AFFIX -,
 SYNSEM.LOCAL [CAT.HEAD i-adj_head],
 INFLECTED +].



; (ERB 2001-09-19) I want the verbal nouns to all be [H-TENSE no_tense]
; so I can keep them from being the complement of nspec-no-3.  This
; means they can't share H-TENSE with the light verbs.  I'm going to
; try breaking that identity here.

; (MS 2001-09-20) There is a much easier solution to that: see the no-nspec-3 lexical entry.

; (ERB 2001-12-28) True light verbs raise content and therefore should
; have empty WLINKs.  So, this should be a subtype of lexical_sign and
; not lexical_sign-word.  Move that to appropriate subtypes.  (It already
; is a subtype of lexical_sign, via ancestors.)

; (ERB 2002-01-11) Changed supertype here from verb-stem-lex to
; verb-stem-lex-base because some subtypes don't want the identification
; of MOD-IND & INDEX and MOD-HAND & LTOP supplied by simple-verb-sem-type.
; ... added in verb-stem-lex-super to keep contrast with other subtypes
; of verb-stem-lex-base (in potential rule, and maybe some other
; inflectional rules) while not inheriting this constraint.

; (ERB 2002-01-11) quasi-light-verbs shouldn't identify INDEX and
; SPR.INDEX.  This constraint is already repeated on light-stem-lex,
; and we don't need it here.  Still presumably want the E.TENSE value
; to come from the SPR's INDEX, though.

; (MS 2004-12-14) The light verb needs to copy the VN's ARG-S, such
; that this can be accessed by, e.g., passive.

light-stem-base-lex := verb-stem-lex-super &
[SYNSEM [LOCAL [CAT [HEAD light-verb_head &
                          [H-TENSE #tense,
                           MODUS #mood],
                     VAL light_transitive & 
                          [SPR.FIRST.LOCAL [ CAT.HEAD.MODUS #mood,
					     CONT.HOOK.INDEX.E.TENSE #tense,
					     ARG-S #arg-s]]],
                CONT pred-sem-type & [HOOK.INDEX [E.TENSE #tense]],
		ARG-S #arg-s],
         NON-LOCAL.QUE <! !>,
	 MODIFIED.PERIPH +]].

; (ERB 2001-12-28) The passive suffix looks in the KEY to get the
; right value for the new SUBJ.  This means that unless light verbs share
; the KEY of their SPR, the SUBJ in a passive sentence won't get
; linked to any role of the verb.  Also, grab LTOP, not KEY.LBL.
; (Remember: Content raising words should have empty WLINKs.)

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND


light-stem-lex := light-stem-base-lex &
[ SYNSEM [LOCAL [CAT.VAL.SPR.FIRST [LOCAL.CONT simple-verb-sem-type &
                                              [HOOK #hook]],
                CONT [HOOK #hook,
                      RELS <! !>,
                      HCONS <! !>]]]].


; (ERB 2001-12-28) We don't use all of these types, since the
; space of light verbs isn't that big.  Commenting out the unused ones.


light-nohon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

light-nohon-kurusuru-stem-lex := light-nohon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-21) It is not right to say something about the subject of the spr. 
; it can be already bound by a zpro. taking that out (勉強になる)

light-shon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL [SPR.FIRST [LOCAL [CONT.HOOK [INDEX #3,
						     XARG #2]]]]],
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

light-shon-c-stem-lex := light-shon-stem-lex & [STEMTYPE c-stem].

; (MS 2005-06-20) nasaru.

light-shon-c2-stem-lex := light-shon-stem-lex & [STEMTYPE c2-stem].


; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-21) It is not right to say something about the subject of the spr. 
; it can be already bound by a zpro. taking that out (勉強いたす) and binding the
; honorification to XARG.

light-minus_shon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
               CONT.HOOK [INDEX #3,
			  XARG #2],
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
						    [HONORED #2,
						     BEARER #3,
						     POLARITY -] !>]]].

light-minus_shon-v-stem-lex := light-minus_shon-stem-lex & [STEMTYPE v-stem].
light-minus_shon-c-stem-lex := light-minus_shon-stem-lex & [STEMTYPE c-stem].

; (ERB 2001-08-30) Fixing dekiru so that it has some semantic effect 
; in combination with vns.  Giving it the same semantic effect of rareru.

; (ERB 2001-08-30) Want two subtypes of dekiru --- one that is ga_wo_trans
; and one that has a ga marked object and a suppressed subject (zpro).

; (MS 2001-09-14) Changed that again. There is only one type of dekiru 
; that undergoes the objchange rule.

; (ERB 2001-12-28) Replacing this with a slightly more general type
; that allows for all of the quasi-light-verbs.

; (ERB 2002-01-11) These guys should really pass up the MOD-IND and
; MOD-HAND of their SPRs, since that's what modifiers will attach to.
; (Most clearly true with ねがう, but probably also true with できる.)


; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-22) no MOD-IND/MOD-HAND

quasi-light-lex :=  light-stem-base-lex & lexical_sign-word &
[SYNSEM [LOCAL [CAT.VAL.SPR.FIRST [LOCAL.CONT [ HOOK.LTOP #ohand ]],
		CONT [RELS <! #key,
			    message &
			    [PRED proposition_m_rel,
			     LBL #chand,
			     MARG #soa] !>,
                     HOOK [INDEX #event,
			   LTOP #top],
                     HCONS <! qeq & [LARG #ohand,
                                      HARG #soa] !>]],
	 LKEYS.KEYREL #key & arg12-relation & [LBL #top,
                                             ARG2 #chand,
                                             ARG0 #event]]].  


; (ERB 2001-12-28) Once again, the space of quasi light verbs isn't
; that big, so we're not using many of these.  Commenting out those
; that aren't in use.


quasi-light-nohon-stem-lex := quasi-light-lex &
[SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

quasi-light-nohon-v-stem-lex := quasi-light-nohon-stem-lex & [STEMTYPE v-stem].
quasi-light-nohon-c-stem-lex := quasi-light-nohon-stem-lex & [STEMTYPE c-stem].

; (MS 2005-11-09) Subtypes to get rid of skip files.

quasi-light-nohon-v-stem-rareru-lex := quasi-light-nohon-v-stem-lex &
				       [SYNSEM.LKEYS.KEYREL rareru-relation ].

; (MS 2003-12-17) We cannot safely switch to the Matrix 0.6 definition of lexeme. 
; This needs some fundamental adaptations of the word and lexeme concepts.

lexeme :< lexical_sign.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  VP embedding Syntactic V-Vs
;;
;; (cf. syntactic-vv-stem_head in lex-types.tdl
;;      syn-vv-vp-stem_head in lex-types.tdl
;;      syntactic-vv-vp-stem-lex in lex-types.tdl
;;      syn-vv-raising-stem-lex in lex-types.tdl
;;      syn-vv-raising-{v/c/c2/kurusuru}-stem-lex in lex-types.tdl
;;      syn-vv-control-stem-lex in lex-types.tdl
;;      syn-vv-control-{v/c/c2/kurusuru}-stem-lex in lex-types.tdl
;;      infinitive-infl-rule-for-syntactic-VV in infl.tdl)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(CH 2005-04-09)
; v-stem_head と同じ
; 統語的複合動詞の V2 のためのタイプ
syntactic-vv-stem_head  := other-verb-stem_head &
			   [AUX aux_minus,
			    LIGHT -,
			    ADJ -,
			    COP -].

;(CH 2005-04-09)
; head for VP embedding V-Vs
syn-vv-vp-stem_head := syntactic-vv-stem_head &
		       [MODUS nonpassive].

;(CH 2005-04-09)
; Raising V-V と Control V-V の上位タイプ
; restricted the VP's COMPS to be <> (SPR should be a VP),
; and added the identities between SUBJs and COMPSs.
; syntactic-vv-vp-stem-lex := verb-stem-lex & lexical_sign-word &
;  [SYNSEM [LOCAL [CAT [HEAD syn-vv-vp-stem_head & [H-TENSE #tense],
; 		      VAL aspect_transitive &
; 			   [SUBJ < #sbj >,
; 			    COMPS #obj & <>,
; 			    SPR < [LOCAL [CONT.HOOK.LTOP #ohand,
; 					  CAT [VAL [SUBJ < #sbj >,
; 						    COMPS #obj ]]]] > ]],
; 		 CONT [HOOK.INDEX #event & [E [TENSE #tense]],
; 		       HCONS <! qeq & [LARG #ohand,
; 				       HARG #soa] !>,
; 		       RELS diff-list & <! #key,
; 					 message &
; 					 [PRED proposition_m_rel,
; 					  MARG #soa] !>],
; 		 ARG-S < #sbj >],
; 	  LKEYS.KEYREL #key & 
; 		[ARG0 #event],
; 	  NON-LOCAL.QUE <! !>,
; 	  MODIFIED.PERIPH +]].

;(CH 2005-04-09) [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.FIN -]
;(CH 2005-04-09) [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.BAR +]
;(CH 2005-04-09) verb-stem_head --> ordinary-verb-stem_head
; (FCB 2005-06-27) Added ARG0 to message
syntactic-vv-vp-stem-lex := verb-stem-lex & lexical_sign-word &
 [SYNSEM [LOCAL [CAT [HEAD syn-vv-vp-stem_head & [H-TENSE #tense],
		      VAL aspect_transitive &
			   [SUBJ < #sbj >,
			    COMPS #obj & <>,
			    SPR < [LOCAL [CONT.HOOK [ LTOP #ohand,
						      INDEX #oindex ],
					  CAT [HEAD ordinary-verb-stem_head & [FIN -],
					       VAL [SUBJ < #sbj >,
						    COMPS #obj ]],
					  BAR +]] > ]],
		 CONT [HOOK.INDEX #event & [E [TENSE #tense]],
		       HCONS <! qeq & [LARG #ohand,
				       HARG #soa] !>,
		       RELS diff-list & <! #key,
					 message &
					 [PRED proposition_m_rel,
					  ARG0 #oindex,
					  MARG #soa] !>],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL #key & 
		[ARG0 #event],
	  NON-LOCAL.QUE <! !>,
	  MODIFIED.PERIPH +]].

;(CH 2005-04-09)
; Raising 版の統語的複合
syn-vv-raising-stem-lex := syntactic-vv-vp-stem-lex &
 [SYNSEM [ LOCAL [ CONT.RELS <! #key, [ LBL #chand ] !> ],
	   LKEYS.KEYREL #key & arg1-relation & [ ARG1 #chand ]]].

syn-vv-raising-v-stem-lex := syn-vv-raising-stem-lex & [STEMTYPE v-stem].
syn-vv-raising-c-stem-lex := syn-vv-raising-stem-lex & [STEMTYPE c-stem].
;syn-vv-raising-c2-stem-lex := syn-vv-raising-non-aa-stem-lex & [STEMTYPE c2-stem].
;syn-vv-raising-kurusuru-stem-lex := syn-vv-raising-non-aa-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; Control 版の統語的複合
syn-vv-control-stem-lex := syntactic-vv-vp-stem-lex &
 [SYNSEM [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #sbjind ] >,
                   CONT.RELS <! #key, [ LBL #chand ] !> ],
           LKEYS.KEYREL #key & arg12-relation & 
                 [ ARG1 #sbjind, ARG2 #chand ]]].

syn-vv-control-v-stem-lex := syn-vv-control-stem-lex & [STEMTYPE v-stem].
syn-vv-control-c-stem-lex := syn-vv-control-stem-lex & [STEMTYPE c-stem].
;syn-vv-control-c2-stem-lex := syn-vv-control-stem-lex & [STEMTYPE c2-stem].
;syn-vv-control-kurusuru-stem-lex := syn-vv-control-stem-lex & [STEMTYPE kurusuru-stem].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  V embedding Syntactic V-Vs  ( Kageyama's (1993) V' complement type )
;;
;; (cf. syn-vv-vbar-stem_head in lex-types.tdl
;;      syn-vv-vbar-stem_transitive in lex-types.tdl
;;      syntactic-vv-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-intrans-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-monotrans-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-ditrans-vbar-stem-lex in lex-types.tdl
;;      vbar-monotransitivization-lrules in infl.tdl
;;      vbar-ditransitivization-lrules in infl.tdl)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(CH 2005-04-09)
; head for V embedding V-Vs
syn-vv-vbar-stem_head := syntactic-vv-stem_head.

;(CH 2005-04-09)
; based on light_transitive
;(CH 2005-04-09)
; verb-stem_head --> ordinary-verb-stem_head
syn-vv-vbar-stem_transitive := j-valence &
 [SPR  obl-1-arg &
       < [LOCAL [CAT [HEAD ordinary-verb-stem_head & [MAIN-PRD -],
		      VAL [SUBJ #sbj,
			   COMPS #comps]],
		 BAR +],
	  LEX +] >,
  SUBJ #sbj,
  COMPS #comps].

;(CH 2005-04-09)
; added [SYNSEM.LOCAL.CONT.HOOK.XARG #sbjind] so that XARG is linked to ARG1.
; (FCB 2005-06-27) Added ARG0 to message

syntactic-vv-vbar-stem-lex := verb-stem-lex & lexical_sign-word &
 [SYNSEM [LOCAL [CAT [HEAD syn-vv-vbar-stem_head & [H-TENSE #tense],
		      VAL syn-vv-vbar-stem_transitive &
			   [SUBJ.FIRST #sbj & 
				       [LOCAL [CAT.HEAD case-p_head &
							[CASE ni-or-ga],
					       CONT.HOOK.INDEX #sbjind]],
			    SPR.FIRST.LOCAL.CONT.HOOK [LTOP #ohand,
						       INDEX #oindex] ]],
		 CONT [HOOK [INDEX #event & [E [TENSE #tense]],
			     XARG #sbjind],
		       HCONS <! qeq & [LARG #ohand,
				       HARG #soa] !>,
		       RELS diff-list & <! #key, message &
					 [PRED proposition_m_rel,
					  ARG0 #oindex,
					  MARG #soa] !>],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL #key & arg1-relation &
		[ARG1 #sbjind,
		 ARG0 #event],
	  NON-LOCAL.QUE <! !>,
	  MODIFIED.PERIPH +]].

;(CH 2005-04-09)
; for an intransitive V1
syntactic-vv-intrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CONT.RELS <! [], [LBL #chand] !>,
		 CAT.VAL.SPR <[LOCAL.CAT.VAL [COMPS null]]>],
	  LKEYS.KEYREL arg12-relation &
		[ARG2 #chand]]].

syn-vv-intrans-vbar-v-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE v-stem].
syn-vv-intrans-vbar-c-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-intrans-vbar-c2-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-intrans-vbar-kurusuru-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; for a monotransitive V1
syntactic-vv-monotrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL [COMPS <[LOCAL.CONT.HOOK.INDEX #objind]>,
			   SPR.FIRST.LOCAL.CAT.VAL.COMPS 1-list]],
		 CONT.RELS <! [], [LBL #chand] !>],
	  LKEYS.KEYREL arg123-relation &
		[ARG2 #objind,
		 ARG3 #chand]]].

syn-vv-monotrans-vbar-v-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE v-stem].
syn-vv-monotrans-vbar-c-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-monotrans-vbar-c2-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-monotrans-vbar-kurusuru-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; for a ditransitive V1
syntactic-vv-ditrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL [COMPS <[LOCAL.CONT.HOOK.INDEX #objind],
				  [LOCAL.CONT.HOOK.INDEX #obj2ind]>,
			   SPR.FIRST.LOCAL.CAT.VAL.COMPS 2-comps-list]],
		 CONT.RELS <! [], [LBL #chand] !>],
	  LKEYS.KEYREL arg1234-relation &
		[ARG2 #objind,
		 ARG3 #obj2ind,
		 ARG4 #chand]]].

syn-vv-ditrans-vbar-v-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE v-stem].
syn-vv-ditrans-vbar-c-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-ditrans-vbar-c2-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-ditrans-vbar-kurusuru-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].


