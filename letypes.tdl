; -*- Mode: TDL; Coding: utf-8 -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;        file: lex-types.tdl
;;;      module: Basis
;;;     version: %I%
;;;  written by: Melanie Siegel
;;; last update: 
;;;  updated by: Melanie Siegel/Emily Bender/Francis Bond
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; author            | date        | modification
;;; -----------------|--------- ---|------------------------------------------
;;;Melanie Siegel(MS)|             | Emily Bender (ERB), Francis Bond (FCB), 
;;;                  |             | Sanae Fujita (SF), Takaaki Tanaka (TT),
;;;                  |             | Akira Ohtani (AO)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;HEADS;;;;;;;;;;;;;;;;;;;;;;;;;


; (ERB 2001-08-06) In order to do Jeff Smith's version of number
; names (i.e., using head-comps and head-spr rules) I need to
; classify all subtypes of head into integer and nonint_head.
; This way I can have a head-initial HCR that only works with
; number names.

; (ERB 2001-08-21) I found another candidate for the head of
; the head-initial HCR, namely symbols like $, ￥, etc. that
; (orthographically) precede the numbers the go with.  So,
; I'm renaming the two subtypes of head to be final_head and
; init_head.

final_head := head.
init_head := head.


; (MS 2005-11-23) trying to put utterance head a bit deeper under utt-valid
; (which itself inherits from final_head). Otherwise we cannot parse
; "これはよく売れるが，しかしあまり効かない薬だ。"

utterance-super :=  utt-valid &
                  [POS utt,
                   MOD null,
                   C-MOD null,
                   J-SPEC null,
                   MARK < >,
                   SMOD marked,
                   COP-ARG -].

utterance_head := utterance-super.
fragment_head := utterance-super.

temp_mod_head := final_head.

temp_mod_head-avm := temp_mod_head &
                     [POS temp_mod,
                      MARK null,
                      C-MOD null,
                      J-POSTHEAD right,
                      J-SPEC null,
                      COP-ARG -].


; (MS 2003-01-21) adding the MOD none restriction on the modified noun, because I got spurious ambiguity on 日本の経済
; (MS 2005-12-07) but this doesn't work, as nouns do modify!

temp_nmod_head := temp_mod_head-avm &
                     [ MOD < [LOCAL scopal-mod & [CAT.HEAD noun_head,
						  BAR +]] > ].


; (MS 2003-09-11) This seems not to be in use any more.

;temp_vmod_head := temp_mod_head-avm &
;                     [ MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD -,
;								  FORMAL.AHON -],
;                                            BAR +]] >,
;		       COP-ARG -].

noun_mod_head := final_head.

; (ERB 2002-01-10) Developing an analysis of など as a posthead
; noun-mod-lex.  So, this shouldn't be J-POSTHEAD left.

; (MS 2002-01-16) Moving from LEX + to BAR +, to allow compounds as modifiees.

noun_mod_head-avm :=  noun_mod_head &
                      [POS noun_mod,
                       MARK null,
                       MOD < [LOCAL [CAT [HEAD noun_head,
                                                 VAL saturated],
                                            BAR bool]] >,
                       C-MOD null,
                       J-SPEC null,
                       COP-ARG -].

pp_mod_head := final_head.



pp_mod_head-avm :=  pp_mod_head &
                      [POS pp_mod,
                       MARK null,
                       MOD < [LOCAL [CAT [HEAD vmod-p_head,
					  VAL saturated],
				     BAR bool]] >,
                       C-MOD null,
                       J-SPEC null,
                       COP-ARG -].

; (MS 2005-11-09) These are all AHON + and modifying BAR +.

hon-prefix_head :=  head &
                   [POS prefix,
		    FORMAL.AHON +,
                    MARK null,
                    MOD < [LEX +, LOCAL.BAR +] >,
                    C-MOD null,
                    J-POSTHEAD left,
                    J-SPEC null,
                    COP-ARG -].



punct_head := final_head &
              [MARK null,
               C-MOD null,
               COP-ARG -].

punct_head-avm := punct_head &
                  [J-SPEC  < >].

brackets-or-quotations_head := punct_head.
brackets-or-quotations-end_head :=brackets-or-quotations_head.
brackets-or-quotations-init_head :=brackets-or-quotations_head.

comma-etc_head := punct_head-avm.

; (ERB 2002-01-14) For comma that takes infinitival V as
; complement and gives it a C-MOD value.

; (ERB 2002-02-12) Don't know why I said C-MOD...ADJ -,
; but that obviously needs to come out: 食べ、よい.

punct_head2 := verb_head-super &
               [POS punct,
                MARK null,
                J-SPEC null,
                COP-ARG -,
                J-POSTHEAD coord,
                MOD null,
                C-MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
                             BAR +] ] >].

comma-pmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD p_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-advmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD adv_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-sapmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD sap_head,
                                    BAR +]] >,
               J-POSTHEAD right].

comma-infvmod_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD sentence-valid &
                                                [FIN -,
                                                 MAIN-PRD +]],
                                    BAR +]] >,
               J-POSTHEAD right].

; (ERB 2002-01-15) Replacing comma-s_conj with two commas that
; modify verbal things that have nonempty MOD and C-MOD values, respectively.

comma-vmod1_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD verb_head &
                                              [MOD 1-list,
                                               C-MOD null,
                                               MAIN-PRD +],
                                         VAL saturated],
                                    BAR +]] >,
               J-POSTHEAD right].

comma-vmod2_head := comma-etc_head &
              [MOD < [LOCAL [CAT [HEAD verb_head &
                                              [C-MOD 1-list,
                                               MAIN-PRD bool],
                                         VAL saturated],
                                    BAR +]] >,
               J-POSTHEAD right].

comma-interjmod_head  := comma-etc_head &
              [MOD < [LOCAL [CAT.HEAD interj_head,
                                    BAR +]] >,
               J-POSTHEAD right].


parent-end_head := punct_head & noun_head & int_head &
              [MOD < [LOCAL [CAT [HEAD noun_head,
				  VAL saturated],
			     BAR +]] > ].

parent-init_head := brackets-or-quotations_head &
              [MOD null,
	       J-SPEC  < >].


quotation-name-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].

quotation-name-end_head  := brackets-or-quotations-end_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head,
                                             BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].


quotation-noun-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].


quotation-noun-end_head  := brackets-or-quotations-end_head & noun_head &
                       [MOD < [LOCAL [CAT [HEAD ordinary_noun_head,
						  VAL saturated],
                                             BAR +]] >,
                        J-POSTHEAD right].

quotation-sentence-init_head := brackets-or-quotations-init_head &
                       [MOD null,
			J-SPEC  < >,
                        J-POSTHEAD left].

quotation-sentence-end_head  := brackets-or-quotations-end_head & sentence-valid &
                       [MOD < [LOCAL [CAT.HEAD sentence-valid,
				      BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].

quotation-sap-init_head := brackets-or-quotations-init_head & 
                      [MOD < [LOCAL [CAT.HEAD sap_head,
                                             BAR +]] >,
		       J-SPEC  < >,
                        J-POSTHEAD left].

quotation-sap-end_head  := brackets-or-quotations-end_head &
                       [MOD < [LOCAL [CAT.HEAD sap_head,
                                             BAR +]] >,
			J-SPEC  < >,
                        J-POSTHEAD right].

quotation-definition-end_head := brackets-or-quotations-end_head & nom_head-avm &
                       [MOD null,
			J-SPEC  null].

; (ERB 2001-08-09) I need a supertype to both noun_head and case-p_head to 
; get disjunctive modification possiblities for numeral classifiers w/o
; adding extra lexical entries.

noun-or-case-p_head := final_head.

noun_head := noun-or-case-p_head.

; (MS 2005-07-04) I want to get rid of the compound-noun-rule, such that I give a value to MOD here.

noun_head-avm :=  noun_head &
                  [POS n,
		   C-MOD null,
		   MARK null,
		   QUANTIFIABLE bool,
		   COP-ARG -].

; (ERB 2002-01-28) Make supertype to ordinary_noun_head and date_noun_head
; to allow words like TOKI as heads of compounds.


ordinary-or-date-noun_head := noun_head-avm.
ordinary_noun_head := ordinary-or-date-noun_head.

;(MS 2001-12-14) changing J-SPEC in order to make something like GAKUSEI SAMA possible.
; (MS 2005-07-04) I want to get rid of the compound-noun-rule, such that I give a value 
;   to MOD in noun_head-avm.
; (was MOD null)

ordinary_noun_head-avm := ordinary_noun_head & 
			  [J-SPEC.FIRST.LOCAL.CAT.HEAD title_head, 
			   MOD < [LOCAL [CAT [HEAD ordinary-or-date-noun_head]],
				  MODIFIED.PERIPH -]>,
			   J-POSTHEAD compound,
			   VN -].

;; (FCB 2003-09-04) type for mi and sa

adj2n-suffix_noun_head := ordinary-or-date-noun_head.


; (MS 2005-10-06) I use this for month names.
; (MS 2005-11-04) I date nouns to occur in compounds, such as "毎週土曜日"

date_noun_head := temporal-noun_head & ordinary-or-date-noun_head.

date_noun_head-avm := date_noun_head & [J-SPEC null, 
					J-POSTHEAD compound,
					VN -,
					MOD < [LOCAL intersective-mod & 
						     [CAT [HEAD noun_head-avm,
							   VAL saturated]],
					       MODIFIED.PERIPH -] >].

pron_head := noun_head-avm.

pron_head-avm := pron_head & [MOD null, 
	                      KEYS.KEY pron_rel,
			      J-SPEC null, 
			      VN -,
			      QUANTIFIABLE -].

exceptional_noun_head := nom_head-avm & [MOD null, 
					 J-SPEC null, 
					 NO-MOD -, 
					 QUANTIFIABLE -].

; (MS 2005-03-30) This seems not to be in use any more.
;exceptional_noun_nmod_head := nom_head-avm & [J-SPEC null, 
;					      QUANTIFIABLE -, 
;					      MOD < [LOCAL.CAT.HEAD noun_head]>, 
;					      J-POSTHEAD rels].

                  
relational_noun_head := ordinary_noun_head & [MOD null,J-SPEC null, VN -].
                                                   

dofw_noun_head  := temporal-noun_head.
dofm_noun_head  := temporal-noun_head.



dofw_noun_head-avm := dofw_noun_head & 
                      [MOD null].

dofm_noun_head-avm := dofm_noun_head & 
                      [MOD null].



nom_head  := noun_head-avm.


nom_head-avm  := nom_head & [J-SPEC null, ADJ -].


title_head  := noun_head-avm.



title_head-avm := title_head & 
                  [MOD < [LOCAL.CAT.HEAD idiom_head] >, 
                   J-SPEC null,
                   J-POSTHEAD left,
                   QUANTIFIABLE -].


name_head := noun_head-avm.


name_head-avm := name_head & 
                 [J-SPEC.FIRST.LOCAL.CAT.HEAD title_head,
		  VN -,
                  QUANTIFIABLE -].

; (MS 2005-03-15) For documentation purposes, changed pn_head to surname_head

surname_head := name_head-avm.


surname_head-avm := surname_head & 
               [MOD < [LOCAL [CAT.HEAD name_head]] >,
		J-POSTHEAD compound].

ippan_head := name_head-avm.

ippan_head-avm := ippan_head &
                  [MOD < [LOCAL [CAT.HEAD ordinary_noun_head]] >,
                   J-POSTHEAD left].

first_name_head := name_head-avm.


first_name_head-avm := first_name_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head]] >,
			J-POSTHEAD compound].

other_name_head := name_head-avm.

other_name_head-avm := other_name_head & 
                       [MOD < [LOCAL [CAT.HEAD name_head]] >,
			J-POSTHEAD compound].

inst_name_head := name_head-avm.

;(MS 2005-11-15) Found examples of compounds with inst-names,
; such as "小田急片瀬江ノ島駅前". Changing MOD null to noun_head.

inst_name_head-avm := inst_name_head & 
                      [MOD < [LOCAL.CAT.HEAD noun_head] >,
                      J-POSTHEAD compound].

; (MS-2005-09-30) Shouldn't the relation between a location name and an institution be a compound?
; Maybe it should just be a noun: "アメリカ経済"

loc_name_head := name_head-avm.

loc_name_head-avm := loc_name_head & 
                     [MOD < [LOCAL.CAT.HEAD noun_head] >,
                      J-POSTHEAD compound].


product_name_head := name_head-avm.

product_name_head-avm := product_name_head &
                        [MOD null].

temp_numeral_head := temporal-noun_head.


; (MS 2005-11-04) Found examples for compounds of temp_numerals and noun (vn): "深夜営業"
; changing the MOD null value.

temp_numeral_head-avm :=  temp_numeral_head & 
                      [MOD < [LOCAL.CAT.HEAD noun_head] >].

; (ERB 2001-08-07) Redoing numeral classifiers...
; (ERB 2001-08-07) Copying constraints from expanded def of old
; number-classifier_head and changing as appropriate.
; (ERB 2001-09-24) Making this COP-ARG - until data
; compels the contrary.
; (ERB 2001-10-29) I believe they should be COP-ARG +,
; but they need to be made into something predicative in order
; to function properly as the complement of the copula.  So,
; I think I'll add another pumping rule.

num-cl_head := init_head &
	       [ MARK null,
                 POS numcl,
                 C-MOD null,
                 J-SPEC null,
                 FORMAL formal,
                 QUANTIFIABLE -,
		 VN -,
                 COP-ARG - ].

; 本、個、便、etc.

; (ERB 2001-08-09) Trying to get disjunctive MOD values without positing
; extra lexical entries for numeral classifiers.

; (ERB 2001-09-13) J-POSTHEAD has different values depending on what the
; MOD.HEAD value is.

num-cl-mod_head := num-cl_head &
                   [ MOD < synsem > ].

num-cl-n-or-p-mod_head := num-cl-mod_head & 
                          [MOD < [LOCAL.CAT [ HEAD noun-or-case-p_head,
					      VAL saturated ]] > , 
			   J-POSTHEAD right ].

; (MS 2004-12-27) Floated numeral classifiers
; (MS 2005-01-07) Using EMPTY to prevent floated quantifiers to go into the nominal-numcl-rule.
; (FCB 2007-07-03) FIXME: make this intersective

num-cl-adv_head := num-cl-mod_head &
                   [ MOD < [LOCAL scopal-mod & [CAT [ HEAD verb_head]]] >,
		     EMPTY -].

num-cl-float_head := num-cl-adv_head.
num-cl-event_head := num-cl-adv_head.

; 番、号

; (ERB 2001-09-12) Some num-cl like things can't "float" (i.e., show 
; up outside the PP.  So these have a more specific MOD value).

; (MS 2004-11-30) But these should not go into the relative clause rule.
; That's why they get the J-POSTHEAD nonrels.

; (MS 2005-01-10) The modified noun should be saturated to prevent spurious
; ambiguity in e.g., 猫二匹を飼う
; The J-POSTHEAD should be right, because pre-nominal numeral classifiers are not 
; possible: *二匹猫を飼う

num-cl-nmod_head := num-cl-mod_head &
                    [ MOD < [LOCAL.CAT [HEAD noun_head,
					VAL saturated]] >,
		      J-POSTHEAD right].


; 円、階、etc.

num-cl-nomod_head := num-cl_head &
                     [ MOD null ].

; ERB (2001-08-28) Date expressions

; ERB (2001-09-24) Overhauling the date expressions.  The general
; plan is treat them as nouns, which take up to three arguments:
; a determiner (この、その、あの、どの）
; an OBJ2 (月 for 日 and 年 for 月)
; an integer (1-12 for 月、1-31 for 日、unlimited for 年)
; The first two of these are optional, although ordered.
; The third is obligatory, and must occur right next to the head.

; (ERB 2002-01-14) I want to allow punct_head2 in the sentence-te-coordination
; rule without allowing it anywhere else that verbs are required.  So,
; making this supertype.

verb_head-super := sentence-valid.

verb_head := verb_head-super.

;(MS 2001-09-25) I've taken S-MODIFIED out of the head in order to replace it with NUCLEUS, but not in the head.

;(ERB 2002-01-15) verb_head-avm contrasts with verbend_head, so declaring
; the feature EMPTY here causes problems:  When conjunctions place restrictions
; on its value, they force type resolution from sentence-valid to 
; verb_head-avm and then don't unify with inflected verbs (i.e., those
; that are HEAD verbend_head).  So, moving EMPTY up to verb_head.

verb_head-avm := verb_head &
             [POS v,
              AUX aux,
              COP bool,
              VN bool,
              LIGHT bool,
              ADJ bool,
              MODUS mood,
              FIN bool,
              MAIN-PRD bool,
              SMOD smod].


verb-stem_head := verb_head-avm &
                  [VN -].

ordinary-verb-stem_head := verb-stem_head.

other-verb-stem_head := verb-stem_head.

v-stem_head  := ordinary-verb-stem_head &
                [AUX aux_minus,
                 MODUS nonpassive,
                 LIGHT -,
                 ADJ -].

cop-id-stem_head := v-stem_head &
		    [COP-ARG -,
		     COP +,
		     VN -,
		     AUX aux_minus,
		     LIGHT -,
		     ADJ -].

aux-stem_head := other-verb-stem_head &
                [AUX aux_plus,
                 ADJ -,
                 LIGHT -,
                 COP-ARG -].
     
; (MS 2004-06-25) Took the ADJ - restriction out.

verbend_head := verb_head &
              [COP -].

; (ERB 2002-01-11) Most verbal endings are [SMOD unmarked]:
; (FCB 2006-11-05) made a subtype of adj-or-adv_head to allow 
; (do-parse-tty "とても 美味しかっ た")
; (do-parse-tty "とても 空い て いる")

v-end_head := verbend_head & adj-or-adv_head.


verbend_head-unmarked := verbend_head &
                         [ SMOD unmarked ].

v-op-end_head := verbend_head-unmarked & [VN -].

v-cond-end_head := v-op-end_head.

v-pass-caus-end_head := verbend_head-unmarked.

pass-end_head := v-pass-caus-end_head & [MODUS passive].

simple-pass-end_head := pass-end_head & [MOD < [LOCAL [CAT.HEAD noun_head,
						       BAR +]] >,
					 J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					 FIN +,
					 J-POSTHEAD rels,
					 C-MOD null,
					 FORMAL.AHON -].



caus-end_head  := v-pass-caus-end_head & [MODUS causative,
					   MARK < [MODIFIED.PERIPH -] >].

contracted-aux_head := verbend_head-unmarked.

verb-noninfl_head := verb_head-avm.

verb-noninfl_head-avm := verb-noninfl_head & [AUX aux_minus].

cop_head := verb-noninfl_head-avm & [COP-ARG -, LIGHT -].

; (MS 2003-1-22) Should be COP-ARG neutr, because of 結婚するんですか 

light-verb_head := other-verb-stem_head &
                [AUX aux_minus,
                 ADJ -,
                 LIGHT +].

p_head := final_head.

p_head-avm := p_head &
          [POS p,
           PTYPE ptype,
           MARK null,
           CASE case].

mod-p_head := p_head-avm.

; (ERB 2002-01-22) Adverbs and such can modify things that are NUCL nucl_bool,
; but crucially not things that are NUCL conj.  This forces low adverb
; attachment wrt to the conj-rule.
; (MS 2002-07-04) But this is not valid for topic particles.
; "これは聞けば分かります"

mod-p_head-avm := mod-p_head &
              [CASE mod,
               C-MOD null,
               MOD 1-list].

vmod-p_head := mod-p_head-avm.

; (ERB 2001-09-13) Getting rid of J-POSTHEAD value intersective, in system
; with only two HMRs.  See notes in japgram.tdl and rule-types.tdl.
; (MS 2001-11-29) Making all these intersective-mod for the differentiation in the head-adjunct rules.

vmod-p_head-avm := vmod-p_head &
                   [J-SPEC null,
                    MOD < [LOCAL intersective-mod &
					[CAT.HEAD verb_head,
                                         BAR +]] >,
                    J-POSTHEAD left].


; (ERB 2002-01-21) How bad is it for ambiguity if this doesn't
; say MOD...SMOD unmarked?  (I'm using that to constrain some other
; things and it would be nice if the head type were enough here.)

; (MS 2004-11-12) Here we restrict the MOD to be MAIN-PRD +. But this is not true
; in all cases: 社内でも有名な王が寝る。Here we want to be able to say that the king is
; famous in the company. I wonder how much this affects the ambiguity.

;topic-vmod-p_head := vmod-p_head-avm & [MOD < [LOCAL [CAT.HEAD [MAIN-PRD +]] ] >,
;                                        PTYPE topic,
;                                        COP-ARG -].

topic-vmod-p_head := vmod-p_head-avm & [PTYPE topic,
                                        COP-ARG -].

; (MS 2005-05-10) Not used any more.
;uttmod-p_head := mod-p_head-avm &
;               [J-SPEC null,
;                MOD < [LOCAL [CAT.HEAD verb_head & [FIN +,
;                                                          MAIN-PRD +],
;                                     BAR +,
;				     NUCL nucl_bool]] >,
;                J-POSTHEAD left,
;                COP-ARG -].



nmod-p_head := mod-p_head-avm.

;"dekitara issho ni hanoofaa no kaNkou  shimaseN ka."
;"asa no juuji ni rufutohaNza no nanahyaku yoNjuuichi biN ga dete imasu keredomo."


nmod-p_head-avm := nmod-p_head &
                   [MOD < [ LOCAL.NUCL nucl_bool ] >,
                    J-POSTHEAD left,
                    COP-ARG -].




overt-nmod-p_head := nmod-p_head-avm & 
                     [PTYPE overt,
                      J-SPEC null,
                      MOD < [LOCAL [ CAT [HEAD noun_head,
                                        VAL saturated]],
                           MODIFIED.PERIPH bool] > ].



; (MS 2001-12-14) The COP-ARG - is introduced to prevent spurious ambiguity in II NO DESU KA.

nspec-p_head := p_head-avm & [MOD null,
			      COP-ARG -,
                              C-MOD null,
                              PTYPE overt,
                              J-SPEC.FIRST.LOCAL.CAT.HEAD nom_head].

empty-nmod-p_head := nmod-p_head-avm & 
                     [PTYPE empty,
                      J-SPEC null,
                      MOD < [LOCAL.BAR -] >,
                      COP-ARG -].

; (MS 2005-10-21) "C-MOD < [MODIFIED.PERIPH -]" prevents the case of compounds in conjunctions.
; Changing that.

n_conj_head := p_head-avm & [MOD null,
                             CASE con,
                             PTYPE to,
                             J-SPEC null,
                             C-MOD < [MODIFIED.PERIPH bool] >].



;"ato saNgatsu desu to yahari juuninichi no mokuyoubi kara hatsuka kiNyoubi made no hou ga tsugou yoroshii no desu ga."

empty-vmod-p_head := vmod-p_head-avm & [PTYPE empty,
                                        MOD < [LOCAL [CAT.HEAD.MAIN-PRD +,
						   NUCL nucl_bool]] >,
                                        COP-ARG -].


empty-frag-p_head := p_head-avm & [PTYPE empty,
                                   MOD null,
                                   C-MOD null,
                                   COP-ARG -].

case-p_head := p_head-avm & 
               [CASE case,MOD null,J-SPEC null,C-MOD null,
                COP-ARG -].

overt-case-p_head := case-p_head & [PTYPE overt].

; (ERB 2001-08-09) Adding supertype that relates case-p_head to noun_head for
; numeral classifiers.

ga-or-wo-case-p_head := overt-case-p_head & noun-or-case-p_head & [CASE ga-or-wo].

empty-case-p_head := case-p_head  & [PTYPE empty].

; (MS & FCB 2003-10-29) added AUX aux_minus to get rid of spurious ambiguity in 普通 と 違っ て いる.
; (MS 2004-11-05) But now we don't get aspectual readings in 家から父が運んでいる . So, I take
; it out again.

postp_head := vmod-p_head-avm &
              [PTYPE overt,
	       MOD < [LOCAL [NUCL nucl_bool,
			     CAT.HEAD.AUX aux]] >,
               COP-ARG +].


; (MS & FCB 2003-10-29) added AUX aux_minus to get rid of spurious ambiguity in 普通 と 違っ て いる.
; (MS 2004-11-05) But now we don't get aspectual readings in 家で父が運んでいる . So, I take
; it out again.

adv-p_head := vmod-p_head-avm &
                [PTYPE overt,
		 MOD < [LOCAL [NUCL nucl_bool,
			       CAT.HEAD.AUX aux]] >,
                 COP-ARG -].


idiom_head :=  sentence-valid &
              [POS idiom,
               MOD null,
               C-MOD  < [LOCAL [CAT [HEAD sentence-valid & [MAIN-PRD +,
                                                       FIN +],
                                VAL saturated],
                            BAR +]] >,
               J-POSTHEAD left,
               MARK null,
               COP-ARG -,
               J-SPEC null].

sap_head := p_head-avm &
            [J-SPEC null,
             MARK null,
             MOD 0-1-list,
             SMOD marked,
             PTYPE sentence-particle,
             J-POSTHEAD left] .


; (MS 2005-05-17) This is not needed any more!
;sap1_head := p_head-avm &
;            [POS sap,
;             J-SPEC null,
;             MARK null,
;             MOD 0-1-list,
;             SMOD unmarked,
;             J-POSTHEAD left,
;             COP-ARG -] .

; (ERB 2001-09-06) Conjunctions should only modify finite sentences.

; (ERB 2002-01-07) They also have to be able to modify finite sentences
; like V-te + kudasai.  Adding a type utt-valid to describe this class.
; (was: C-MOD.LOCAL.CAT.HEAD sentence-valid).

; (ERB 2002-01-07) That doesn't give quite the right result because
; when the second conjunct is 〜ください, the message is already there
; and the message contributed by the conjunction is irrelevant.  A
; short-term solution is to make two kinds of conjunctions: those that
; are [C-MOD sentence-valid] and supply two messages and those that
; are [C-MOD s-end_head] and supply just one message.  In the long run,
; we might think about revamping the way messages are introduced.
; Also, we might worry some more about the relative scope of messages
; and the conj-rel in different constructions.
; (MS 2005-06-07) It seems that this one is never applied.
s-conj_head := sap_head &
               [MOD null,
		CASE con,
		COP-ARG -,
                C-MOD < [LOCAL [CAT [HEAD sentence-valid & [MAIN-PRD +,
                                                        FIN +,
                                                        SMOD unmarked],
                                 VAL saturated],
                            BAR +]] >,
                J-POSTHEAD left].

; (ERB 2002-01-07) Want this to apply to vn+kudasai as well, which is
; actually HEAD v-end_head.  So, change [HEAD s-end_head] to 
; [HEAD utt-valid & [SMOD marked]].  (utt-valid groups together 
; sentence-valid and s-end_head.
; (MS 2005-05-18) But this prevents "食べたから寝た" from parsing. So, I took the restriction out.

s-conj-nonprop_head := sap_head &
               [MOD null,
		COP-ARG -,
                C-MOD < [LOCAL [CAT [HEAD utt-valid & 
                                      [ FIN + ],
                                 VAL saturated],
                            BAR +]] >,
                J-POSTHEAD left].

; (ERB 2002-01-07) utt-valid groups together sentence-valid and
; s-end_head.  (Added for conjunction with non-propositional right
; conjuncts.)

s-end_head := sap_head & utt-valid.

s-end_head-avm := s-end_head &
              [MOD null,
               C-MOD null,
               J-POSTHEAD left].

interj_head := final_head.

; (ERB 2001-12-10) These aren't doing anything semantically, so
; make them use the intersective head adj rule.

; (ERB 2001-12-10) Making them more like "well" and "so" in the LinGO
; grammar.  Among other things, this means they're scopal modifiers.

; (ERB 2001-12-10) The corresponding words in the LinGO grammar only
; attach to matrix sentences.  Try making these guys [MOD utt].  This
; would save us having to put in a message for the sentence they 
; attach to (can't tell what it will be anyway).  Should also force
; high attachment.
; try making CAT.HEAD  utterance-super rather than sentence-valid to reduce ambiguity

interj_head-avm := interj_head &
                   [POS interj,
                    J-SPEC null,
                    MARK null,
                    MOD < [LOCAL scopal-mod &
                                        [CAT.HEAD utterance-super]] >,
                    C-MOD null,
                    J-POSTHEAD left,
                    COP-ARG -].


excl_head := idiom_head &
             [J-SPEC null,
              MARK null].


det_head := final_head.

det_head-avm := det_head &
            [POS det,
             MARK null,
	     KEYS.KEY def_q_rel,
             J-SPEC < [LOCAL [CAT.HEAD noun_head,
                                    BAR +],
                            MODIFIED.PERIPH bool] >,
             MOD null,
             C-MOD null,
             COP-ARG -].

; (MS 2002-04-17) DAI behaves like a definite determiner on counted nouns: 一本 - one book, 第一本 - the first book. 
; I've thus made it a determiner that specifies counted nouns. 
; I could not think of a solution that changes the card-rel to ord-rel, though.


card2ord_head-avm := det_head &
		     [POS det,
		      MARK null,
		      J-SPEC < [LOCAL [CAT.HEAD noun_head,
				       BAR +],
				LKEYS.KEYREL reg-nom-relation,
				MODIFIED.PERIPH bool] >,
		      MOD null,
		      C-MOD null,
		      COP-ARG -].


vn_head := verb-noninfl_head-avm.

; (ERB 2001-09-03) If I want the vn-light verb combination to be done via the
; head-spr rule, I need VNs to have a compatible J-SPEC value.

; (ERB 2001-09-19) I'm trying to keep the output of v2vn-infl-rule
; from being the complement of nspec-no-3, which is supposed to attach
; to te forms.  So as a first pass, I'm going to say that all vns
; are [H-TENSE no_tense].  This also requires a change to light verbs.

; (MS 2001-11-22) I take the MODUS indicative restriction out in order to allow VNs to combine with light verbs in, e.g., potential mode.

; (ERB 2001-12-28) For VN + itadaku, these can't be J-SPEC null, if that combination
; is to happen via the head-spr rule.  Try J-SPEC ... HEAD aux-stem_head

; (ERB 2002-01-02) That's overly restrictive if VN + kudasai is vn-vend-rule
; (subtype of head-spr rule).  Try J-SPEC ... HEAD verb_head, and hope it doesn't
; overgenerate.

; (ERB 2002-01-02) It does over generate, since suru is also looking for a
; vn specifier.  Try adding constraint [LIGHT -].  (Assumes that the
; vn-light-rule doesn't check the J-SPEC value of the VN.)

; (MS 2002-02-08) Took the HEAD restriction out. Then, also VNs can be specifiers of 
; nominalizations as in "変更届けを提出済ですが".

vn_head-avm := vn_head &
           [MOD null,
            C-MOD null,
            MODUS mood,
            FIN -,
            VN +,
            J-SPEC.FIRST.LOCAL.CAT.HEAD [LIGHT -],
            MARK < [LOCAL [CAT.HEAD verb_head,
                                  BAR +]] >,
            COP-ARG -].

; (ERB 2001-09-03) Can't require HEAD light-verb_head of J-SPEC value because
; that's MOD none, but the inflected light verb is MOD synsem.

;;; FCM FIXME - do we need this and the stem head?
i-adj_head := verb_head-avm & 
              [VN -,
               C-MOD null,
               AUX aux_minus,
               COP -,
               LIGHT -,
               ADJ +,
               J-POSTHEAD rels,
               COP-ARG -].

adj_head := adj-or-adv_head.                                         

; (MS 2002-1-7) This should have an ADJ +, shouldn't it?
; (MS 2002-1-15) changed the J-SPEC from verbend_head-unmarked to verbend_head, otherwise 小さかった wouldn't parse.
; (MS 2002-12-04) Took the J-SPEC value out. Otherwise, 小さいこと would not parse.
; (FCB 2006-05-11) Added adj_head as another parent (to allow deg-adv to modify i-adj)
; also use for pred-adj-lex: ookina
; adj-head must be COP +  to allow 美しい　です

i-adj-stem_head :=  other-verb-stem_head & adj_head &
                   [ADJ +].
                                                  
na-adj_head  := adj_head &
              	[COP-ARG -,
                 C-MOD null,   	
                 MARK null].

na-adj-basic_head := na-adj_head & 
 [ADJ +,
  POS adj].

;na-adj-suffix_head := na-adj-basic_head & [MOD < [LOCAL intersective-mod & 
;							[CAT [HEAD ordinary_noun_head,
;							      VAL saturated]]] >,
;					   J-POSTHEAD left].

na-adj-end_head := na-adj_head & verbend_head-unmarked & 
 [ POS adj,
   MOD null,
   J-SPEC.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2005-03-30) This seems not to be used any more.
;exceptional-adj_head := adj_head &
;                        [MOD < [LOCAL.CAT.HEAD ordinary_noun_head ] >,
;                         POS adj,
;                         J-SPEC null,
;                         MARK null].

; (ERB 2001-01-02) [MOD ... NUCL +] is too restrictive if
; we want head-adjunct rules to be [NUCL -] on the mother.
; This may have been there to restrict ambiguity, but I think
; the ambiguity is probably valid.

; (ERB 2002-01-22) On the other hand, we really don't want adverbs
; attaching wrt to the conj-rule.  So require [NUCL nucl_bool].

; (MS 2002-06-19) Sometimes we want to allow attachements of adverbs on lower verbs. 
;  I thus take the MAIN-PRD + restriction on the modified item out.
;  "税金の項目を申告でなく源泉にしたいのですが"

adv_head := adj-or-adv_head &
            [POS adv,
             J-SPEC null,
             MARK null,
             C-MOD null].


; (MS 2004-11-05) erased AUX aux_minus on the modified to account for aspectual reading
; of また彼が帰って来る


adv_head-avm := adv_head &
            [KEYS.KEY adv_rel,
	     MOD < [LOCAL [CAT.HEAD sentence-valid]] >,
	     H-TENSE present].

;;; making MOD.LOCAL.CAT.HEAD.ADJ + stops us from modifying adverbs
;;; FIXME: now we over generate by modifying past tense normal verbs

adv_deg_head-avm := adv_head &
            [KEYS.KEY adv_rel,
	     MOD < [LOCAL.CAT.HEAD adj-or-adv_head &
				   [ADJ bool]] >,
	     H-TENSE present].

adv_deg_num_head-avm := adv_head &
            [KEYS.KEY adv_rel,
	     MOD < [LOCAL [CAT.HEAD num-cl_head]] >,
	     H-TENSE present].

case-adv_head := adv_head &
            [MOD < >].

hes_head := final_head.

hes_head-avm := hes_head &
            [POS hes,
             J-SPEC null,
             MARK null,
             MOD < [LOCAL.CAT [HEAD ordinary_noun_head,
			       VAL saturated]] >,
             C-MOD null,
             J-POSTHEAD right,
             COP-ARG -].


;dai ichi kibou

; (ERB 2001-08-06) Redoing the numbers following Jeff Smith's analysis
; of English number names.

; (ERB 2001-08-06) Numbers don't modify anything.  They will be SPRs
; of numeral classifiers and other elements.

; (ERB 2001-08-20) Adding a feature [ST-ALONE bool] (for "stand-alone")
; to express the fact that when sen takes ichi as its SPR, it can't
; be the head of the thing that NumCl select.  (And especially not with
; the NumCl 年).

; (ERB 2001-10-29) int_head should be COP-ARG -, as integers
; themselves can't be predicative (they need to be promoted first).
; (Was COP-ARG +.)

int_head := init_head &
           [ ST-ALONE bool,
             POS card,
             C-MOD null,
             J-POSTHEAD left,
             MARK null,
             J-SPEC 1-list,
             COP-ARG -].

int_head-avm := int_head &
                [MOD null].

; (ERB 2001-08-06) Subtypes of int_head for subcategorization of SPR and COMPS
; inside number names.  Names of the form intk- mean "int_head with k or fewer
; digits".

; (ERB 2001-08-21) Adding subtypes for XDigitErsatz that don't correspond
; to types that are already there.

; (ERB 2004-1-18) Need a special type for 何 in num cl phrases,
; so that it's an integer but can't be selected by anything else.

nan_int := int_head-avm.

int21 := int_head-avm.
int17- := int_head-avm.
int17 := int17-.
int13- := int17-.
; (ERB 2001-08-21) For ThirteenPlusDigitErsatz
int13x := int13-.
int13 := int13-.
int9- := int13-.
; (ERB 2001-08-21) For Nine-TwelveDigitErsatz
int9x := int9-.
int9  := int9-.
int5- := int9-.
; (ERB 2001-08-06) For Six-EightDigitErsatz
int5x := int5-.
int5  := int5-.
int4x := int5-.
int4z := int4x.
int4- := int4x.
int4  := int4-.
int3- := int4-.
int3  := int3-.
int2- := int3-.
int2  := int2-.

; (ERB 2001-08-06)Need a type "1 or fewer digits" because ichi is special: It
; behaves like the other one digit numbers when it's a complement, but
; differently in specifier position (juu and hyaku won't take it as a
; specifier).

int1- := int2-.
int1  := int1-.
int_ichi := int1-.

; (ERB 2001-12-05) Need a special head type for 半 because it has a very
; restricted distribution.  (Chasen calls it a 名詞-接尾-一般+n-n.  Although
; an inflectional rule analysis isn't implausible, I'm going to stick
; with a syntactic analysis of things like 年半 in 二年半 for now.)

han_head := final_head &
            [ MOD null,
              C-MOD null,
              J-SPEC null ].

grad_head := final_head.

grad_head-avm := grad_head &
                 [POS adv,
                  MARK null,
                  MOD 1-list,
                  C-MOD null,
                  J-POSTHEAD left,
                  J-SPEC null,
                  COP-ARG -].

;;;;;;;;;;;;;;;;;;SUBCATEGORIZATION - others;;;;;;;;;;;;;;;;;;;;;;;;;;


spr-arg := valence &
              [SPR 1-list,
	       SUBJ null,
	       COMPS null].



spr-obj-arg := valence &
               [SPR 1-list,
		SUBJ null,
		COMPS 1-list].

obj-arg := valence &
               [SPR null,
		SUBJ null,
		COMPS 1-list].

obj-obj2-arg := valence &
               [SPR null,
                SUBJ null,
		COMPS 2-comps-list].
;;; FCB refactor
; sc-sbj-arg-lex := word-or-lexrule &
;  [SYNSEM.LOCAL.CAT.VAL [SPR null,
; 			SUBJ opt-1-arg,
; 			COMPS null]].


sbj-arg :=  valence & 
               [SPR null,
		SUBJ opt-1-arg,
		COMPS null].


; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

sbj-obj-arg := valence &
               [SPR null,
		SUBJ opt-1-arg,
		COMPS 1-list].


sbj-obj-obj2-arg := valence &
               [SPR null,
		SUBJ opt-1-arg,
		COMPS 2-comps-list].

sbj-spr-arg  := valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS null].

;(MS 2002-11-18) This one is needed for subject raising, if the subject could also have been deleted.

sbj-or-not-spr-arg  := valence &
		[SPR 1-list,
		 SUBJ 0-1-list,
		 COMPS null].

sbj-obj-spr-arg  := valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 1-list].

sbj-obj-or-not-spr-arg := valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 0-1-list].

sbj-obj-obj2-spr-arg := valence &
		[SPR 1-list,
		 SUBJ opt-1-arg,
		 COMPS 2-comps-list].

; (MS 2003-10-05) insert a quant-relation that introduces the attributes,
;  while the _rel is a sort, says Dan.


noun_sc  :=  spr-arg &
             [SPR opt-1-arg & 
		  < [LOCAL [CAT.HEAD det_head,
			    CONT det-sem-type]] >].



temp_noun_sc  :=  spr-obj-arg &
             [SPR opt-1-arg & 
		  < [LOCAL.CAT.HEAD det_head] >,
	      COMPS opt-1-arg & 
		  <[LOCAL [CAT.HEAD case-p_head & [CASE temp-no]]] >].


title_sc  :=  spr-arg &
             [SPR < [LOCAL [CAT [HEAD noun_head,
				 VAL saturated]]] >].

loc-title_sc := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT [HEAD loc_name_head,
				    VAL saturated]]] >].


p_sat :=  obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL.CAT.VAL saturated] >].


kara-made_sc :=  obj-obj2-arg &
                 [COMPS obl-2-args &
			< synsem & [LOCAL.CAT [HEAD noun_head,
					       VAL saturated]],
			  synsem & [LOCAL.CAT.HEAD case-p_head & [PTYPE kara]] >].


nom_sc :=  spr-arg &
           [SPR obl-1-arg].

subcategorizing-noun_sc := spr-obj-arg &
                           [COMPS obl-1-arg &
				  < [LOCAL.CAT.VAL saturated] >,
			    SPR opt-1-arg &
				  < [LOCAL [CAT.HEAD det_head,
					    CONT det-sem-type]] > ].

; (MS 2004-08-25) Topics and colons should be allowed as arguments.
; This is why I changed the CASE to ga-or-coparg.

adj_sc := sbj-arg &
 [SUBJ.FIRST [LOCAL.CAT.HEAD case-p_head & [
     CASE ga-or-coparg]] ].


eval-adj_sc := obj-arg &
 [COMPS < [LOCAL [CAT [HEAD [FORMAL.AHON -],
		       VAL saturated],
		  BAR +]] > ].


;;; (AO 2003-09-04) MS patch for expressions like "... de, ..." in japanese dictionaries.
; (MS 2004-06-25) The restriction on EMPTY - is not useful. It prevents the parsing of, e.g.
; 子供は学生と大人が先生だ。
; (MS 2005-05-17) Trying to put sentence particles into the type hierarchy of particles.

sap_sc := p_sat & 
 [COMPS obl-1-arg &
	< [LOCAL [CAT [HEAD sentence-valid & 
			    [MODUS uttmodus,
			     MAIN-PRD +],
		       VAL saturated],
		  BAR +],
	   MODIFIED hasmod] > ].

; (ERB 2001-12-28) For kudasai on VNs.

sap-restricted_sc := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT [HEAD vn_head,
					   VAL saturated],
				      BAR +]] > ].

desu-sap_sc := sap_sc & 
               [COMPS < [LOCAL.CAT.HEAD verb_head & [COP -, VN -]] > ].



             

;;;;;;;;;;;;SUBCATEGORIZATION - verbs;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




ga-wo_transitive := sbj-obj-arg  & 
                     [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                           COMPS opt-1-arg &
			   < [LOCAL.CAT.HEAD case-p_head & [CASE wo]] >].

;;; FCB used in 欲しい　好き
ga-ga_transitive := sbj-obj-arg &
                     [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                           COMPS obl-1-arg &
			   < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].


; (SF 2003)
; (MS 2003-12-23) This seems not to be used.
; (FCB 2007-12-19) < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >].
;                -> < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].
; 必要,欲しい
ni-ga_transitive := sbj-obj-arg  & 
                     [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >,
                           COMPS opt-1-arg & 
			   < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

ga-ni_transitive := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
                          COMPS < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] > ].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.

naru_adv_transitive := sbj-obj-arg &
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
		     COMPS obl-1-arg &
			   < [LOCAL.CAT.HEAD adv_head] >].

; (MS 2004-11-22) I don't think that we need sbj-obj2-arg.
; (FCB 2005-03-22) removed this as we now treat the ni-or-to as optional

; naru_noun_transitive :=  sbj-obj-arg &
;                     [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
;                           COMPS obl-1-arg &
; 			  < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] > ].

; (FCB and CH 2005-034-12) for complement suru 
; (do-parse-tty "彼 が 鈍 を 銀 に し た") "he made lead into silver"
; FIXME now also parses  (do-parse-tty "彼 が 鈍 を とても し た") 
; need to distinguish 綺麗に/美しく from real adverbs
suru_noun_ditransitive :=  sbj-obj-obj2-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS
			  < [OPT + ,
			     LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]], 
			    [OPT -,
			     LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].

suru_adv_ditransitive :=  sbj-obj-obj2-arg &
                    [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		     COMPS
			  < [OPT + ,
			     LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]], 
			    [OPT -,
			     LOCAL.CAT.HEAD adv_head] >].
;;
;; ERB&FCB restrict the complement's index to be an event (2009-02-18)
;; so that it won't become a dropped argument


ga-to_transitive1 := sbj-obj-arg  & 
 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
  COMPS  opt-1-arg &
       < [LOCAL [CAT.HEAD case-p_head & [CASE to],
		 CONT.HOOK.INDEX event ]] > ].

ga-to_transitive2 := sbj-obj-arg  & 
 [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >,
  COMPS opt-1-arg & 
       < [LOCAL [CAT.HEAD  case-p_head & [CASE to],
		 CONT.HOOK.INDEX event ]] >].


ga-to-ni_transitive1 := sbj-obj-arg  & 
 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
  COMPS opt-1-arg & 
       < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].

ga-to-ni_transitive2 := sbj-obj-arg &
 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
  COMPS obl-1-arg & 
       < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].



; sc-intr-lex := sc-sbj-arg-lex & 
;  [SYNSEM.LOCAL.CAT.VAL.SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].


intransitive := sbj-arg & 
                [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].



to_intransitive-opt := obj-arg  & 
                [COMPS opt-1-arg & 
			  < [LOCAL [CAT.HEAD case-p_head & [CASE to],
				    CONT.HOOK.INDEX event ]] >].


to_intransitive-obl := obj-arg &
                [COMPS obl-1-arg &
		       < [LOCAL [CAT.HEAD case-p_head & [CASE to],
				 CONT.HOOK.INDEX event ]] >].


ditransitive :=  sbj-obj-obj2-arg  & 
                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		  COMPS opt-2-args &
		       < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
			  [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].

; (MS 2004-11-15) This seems not to be used any more.

;ga-wo-to-ditransitive := sbj-obj-obj2-arg  &
;                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
;		  COMPS < [OPT + ,
;			   LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
;			  [OPT - ,
;			   LOCAL.CAT.HEAD case-p_head & [CASE to]] >].

ga-wo-toni-ditransitive := sbj-obj-obj2-arg   & 
                 [SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
		  COMPS < [OPT + ,
			   LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE wo]],
			  [OPT + ,
			   LOCAL.CAT.HEAD case-p_head & [CASE ni-or-to]] >].


; (MS 2003-12-23) Added CASE ni-or-ga for, e.g., ni - ga wakaru.

mental_state_transitive :=  sbj-obj-arg  & 
                    [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ni-or-ga]] >,
		     COMPS opt-1-arg &
			  < [LOCAL.CAT.HEAD case-p_head & [CASE ga-or-wo]] >].

aru_transitive :=  sbj-arg & 
           [SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].

cop_transitive := obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL [BAR +,
			   CAT [HEAD [COP-ARG +,MAIN-PRD -],
				VAL saturated]]] > ].


; (MS 2004-11-30) If the VAL of the na-adj is restricted to be saturated, 
; the relative-clause-gap-rules cannot be applied. Rather, the cop-stem should 
; take the subject of the na-adj.

cop-stem_transitive := sbj-obj-arg & 
                       [SUBJ #sbjval,
			COMPS obl-1-arg &
			      < [LOCAL [BAR +,
					     CAT [HEAD na-adj_head,
						  VAL.SUBJ #sbjval]]] > ].


; (ERB 2001-09-24) Experimenting with removing [BAR +] constraint
; on OBJ to allow Ns built out of NumClPs to be OBJ of id-cop desu
; and allow them as dtrs in compounds.

cop-id_transitive := sbj-obj-arg &
          [COMPS obl-1-arg &
		 < [LOCAL [CAT [HEAD noun_head,
				     VAL saturated]]] >,
		SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga-or-coparg]] > ].


; (ERB 2001-09-03) Changing light verbs to make them in charge of the
; valence of the vn+light verb combination.
; (MS 2001-09-14) Changing that back.
; (MS 2002-11-11) This one is going to be interesting!

light_transitive := valence &
            [SPR  obl-1-arg &
		 < [LOCAL [CAT [HEAD vn_head & [MAIN-PRD -],
				 VAL [SUBJ #sbj,
				      COMPS #comps]],
			    BAR -]] >,
	     SUBJ #sbj,
	     COMPS #comps].



; (MS 2004-11-18) Type for obj-id. The comps list of the specifier should be emptied.
; 私 が 先生 に 本 を 買っ て もらっ た

aux_transitive  :=  sbj-obj-spr-arg & 
          [SPR obl-1-arg &
	       < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
						 COP -,
						 VN -,
						 AUX aux_minus],
			      VAL [COMPS null]],
			 CONT.HOOK.XARG #ind,
			 NUCL nucl_plus]] >,
	   COMPS < [OPT + ,
		    LOCAL [CAT.HEAD case-p_head & [CASE ni],
			   CONT.HOOK.INDEX #ind]] >,
	   SUBJ < [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] > ].


; (ERB 2001-12-28) For VN + itadaku, etc.

light-aux_transitive  :=  valence & 
          [SPR obl-1-arg &
	       < [LOCAL [CAT [HEAD  vn_head & [MAIN-PRD -],
			     VAL [COMPS < #obj >,
				   SUBJ #subj]],
			 CONT.HOOK.XARG #arg1ind,
			 NUCL nucl_plus]]>,
	   COMPS < #obj,
		   [OPT + ,
		    LOCAL [CAT.HEAD case-p_head & [CASE ni],
			   CONT.HOOK.INDEX #arg1ind]] >,
	   SUBJ #subj].


; (MS 2004-06-25) Took the COMPS null restriction out to allow the rel-clause-obj-gap-rule to apply.
; And then took over the COMPS value from the verb to the auxiliary.
; (MS 2004-07-09) FORMAL.AHON - restriction on the SPR, to rule out "mashite"
; (MS 2004-11-05) AUX aux_minus on the specifier might be too strong: 読んでもらっている
; (MS 2004-11-17) This is valid for pure-aspect.
; (CH 2005-03-18)
; added [SPR.FIRST.LOCAL.CAT.HEAD.MOD null] to disallow te-adjunct
; in the SPR.
; 「で」 in 「読んでいる」 should be te-end-lex rather than te-adjunct.
pure-aspect_transitive :=  valence & 
 [SPR obl-1-arg &
      < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
					COP -,
					MOD null,
					VN -,
					AUX aux_minus_or_complex,
					FORMAL.AHON -],
		     VAL  [SUBJ  #sbj,
			   COMPS #obj]],
		NUCL nucl_plus]] >,
  SUBJ #sbj,
  COMPS #obj].

; (MS 2004-11-17) In aspect_transitive, we need to link the ARG2 of the verb to the ARG1 of
; the aspect aux.
 
aspect_transitive :=  sbj-spr-arg & 
                      [SPR obl-1-arg &
			   < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
							     COP -,
							     VN -,
							     AUX aux_minus_or_complex,
							     FORMAL.AHON -]],
				     NUCL nucl_plus]] >,
		       SUBJ  < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] > ].


 
perspective_transitive  :=  sbj-obj-spr-arg & 
                            [SPR obl-1-arg &
				 < [LOCAL [CAT [HEAD  verb_head & [MAIN-PRD -,
									COP -,
									VN -,
									AUX aux_minus],
						VAL [SUBJ #sbj,
						     COMPS null]]]] >,
			     SUBJ #sbj,
			     COMPS opt-1-arg &
				 < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].

; (ERB 2001-12-28) For VN + kureru etc.

light-perspective_transitive  :=  sbj-obj-spr-arg & 
				  [SPR obl-1-arg &
				 < [LOCAL [CAT [HEAD  vn_head & [MAIN-PRD -],
						      VAL [SUBJ < #sbjval >]],
						 BAR +]] >,
				   SUBJ < #sbjval  & [LOCAL.CAT.HEAD ga-or-wo-case-p_head & [CASE ga]] >,
				   COMPS opt-1-arg &
				       < [LOCAL.CAT.HEAD case-p_head & [CASE ni]] >].





sbj-narg_transitive := sbj-obj-arg & 
          [COMPS obl-1-arg &
		 < [LOCAL [CAT [HEAD noun_head,
				     VAL saturated]]] >,
                SUBJ < [LOCAL.CAT.HEAD case-p_head & [CASE ga]] >].
		       
                                 
    
;;;;;;;;;;;;;;LEXICAL TYPE -- unknown words;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

my_unknown_word := lexical_sign.

my_unknown_noun := my_unknown_word & ordinary-n-lex.

my_unknown_vn := my_unknown_word & vn-trans1-lex.

;;;;;;;;;;;;;;LEXICAL TYPES -- particles;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (ERB 2001-10-17) Some p-lex identify their KEY with their OBJ's
; and some don't, do I can't make the whole class lexical_sign-word.
; I'm going to make p-lex lexical_sign and make the subtypes that
; don't do key identification more specific.

p-lex := lexical_sign & 
 [SYNSEM [LOCAL [CAT [HEAD p_head-avm & [FORMAL.SHON #1, QUANTIFIABLE #2],
		      VAL p_sat & [COMPS #comps & 
					 < [LOCAL [CAT.HEAD [FORMAL.SHON #1,
							     QUANTIFIABLE #2]]] >]],
		 CTXT.BACKGROUND <! !>,
		 BAR +,
		 ARG-S #comps],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]],
  INFLECTED +].

; (FCB 2006-05-02) move this down to do the wierd numeral-clasifier の
; DPF maybe this linkage could be revised


p-lex-norm := p-lex &
 [SYNSEM.LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #ind,
		 CONT.HOOK.XARG #ind]].
  
; (ERB 2001-10-17) This is the supertype for p-lex's that don't
; identify their KEY with their OBJ's KEY.  Name means p-lex-contentful.



p-lex-c := p-lex-norm & lexical_sign-word.

; (ERB 2001-11-26) Identification of CONT.KEY.HANDEl and LTOP is
; redundant, since both LTOP and KEY are coming from the complement.

; (MS 2005-06-20) FORMAL should come from the complement.


case-p-lex := p-lex-norm & 
 [SYNSEM [LOCAL [CAT [HEAD overt-case-p_head & [FORMAL #formal],
		      VAL.COMPS < [LOCAL [CAT.HEAD.FORMAL #formal,
					  CONT [HOOK [INDEX #arg, 
						      LTOP #hand]]]] >],
		 CONT [HOOK [INDEX #arg, 
			     LTOP #hand],
;		       RELS <! !>,
		       HCONS <! !>]]]].


; (MS 2005-05-06) renamed ga-wo-ni-p-lex (cleaning up particles).

case-p-lex-np := case-p-lex & 
[SYNSEM [NON-LOCAL.UNDERSPEC_ARG -,
	  LOCAL [CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head,
		 CONT.RELS <!  !>]]].


; (MS 2005-11-10) getting rid of skip files.


; <type val="case-p-lex-np-coparg">
; <name-ja>記号主格
; <description>case-p-lexの「が」と同じような役割をする記号。ただしこのtypeは、verbの格になることができない。
; 「写真 ： 馬 だ」のような文を解析するためのtypeだが、現実の文では「だ」などcopulaを伴わない場合がほとんど。
; <ex>写真 ： 馬
; <nex>
; <todo>(TK 07-04-04)実際には「写真 ： 馬」のように、copulaがない文でも解析できるようにすべき。
; (TK 07-04-04)また、リストのようなものだと「本田 ： 行く 、 川崎 ： 行か ない 、 鈴木 ： 不明」や、
; 「メニュー ： 多い 、 値段 ： 安い 、 店員 ： 明るい」のような使い方もあり得るのではないか。
; </type>
case-p-lex-np-coparg := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE coparg].

; <type val="case-p-lex-np-ga">
; <name-ja>承名詞主格助詞
; <description>名詞の直後について、主格を表す助詞「が」。このtypeによってその名詞は各種用言・助動詞
; の主語(ARG1)となることができる。受動態・可能態では、見た目は主格だが、実際の行為の目的格(ARG2)
; となる。
; <ex>犬 が 走る
; <ex>バナナ が 猿 に 食べ られる
; <ex>犬 に 芸 が できる か
; <nex>彼 は 帰っ た が
; <todo>
; </type>
case-p-lex-np-ga := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ga].

; <type val="case-p-lex-np-wo">
; <name-ja>承名詞目的格助詞ヲ
; <description>名詞の直後について、目的格を表す助詞「を」。このtypeによってその名詞は動詞の目的語
; (ARG2)となることができる。
; <ex>子供 が 本 を 買う
; <nex>ボール が 落ち て き た ところ を キャッチ する
; <todo>(07-03-30)場所や状況を表す「を」も必要。(lkb::do-parse-tty "砂漠 を 行く 旅人")
; (lkb::do-parse-tty "ボール が 落ち て き た ところ を キャッチ する")
; </type>
case-p-lex-np-wo := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE wo].

; <type val="case-p-lex-np-to">
; <name-ja>承名詞目的格助詞ト
; <description>case-p-lex-np-woを参照。このtypeは助詞「と」。
; <ex>部長 と 会う
; <nex>ゆっくり と 進む
; <todo>
; </type>
case-p-lex-np-to := case-p-lex-np &
 [SYNSEM.LOCAL.CAT.HEAD.CASE to].

; <type val="case-p-lex-np-kara">
; <name-ja>承名詞受身主格助詞
; <description>名詞の直後について、受身文の主格（実際にその行為を行うもの）を表す助詞「から」。
; <ex>子供 が 親 から たしなめ られる
; <nex>友人 から 自転車 を 買う
; <todo>(07-03-30)間接受身でも使えるようにすべき。(lkb::do-parse-tty "親戚 から 怒ら れる")
; (07-03-30)「〜」はこのtypeでよいのか？（格として取ることがないため）
; (07-03-30)postp-lexの後につくtypeも必要。(lkb::do-parse-tty "子供 が 親 とか から たしなめ られる")
; </type>
case-p-lex-np-kara := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE kara-case].

; <type val="case-p-lex-np-ni">
; <name-ja>承名詞与格助詞
; <description>名詞の直後について、与格を表す助詞「に」。このtypeによってその名詞は、ditransitiveなど
; では間接目的語としてARG3に入り、v2-stem,v6-stemなどでは直接目的語としてARG2に入り、受動態・使役
; 態・可能態では実際の行為の主体として動詞のARG1に入る（ただし可能態の場合は格として取られ
; ないことがある）。
; <ex>犬 に 餌 を 与える
; <ex>車 に 乗る
; <ex>バナナ が 猿 に 食べ られる
; <ex>母 が 子供 に 宿題 を さ せる
; <ex>犬 に 芸 が できる か
; <nex>朝 に 餌 を 与える
; <todo>
; </type>
case-p-lex-np-ni := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE ni].

; <type val="case-p-lex-np-no">
; <name-ja>承名詞ノ主格助詞
; <description>名詞の直後について、主格を表す助詞「の」。case-p-lex-np-gaの「が」と同じようなものだが、
; relative clauseの場合にしか出ないという部分で違いがある。
; <ex>車 の ある 家
; <nex>大阪 の ある 地域
; <todo>(TK 07-03-29)受動態も作れるようにすべき(lkb::do-parse-tty "勢い の 失わ れ た チーム")
; (TK 07-03-29)「na-adj-lex+reg-cop-stem-lex」も解析できるようにすべき。
; (lkb::do-parse-tty "音 の 静か な 機械")
; (TK 07-03-29)pred-adj-lexがある場合でも解析できるようにすべき。
; (lkb::do-parse-tty "顎 の 大きな 芸人")
; (TK 07-03-29)可能態で、「が」格と「を」格を変換できるようにすべき。
; (lkb::do-parse-tty "納豆 の 食べ られる 人")(lkb::do-parse-tty "手話 の できる 人")
; (TK 07-03-29)「が」のcase-p-lex-postp-gaにあたるようなtypeも必要。
; (lkb::do-parse-tty "車 とか の ある 家")
; </type>
case-p-lex-np-no := case-p-lex-np &
			[SYNSEM.LOCAL.CAT.HEAD.CASE no-case].

; (MS 2005-05-11) This is the topic marker that replaces case particles,
; such that we have massive ambiguity whenever case particles occur. 

case-p-lex-np-topic := case-p-lex & 
 [SYNSEM [LOCAL [CAT.VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head],
		CONT [HOOK [INDEX #arg, 
			    LTOP #hand],
		      RELS <! #key & prep-mod-relation & [PRED focus_d_rel,
						   LBL #hand, 
						   ARG1 event,
						   ARG2 #arg,
						   ARG0.E.TENSE no_tense] !>]],
	  LKEYS.KEYREL #key]].

; (MS 2005-05-13) It sets empathy to the entity it attaches to.
; (FCB 2008-06-23) taking of the empathy as it blocks:  
; (lkb::do-parse-tty "猿 は 私 の 犬 を 食べる")
; FIXME:  I should debug this more fully.

case-p-lex-np-topic-ga := case-p-lex-np-topic &
		       [SYNSEM.LOCAL [CAT.HEAD.CASE ga]].
;				      CONT.HOOK.XARG #emp,
;				      CTXT.EMPATHY.EMPEE #emp]].

; (MS 2005-09-22) It sets empathy to the entity it attaches to, only
; when it is case ga! If it is a case of object topicalization, the 
; empathy is rather set to the sentence subject (see Watanabe 2000)

case-p-lex-np-topic-wo := case-p-lex-np-topic &
		       [SYNSEM.LOCAL.CAT.HEAD.CASE wo].

; (MS 2005-04-07) It seems that we don't need these any more.
; adverb +  case particle is elliptical or ungrammatical, as the NTT
; people say.

;ga-wo-ni-p-lex-2 := case-p-lex & 
;                  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [CAT.HEAD adv_head,
;							   CONT.HOOK.INDEX event]].

;(MS 2002-1-7) restricted this to postpositions, in order to keep NO GA out.
; (MS 2004-06-25) INDEX and XARG must be the same, otherwise the phrase cannot be selected for.
; (MS 2005-05-06) renamed ga-wo-ni-p-lex-3 (cleaning up particles).

case-p-lex-postp := case-p-lex & 
 [SYNSEM.LOCAL [CONT [HOOK.INDEX #ind,
		      RELS <! !>,
		      HCONS <! !>],
		CAT.VAL.COMPS.FIRST.LOCAL [CONT.HOOK.XARG #ind,
					   CAT.HEAD postp_head & [PTYPE nontop,
								  CASE mod]]]].

; <type val="case-p-lex-postp-ga">
; <name-ja>承連用助詞主格助詞
; <description>「名詞or動詞+postp-lex」の形の直後について、主格を表す助詞「が」。case-p-lex-np-gaを参照。
; <ex>犬 まで が 走る
; <ex>バナナ まで が 猿 に 食べ られる
; <ex>犬 に 芸 とか が できる か
; <nex>彼 は 帰っ た が
; <todo>
; </type>
case-p-lex-postp-ga := case-p-lex-postp &
 [SYNSEM.LOCAL.CAT.HEAD.CASE ga].

; <type val="case-p-lex-postp-wo">
; <name-ja>承連用助詞目的格助詞
; <description>「名詞or動詞+postp-lex」の形の直後について、目的格を表す助詞「を」。case-p-lex-np-woを参照。
; <ex>子供 が 本 とか を 買う
; <nex>川 とか 海 とか を 泳ぐ
; <todo>case-p-lex-np-woを参照。
; </type>
case-p-lex-postp-wo := case-p-lex-postp &
 [SYNSEM.LOCAL.CAT.HEAD.CASE wo].

; <type val="case-p-lex-postp-ni">
; <name-ja>承連用助詞与格助詞
; <description>「名詞or動詞+postp-lex」の形の直後について、与格を表す助詞「に」。case-p-lex-np-niを参照。
; <ex>期限 が 明日 まで に なる
; <ex>船 とか に 乗る
; <nex>明日 まで に 終わる
; <todo>
; </type>
case-p-lex-postp-ni := case-p-lex-postp &
 [SYNSEM.LOCAL.CAT.HEAD.CASE ni].


; (MS 2005-05-06) renamed to-case-lex (cleaning up particles).
; BUT I really don't know what this is for. Commented it out until
; I can find a good example.
;case-p-lex-vmodp := case-p-lex & 
;                  [SYNSEM.LOCAL [CONT.HOOK.INDEX #ind,
;				 CAT.VAL.COMPS.FIRST.LOCAL [CONT.HOOK.XARG #ind,
;							    CAT.HEAD vmod-p_head & [PTYPE nontop]]]].

; "何日くらいかかるかを教える"
; (MS 2003-12-19) Matrix 0.6
; (MS 2005-05-06) This is rather a complementizer. Took that out and gave the o-4 the type
; comp-prpstn-lex.
;ga-wo-ni-p-lex-4 := comp-prpstn-lex &
;		    [SYNSEM.LOCAL [CAT [HEAD case-p_head,
;					VAL.COMPS.FIRST [LOCAL [CONT.HOOK.LTOP #ohand,
;								CAT.VAL saturated]]],
;                          CONT [RELS <! message &
;				      [PRED proposition_m_rel,
;				       LBL #chand,
;				       MARG #soa] !>,
;                                HOOK.LTOP #chand,
;                                HCONS <! qeq & [LARG #ohand,
;                                                 HARG #soa] !>]]].


; (MS 2005-05-06) We seem not to need this any more, as the ni-case-5 is replaced with
; naadj2adv-end-lex.
;ga-wo-ni-p-lex-5 := case-p-lex & 
;                  [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2005-05-06) renamed particles (case-p-lex-np and case-p-lex-vmodp).
;to-case-lex := case-p-lex.

; (ERB 2002-02-14) This should take the LTOP of its OBJ for the LARG
; handle, not KEY.LBL.  (Problem was embedded conjoined sentences where
; KEY comes from right conjunct, but LTOP comes from conjunction.)


comp-lex-basic := p-lex-c &
 [SYNSEM.LOCAL [CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [LTOP #vhand,
						     INDEX #ind],
		CONT [RELS  <!  !>,
		      HOOK [LTOP #top,
			    INDEX #ind],
		      HCONS <! qeq & [HARG #top, LARG #vhand ] !>]]].

comp-lex := comp-lex-basic &
 [SYNSEM.LOCAL.CAT.HEAD case-p_head & [CASE to]].

comp-prpstn-lex := comp-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF prop].


; (MS 2005-11-10) getting rid of skip files.

; <type val="comp-prpstn-lex-sentarg">
; <name-ja>承陳述文目的格助詞
; <description>propositionを持つ文を受ける助詞。このtypeによってその文は動詞のARG2となる。
; 多くのtransitive（verbstem-lexもvn-lexも）にかかることができるが、実際には「かもしれない」
; 「かも分からない」など、用法は限定される。
; <ex>行く かも 分から ない
; <nex>人間 かも 分から ない
; <nex>大丈夫 かも 分から ない
; <todo>(TK 07-04-06)かかることのできる動詞を「知れる」「分かる」などに限定すべき。
; だが現状ではこのtypeは「知れる(v2-v-stem-lex)」にかかることができない。
; (TK 07-04-06)また、名詞を受けるtypeがない。(lkb::do-parse-tty "人間 かも 分から ない")
; </type>
comp-prpstn-lex-sentarg := comp-prpstn-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD sentence-valid].

; <type val="comp-prpstn-lex-naarg">
; <name-ja>承陳述形容動詞目的格助詞
; <description>comp-prpstn-lex-sentargを参照。ただしこのtypeはna-adj-lexを受ける。
; その際にna-adj-lexにpropositionを付与して、「na-adj-lex+だ(reg-cop-stem-lex)」の場合と同じ解析
; にする。
; <ex>大丈夫 かも 分から ない
; <nex>人間 かも 分から ない
; <nex>行く かも 分から ない
; <todo>(TK 07-04-06)comp-prpstn-lex-sentargを参照。
; </type>
comp-prpstn-lex-naarg := comp-prpstn-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].


; <type val="comp-prpstn-lex-questarg">
; <name-ja>承疑問陳述ヲ目的格助詞
; <description>疑問文のproposition(question_m)を持つs-end-lexで終止する文を受けて、ga-to_transitive
; （v3-stem-lexなど）にかかる助詞「を」。このtypeによってその文はga-to_transitiveのARG2となる。
; <ex>行く か を 聞く
; <nex>道 を 聞く
; <todo>
; </type>
comp-prpstn-lex-questarg := comp-prpstn-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD sap_head & [SMOD quest]].

; <type val="comp-prpstn-lex-questarg-to">
; <name-ja>承疑問陳述ト目的格助詞
; <description>comp-prpstn-lex-questargを参照。このtypeは助詞「と」。
; <ex>行く か と 聞く
; <nex>行く と 聞く
; <todo>
; </type>
comp-prpstn-lex-questarg-to := comp-prpstn-lex-questarg &
 [SYNSEM.LOCAL.CAT.HEAD.CASE to].

comp-prpstn-lex-quotarg := comp-prpstn-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD quotation-sentence-end_head].

;(TK 09-03-09 commentout)
; <type val="comp-prpstn-lex-varg">
; <name-ja>承動詞陳述ト目的格助詞
; <description>propositionをもつ語（文）の直後につく助詞。このtypeによってpropositionをもつ語（文）は
; 「と」格を取る動詞のargumentになることができる。
; <ex>
; <ex>
; <nex>
; <todo>(TK 07-04-06)comp-prpstn-lex-vargを選んでもcomp-prpstn-lex-quotを選んでもMRSに差が出ない。
; この２つを一緒にするか、もっと区別をはっきりさせるべき。
; </type>
;comp-prpstn-lex-varg := comp-prpstn-lex &
; [SYNSEM.LOCAL.CAT [HEAD.CASE to,
;		    VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [VN -, 
;								MAIN-PRD -]]].

; <type val="comp-prpstn-lex-quot">
; <name-ja>承引用陳述ト目的格助詞
; <description>comp-prpstn-lex-vargを参照。このtypeはpropositionをもつ語（文）にUTTERANCE_RULEがついた
; ものも受けることができる。
; <ex>
; <ex>
; <nex>
; <todo>(TK 07-04-06)comp-prpstn-lex-vargを参照。
; </type>
comp-prpstn-lex-quot := comp-prpstn-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.CASE to].

; (MS 2005-05-09) I don't see why we need this: a copula is inserted
; even with the comp-prpstn-lex.
;comp-copinsert-lex := p-lex-c &
;            [SYNSEM [LOCAL [CAT [HEAD case-p_head & [CASE to],
;                                VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
;						       CONT.HOOK [INDEX #oind]]],
;                          CONT [RELS <! message & #key & [LBL #phand,
;							  MARG #soa], 
;				            [PRED 'cop_id_rel,
;					     ARG2 #oind,
;					     LBL #cophand] !>,
;                                HOOK.LTOP #phand,
;                                HCONS <! qeq & [LARG #cophand,
;                                                 HARG #soa] !>]],
;		     LKEYS.KEYREL #key]].

; (ERB 2002-02-11) Hack to keep these guys out of the ordinary
; head-complement-hf rule, now that I've made the embedded-question-rule
; a binary rule (see notes at embedded-question-rule-type):  Make
; them be MSG.LIST nelist, while hcomp-hf requires MSG.LIST elist.
; In the long run, the right analysis probably involves revamping the
; analysis of clauses in this grammar so that we can have a better theory
; of embedded clause types.  That overhaul will cause this hack to no
; longer work, but it should also render it unnecessary.

comp-int-lex := comp-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX.SF ques].


; (MS 2005-11-10) getting rid of skip files.

comp-int-lex-varg := comp-int-lex &
		     [SYNSEM.LOCAL.CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [MAIN-PRD -]]].

comp-int-lex-naarg := comp-int-lex &
		     [SYNSEM.LOCAL.CAT [HEAD.CASE to,
					VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head]].

comp-int-lex-nonquest := comp-int-lex &
		     [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.QUE <! !>].

comp-int-lex-naarg-nonquest := comp-int-lex-naarg & comp-int-lex-nonquest.

comp-int-lex-varg-nonquest := comp-int-lex-varg & comp-int-lex-nonquest.


comp-int-lex-unmarked := comp-int-lex &
 [SYNSEM.LOCAL.CAT [HEAD.CASE to,
		    VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [SMOD unmarked]]].



; (MS 2003-12-19) Matrix 0.6
; (MS 2005-11-09) These all have PTYPE nattr.

nspec-p-lex  :=  p-lex-c & 
 [SYNSEM [LKEYS.KEYREL #key,
	  LOCAL [CAT [HEAD nspec-p_head & [J-SPEC.FIRST [LOCAL.CONT.HOOK [INDEX #i,
									  LTOP #h]],
					   PTYPE nattr],
		      VAL.COMPS.FIRST.LOCAL [CONT [HOOK.INDEX #arg],
					     CAT.VAL saturated]],
		 
		     CONT [HOOK.INDEX #arg,
			   RELS <! #key & quant-relation & [PRED udef_q_rel,
							    ARG0 #i,
							    RSTR #restr]!>,
			   HCONS <! qeq &
				  [HARG #restr,
				   LARG #h] !>]]]].

; (MS 2005-11-09) Getting rid of skip files.

; <type val="nspec-p-nouncomp-lex">
; <name-ja>承名詞助詞サ変修飾
; <description>名詞（vn-lexを含む）の後につき、vn-lexを修飾する助詞の「の」。「の」の前にある名詞
; を後ろvn-lexのargumentとして取りたい場合に使う。
; <ex>身辺 の 調査
; <ex>医者 の 診察
; <nex>調査 の 結果
; <todo>
; </type>
nspec-p-nouncomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head].

; <type val="nspec-p-pcomp-lex">
; <name-ja>承連用助詞助詞サ変修飾
; <description>postp-lexの後につき、vn-lexを修飾する助詞の「の」。postp-lexの前にある名詞
; （vn-lexを含む）を後ろvn-lexのargumentとして取りたい場合に使う。しかし、現状ではうまく
; argumentが取れていないように見える。
; <ex>部下 から の 報告
; <ex>弟 と の 喧嘩
; <nex>会社 から の 帰宅
; <nex>チョップ から の キック
; <todo>(TK 07-03-28)一部のpostp-lex（「から」など）ではうまくargumentが取れない
; </type>
nspec-p-pcomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD postp_head].

nspec-p-vcomp-lex := nspec-p-lex &
			[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & 
									 [H-TENSE te,
									  VN -]].



; (ERB 2001-11-28) Making all Ps intersective modifiers.

mod-p-lex :=  p-lex-c & 
            [SYNSEM.LOCAL.CAT.HEAD mod-p_head-avm &
				   [ MOD < [LOCAL intersective-mod] > ]].


nmod-p-lex :=  mod-p-lex & 
            [SYNSEM [LOCAL.CAT.HEAD overt-nmod-p_head,
                     MODIFIED.PERIPH -]].

; (MS 2005-11-09) Getting rid of skip files.
;; FIXME doesn't scope (isn't used?)

nmod-p-lex-pconj := nmod-p-lex &
 [SYNSEM [LOCAL [CAT [HEAD [MOD < [LOCAL.CONT [HOOK.INDEX #mod]] >,
			    J-POSTHEAD left],
		      VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD p_head & [PTYPE nontop,
									  CASE mod],
						       CONT [HOOK.INDEX #arg]]]],
		 CONT n-conj-sem-type],
	  LKEYS [KEYREL [L-INDEX #arg,
			 R-INDEX #mod]]]].


;(MS 2005-05-14) This is not used any more. The parentheses do not build the heads.
;parmod-p-lex :=  mod-p-lex & 
;            [SYNSEM [LOCAL.CAT.HEAD nmod-p_head-avm & [MOD < [LOCAL.CAT [HEAD brackets-or-quotations-end_head,
;									 VAL saturated]] > ],
;                     MODIFIED.PERIPH bool]].



conj-lex := p-lex-c &
              [SYNSEM [LOCAL [CAT.HEAD n_conj_head],
		       MODIFIED.PERIPH bool]].

nounmod-p-lex := nmod-p-lex &
                 [SYNSEM [LKEYS.KEYREL #key & prep-mod-relation &
					  [LBL #handle,
					   ARG0.E.TENSE no_tense,
					   ARG1 #mod,
					   ARG2 #arg],
			  LOCAL [CAT [HEAD.MOD < [LOCAL.CONT.HOOK [INDEX #mod,
								   LTOP #handle]] >,
				      VAL.COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #arg]],
				 CONT prep-sem-type &
				     [RELS <! #key !>,
				      HOOK.INDEX #mod,
				      HCONS <! !>]]]].

;(MS 2005-11-09) Getting rid of skip files.

nounmod-p-vcomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head].

nounmod-p-vcomp-quest-lex := nounmod-p-vcomp-lex &
		       [SYNSEM.LOCAL [CAT.VAL.COMPS.FIRST [LOCAL.CAT.HEAD [MODUS uttmodus,
									   FIN +,
									   FORMAL.AHON -,
									   MAIN-PRD +],
							   NON-LOCAL.QUE <! #top !>],
				      CONT.HOOK.LTOP #top]].

; <type val="nounmod-p-vcomp-prepmod-lex">
; <name-ja>承用言助詞名詞修飾
; <description>用言や助動詞の終止形、過去形、否定形などを受けて、名詞にかかっていく助詞。
; <ex>暗い という 道
; <ex>分かっ た という 声
; <ex>社長 だ という 人
; <nex>
; <todo>
; </type>
nounmod-p-vcomp-prepmod-lex := nounmod-p-vcomp-lex &
			       [SYNSEM.LKEYS.KEYREL prep-mod-relation].

; <type val="nounmod-p-ncomp-lex">
; <name-ja>承名詞助詞名詞修飾
; <description>名詞（vn-lexを含む）の直後について名詞（vn-lexを含む）を修飾する助詞。
; <ex>女性 による 日記
; <ex>バイク による 暴走
; <nex>
; <todo>
; </type>
nounmod-p-ncomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST synsem & [LOCAL.CAT.HEAD noun_head]].

; <type val="nounmod-p-ncomp-prepmodrel-lex">
; <name-ja>承名詞助詞名詞修飾
; <description>nounmod-p-ncomp-lexを参照。このtypeは
; <ex>猫 の 手
; <ex>試験 の 結果
; <nex>物体 の 落下
; <todo>
; </type>
nounmod-p-ncomp-prepmodrel-lex := nounmod-p-ncomp-lex &
			     [SYNSEM.LKEYS.KEYREL prep-mod-relation].

nounmod-p-ncomp-vnmod-lex := nounmod-p-ncomp-lex &
			     [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD.VN +] >,
				      LKEYS.KEYREL prep-mod-relation]].

; <type val="nounmod-p-ncomp-relmod-lex">
; <name-ja>承名詞助詞関係名詞修飾
; <description>名詞（vn-lexを含む）の直後についてrelational-n-lexのみを修飾する助詞。
; <ex>公開 より 前 に 見る
; <nex>予定 より 遅れる
; <todo>
; </type>
nounmod-p-ncomp-relmod-lex := nounmod-p-ncomp-lex &
			     [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD relational_noun_head] >,
				      LKEYS.KEYREL prep-mod-relation]].

; <type val="nounmod-p-exc-ncomp-lex">
; <name-ja>承形容動詞化形式名詞助詞名詞修飾
; <description>nom-exceptional-lexの直後について、後の名詞（vn-lexを含む）を修飾する助詞。
; 日本語で一般的に助動詞とされる「ようだ」の連体形である「ような」の一部か？
; <ex>あの よう な 人
; <ex>暖かい よう な 気 が する
; <ex>夢 の よう な 生活
; <nex>器用 な 人
; <todo>
; </type>
nounmod-p-exc-ncomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL.CAT.HEAD exceptional_noun_head]]].


nounmod-p-ncomp-plusbar-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD noun_head,
									   BAR +]]]].

nounmod-p-intcomp-lex := nounmod-p-lex &
		       [SYNSEM.LOCAL.CAT [HEAD.PTYPE nattr,
					  VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD int_head,
									   BAR +]]]].

; <type val="nounmod-p-pcomp-lex">
; <name-ja>承連用助詞助詞名詞修飾
; <description>postp-lexやadv-p-lexの直後につき、名詞（vn-lexを含む）を修飾する助詞。
; <ex>会場 で の 飲食
; <ex>先生 から の 本
; <nex>私 の 本
; <todo>
; </type>
nounmod-p-pcomp-lex := nounmod-p-lex &
 [SYNSEM [LOCAL [CAT [HEAD.PTYPE nattr,
		      VAL.COMPS.FIRST synsem & [LOCAL [CAT.HEAD vmod-p_head  & [PTYPE nontop],
						       CONT.HOOK.XARG #1,
						       BAR +]]],
		 CONT.RELS <! prep-mod-relation & [PRED "_no_p_rel"] !>],
	  LKEYS.KEYREL.ARG1 #1]].



;(MS 2005-05-14) This is not used any more. The parentheses do not build the heads.

;parentmod-p-lex := parmod-p-lex &
;                 [SYNSEM [LKEYS.KEYREL #key & prep-mod-relation &
;                                         [ARG2 #mod, 
;					  ARG0.E.TENSE no_tense,
;                                          LBL #handle,
;                                          ARG1 #arg],
;			  LOCAL [CAT [HEAD.MOD <[LOCAL.CONT.HOOK [INDEX #mod,
;								  LTOP #handle]]>,
;				      VAL.COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #arg]],
;				 CONT prep-sem-type &
;				     [RELS.LIST.FIRST #key,
;				      HOOK.INDEX #mod,
;				      HCONS <! !>]]]].

; (ERB 2001-08-09) Type for the "no" that connects NumClP to nouns
;  e.g.: X CL の NOUN
; (MS 2002-09-10) This should also hold for "〜".
; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-27) Work on floated numeral classifiers
; (MS 2005-01-07) Using EMPTY to prevent floated quantifiers to go into the nominal-numcl-rule.
; <type val="nmod-numcl-p-lex">
; <name-ja>承助数詞助詞名詞接続
; <description>「数詞+助数詞」の形を受けて、名詞にかけるための助詞。このtypeによって数詞と名詞を関係
; づけることができる。関係づけたくない場合は別の助詞を使う。
; <ex>５ 人 の 老人
; <ex>５ リットル の ガソリン
; <nex>５ 階 の 会議室 に 集合 する
; <todo>
; </type>
nmod-numcl-p-lex := p-lex &
 [ SYNSEM [LOCAL [ CAT [ VAL.COMPS.FIRST.LOCAL[ CAT.HEAD num-cl-mod_head &
						       [EMPTY +],
					       CONT.HOOK #hook],
			HEAD overt-nmod-p_head &
					       [PTYPE overt,
						MOD < [LOCAL intersective-mod &
							     [CONT.HOOK.INDEX #NOUN]] >,
						J-SPEC null ]],
		   CONT [ HOOK #hook & [XARG #NOUN] ,
			  RELS <! !>,
			  HCONS <! !> ]],
	   MODIFIED.PERIPH -]].



; (ERB 2001-09-03) Adding constraint that the INDEX of vmod-p-lex be
; the same as the MOD...INDEX.

; (ERB 2001-09-03) If the topic relation is to take an event as the
; value of ARG2, it can't inherit this constraint on the sem type.
; So, I'll create a super type that does contain all the constraints
; that topic particles have in common with other vmod ps.  It also
; can't inherit the constraint that it's getting the ARG2 value from
; it's object's INDEX.

; (ERB 2001-09-06) We decided that topic shouldn't take an ARG2 at all.
; But that still means it can't inherit the constraint on the sem type.

; (ERB 2001-09-06) On this new analysis of wa, it can't identify its
; INDEX with its ARG, since the ARG will be the noun it attaches to
; in some cases and that can't unify with the event of the verb it
; modifies.  Likewise, we don't want the event of a PP modified by
; wa to be the same as the event of the main verb.  The confusing thing
; here is that wa is syntactically modifying the main verb and semantically
; modifying the NP or PP it attaches to.  Can't simply make it a syntactic
; modifier of NP because that NP won't be able to attach to the verb.
; Instead, I'm moving the constraint about INDEX=ARG to prep-sem-type.
; and saying something different about wa.

; (ERB 2001-10-01) It turns out that making topic-rel arg_rel only
; leads to MRSs that don't scope when wa marks NPs.  So, going back to
; having ARG = event of MOD and ARG2 = index of OBJ.

; (ERB 2001-10-03) It's not true of wa that OBJ.INDEX = ARG2.  Moving
; that to vmod-p-lex.


; (ERB 2002-01-10) Experimenting with treating particle uses of
; など as topic markers with some extra content.  For this purpose,
; I need to allow for RELSs of more than one relation on vmod-p-lex-super.


vmod-p-lex-super := mod-p-lex & 
            [SYNSEM [LKEYS.KEYREL #key,
		     LOCAL [ CAT [ HEAD vmod-p_head-avm &
                                       [MOD < [LOCAL.CONT.HOOK [LTOP #hand,
								INDEX #mind]] > ]],
                            CONT [ HOOK [LTOP #hand],
                                   RELS <! #key & [ARG1 #mind] !>,
                                   HCONS <! !>]]]].

; (ERB 2001-09-13) Other than wa, these guys are intersective modifiers.
; (ERB 2001-10-01) Try making wa an intersective modifier, too.

vmod-p-lex :=  vmod-p-lex-super & 
            [SYNSEM [LKEYS.KEYREL prep-mod-relation & [ARG1 #ind,
						       ARG2 #arg,
						       ARG0.E.TENSE no_tense],
		     LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #arg,
			     CONT prep-sem-type &
					     [HOOK.INDEX #ind]]]].

; (MS 2005-11-10) getting rid of skip files.

vmod-p-lex-parentarg := vmod-p-lex &
			[SYNSEM.LOCAL.CAT [HEAD postp_head,
					   VAL.COMPS.FIRST.LOCAL.CAT.HEAD parent-end_head]].


vmod-p-lex-vtearg := vmod-p-lex &
		     [SYNSEM.LOCAL.CAT [HEAD postp_head,
					VAL.COMPS.FIRST.LOCAL.CAT [HEAD verb_head & [FIN -,
										     VN -],
								   VAL saturated]]].

vmod-p-lex-narg := vmod-p-lex &
		   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head].

vmod-p-lex-parg := vmod-p-lex &
		   [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE postp-case]].


; (MS 2005-05-10) Not used any more.
;uttmod-p-lex  :=  mod-p-lex & 
;                  [SYNSEM.LOCAL.CAT.HEAD uttmod-p_head].

postp-lex-general := vmod-p-lex &
             [SYNSEM.LOCAL.CAT.HEAD postp_head].

postp-lex := postp-lex-general & 
             [SYNSEM.LOCAL [CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head,
			    CONT.RELS <! relation !>]].


postp-lex-varg := postp-lex-general & 
             [SYNSEM.LOCAL.CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [FORMAL.AHON -, 
									   MODUS indicative,
									   MAIN-PRD -]]].

;(MS 2004-06-25) This is for the second conjunction in, e.g. "犬と猫とがいます"
; to avoid spurious ambiguity in "犬と猫といます", I use the trick with the empty RELS
; on MOD.
; (MS 2005-06-02) This second conjunction should not add to the MRS. Therefore, it
; belongs under mod-p-lex in the type hierarchy, adding an empty RELS list. The head
; should be postp_head, such that it can be subcategorized for by case particles.

postp-lex-coord := mod-p-lex & 
             [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
						       CONT.HOOK.INDEX conj-ref-ind & #ind],
				 HEAD postp_head & [MOD.FIRST.LOCAL.CONT.RELS <! !>]],
			    CONT [HOOK.INDEX #ind,
				  RELS <! !>,
				  HCONS <! !>]]].

postp-lex-ahon := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

postp-lex-main := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

postp-lex-sub := postp-lex &
		  [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].

postp-lex-robust := postp-lex &
		  [SYNSEM.NON-LOCAL.ROBUST +].




; (ERB 2001-08-30) I need to fix wa-parg so that it identifies the INDEX of its OBJ's MOD
; with the INDEX of it's own MOD.  In the process, I'm moving the further constraints on that
; type to a subtype here (from the instance in p-lex).

; (ERB 2001-09-03) Fixing this so that the ARG2 of wa is the KEY.ARG0 of 
; de (in dewa), not the INDEX, which is identified with #modind (which would
; lead to ARG and ARG2 having the same value.  This led to changing the
; definition of topic-rel so that its ARG2 can take an event as its value,
; and to undoing the constraint that this belong to prep-sem-type, which
; requires a prep-mod-rel as the KEY.  This, in turn, means that topic-vmod-p-lex
; isn't a subtype of vmod-p-lex.

; (ERB 2001-09-03) Adding constraint that the handles of wa and its OBJ should be
; the same.  Don't think anything could scope in there.

; (ERB 2001-09-06) Unlike other Ps, wa is semantically modifying the
; NP or PP it attaches to.  So it must not identify ARG & INDEX.  Instead
; it passes up it's MOD's INDEX.

; (ERB 2001-09-13) Because it's semantically modifying its object, it must
; also identify its LTOP with OBJ.LTOP.

; (ERB 2001-09-26) All of the sudden, "dono X wa" isn't parsing.  I don't
; think that wa or dono have been changed since last time it was working,
; but to make it work, I'm going to remove the constraint that wa only
; take QUE <! !> objects.

; (ERB 2001-09-27) Makino & Tsutsui claim that (topic) wa can't mark
; wh NPs, and Atusko confirms this.  However, contrastive wa can mark
; PPs, at least, as shown in the following:
;
; どの口座には利息がつきますか。
;
; Since we don't have a distinction between topic and contrastive wa,
; let wa modify QUE ne things for now.

; (ERB 2001-10-01) It turns out that making topic-rel arg_rel only
; leads to MRSs that don't scope when wa marks NPs.  So, going back to
; having ARG = event of MOD and ARG2 = index of OBJ.  Undoing constraints
; associated with having ARG = index of OBJ.
; Now ARG1 = index of OBJ (because we swapped ARG1 and 2: FCB)

; (MS 2005-05-11) In cleaning up particles, renaming topic-vmod-p-lex.
; (MS 2005-05-13) Topic particles should set speaker empathy.

topic-p-lex := vmod-p-lex-super &
                    [SYNSEM [LKEYS.KEYREL prep-mod-relation &
					[ ARG1 #ind,
					  ARG0.E.TENSE no_tense ],
			     LOCAL [ CAT [ HEAD topic-vmod-p_head ],
				     CONT topic-sem-type  &
					 [HOOK.INDEX #ind,
					  RELS <! relation !>]]]].

;(MS 2005-11-10) getting rid of skip files.

topic-vhead-connect-p-lex := topic-p-lex &
 [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD verb_head & 
						     [FIN +,
						      VN -,
						      COP -,
						      ADJ -,
						      FORMAL.AHON -,
						      MAIN-PRD -],
					    CONT.HOOK.INDEX #objind]],
		CONT [RELS <! [PRED "_toshite_p_rel",
			       ARG2 #objind] !>]]].

; (ERB 2002-01-10) Experimenting with treating particle uses of など
; as contributing topic semantics in addition to nado relation.

;plain-topic-vmod-p-lex := topic-vmod-p-lex.

; (ERB 2001-09-13) Want pobj wa to pass up any constraints its OBJ had on the
; OBJ's MOD's LTOP as well.

; (ERB 2001-10-01) Making wa ARG/ARG2 again, but I don't want ARG = ARG2.
; That arises because the P object of wa identifies its ARG with its 
; MOD.IND with its own INDEX and wa takes the INDEX of its OBJ as ARG2
; and the INDEX of it's MOD (same thing) as ARG...  So grab the KEY.ARG0 instead.

; (ERB 2002-01-10) Some Ps select for MAIN-PRD + or -.  We 
; presumably want this selection to persist for P+wa.  (Immediate 
; motivation is reducing ambiguity in "dehanai" sentences.)

; (MS 2002-07-12) We could as well just unify the MOD values of both particles. This would 
; restrict the ambiguity in the case of  には, but there a problem with のは.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-05-11) Linking XARG of the complement to ARG1, instead of INDEX.
; (FCB 2007-04-20) Linking XARG of the complement to ARG2

topic-pobj-lex := topic-p-lex & 
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD p_head & 
						     [PTYPE nontop,
						      MOD #mod,
						      CASE mod],
					   CONT.HOOK.XARG #objind],
                    HEAD.MOD #mod],
	       CONT [ RELS.LIST.FIRST [ARG2 #objind]]]].

;(MS 2005-11-09) Getting rid of skip lexicon.

topic-pobj-postpcomp-lex := topic-pobj-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE postp-case].

topic-pobj-fullmod-lex := topic-pobj-lex &
			  [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT [VAL [UNSAT -,
									 SUBJ null],
								    HEAD.EMPTY -],
							       CONT.HOOK.XARG full_ref-ind]] >].

topic-pobj-fullmod-postpcomp-lex := topic-pobj-fullmod-lex & topic-pobj-postpcomp-lex.

topic-pobj-modcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE nontop,
									      CASE mod]].


topic-pobj-negmod-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD.MODUS negative] >].

topic-pobj-overtmodcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE overt,
									      CASE mod]].

topic-pobj-overtmodcomp-negmod-lex := topic-pobj-negmod-lex &topic-pobj-overtmodcomp-lex. 

topic-pobj-vmodpcomp-lex := topic-pobj-lex &
			    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD vmod-p_head & [PTYPE overt]].


; (ERB 2001-09-06) Moving some constraints on narg wa here.
; (MS 2003-12-19) Matrix 0.6

topic-nobj-lex := topic-p-lex &
[SYNSEM [LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [ CAT.HEAD noun_head,
					     CONT.HOOK.INDEX #objind ]]],
	 LKEYS.KEYREL.ARG2 #objind]].

;(MS 2005-11-09) Getting rid of skip lexicon.

topic-nobj-fullmod-lex := topic-nobj-lex &
			  [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT [VAL [UNSAT -,
									 SUBJ null],
								    HEAD.EMPTY -],
							       CONT.HOOK.XARG full_ref-ind]] >].

topic-nobj-negmod-lex := topic-nobj-lex &
			 [SYNSEM.LOCAL [CAT.HEAD.MOD < [LOCAL.CAT.HEAD.MODUS negative] >]].


topic-nobj-adjmod-lex := topic-nobj-negmod-lex &
			 [SYNSEM.LOCAL [CAT.HEAD.MOD < [LOCAL.CAT.HEAD i-adj_head] >]].


; (ERB 2002-01-10) Experimenting with treating particle uses of など
; as contributing topic semantics in addition to nado relation.
; (MS 2005-05-13) But why should that be different to the treatment of, e.g.
; demo, nanka and others?

;plain-topic-nobj-lex := topic-nobj-lex.


;topic-plus-nobj-lex := topic-nobj-lex &
;[ SYNSEM [LKEYS.ALTKEYREL #altkey & adj-relation &
;                               [ LBL #hand,
;                                 ARG1 #ind ],
;	  LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
;							LTOP #hand ],
;		  CONT [ RELS <! relation, #altkey !> ]]]].

; (ERB 2001-09-06) Moving some constraints on varg, comparg, & advarg wa here.
; (MS 2003-12-19) Matrix 0.6

; <type val="topic-vobj-lex">
; <name-ja>後置詞？？？
; <description>２つの動詞を繋ぐ助詞。
; <ex>泳い で も よい
; <todo>reject te-adjunct
; </type>
topic-vobj-lex := topic-p-lex &
 [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT [ HEAD sentence-valid & 
						       [VN -,
							COP -,
							ADJ -,
							H-TENSE te],
						  VAL saturated ],
					   CONT.HOOK.INDEX #objind]],
		CONT.RELS <! [ ARG2 #objind ] !>]]. 

topic-vobj-lex-neg := topic-vobj-lex &
		      [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & [FIN +,
										      FORMAL.AHON -],
					  HEAD [PTYPE shika,
						MOD < [LOCAL.CAT.HEAD.MODUS negative] >]]]].

; (ERB 2001-10-03) Complementizer to is actually a case-p_head, and in
; this case we want to grab the index, since it doesn't contribute a relation. 

topic-cobj-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [ CAT.HEAD case-p_head & [PTYPE to],
                                           CONT.HOOK.INDEX #objind ]],
               CONT.RELS <! [ARG2 #objind ] !>]].

; (MS 2002-05-22) inserted the CONT.KEY restriction to keep input from n2adv out.
; (MS 2003-12-19) Matrix 0.6 

; <type val="topic-advarg-lex">
; <name-ja>副助詞？？？
; <description>副詞の後に付く副助詞。ARG1(external)は動詞で、ARG2(internal)は副詞。ARG2 must be EMPTY -, to avoid attaching to the NP-ADV pumping rule.
; <ex>
; <ex>暫く は 吠える 。
; <nex>今日 は 天気 が よい 。
; <todo>
; </type>
topic-advarg-lex := topic-p-lex &
 [SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST.LOCAL [CAT.HEAD adv_head & 
						     [KEYS.KEY adv_rel,
						      EMPTY -],
					    CONT.HOOK.INDEX #objind]],
		CONT [RELS <! [ARG2 #objind] !>]]].


topic-cardarg-lex := topic-p-lex &
[SYNSEM.LOCAL [CAT [VAL.COMPS.FIRST [LOCAL [CAT.HEAD int_head & [MOD < [LOCAL.CAT.HEAD.MODUS negative] >],
					    CONT.HOOK.INDEX #objind]]],
	       CONT [RELS <! [ARG2 #objind] !>]]].
;;;
;;; end of postpositions
;;;


adv-p-lex := vmod-p-lex & 
             [SYNSEM.LOCAL.CAT.HEAD adv-p_head].

; (MS 2005-08-17) We want date-noun-lex to occur with or without に, but 
; date-noun-adv-lex never to occur with に. In order to do so, I restrict 
; the adv-p-lex-np semantically to non-date-nouns and invent a second one 
; for date nouns.
; (MS 2005-10-18) This is too strict. We cannot get results for relative sentences plus ni,
; for example. So, we do a trick and use FIN to distinguish them.
; i.e.,  date-noun-adv-lex is FIN -, so it won't unite
; FIXME: this is feature abuse

adv-p-lex-np :=  adv-p-lex & 
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head &
						   [FIN +]]].

;(MS 2005-11-10) getting rid of skip files.

; adv-p-lex-np-sub := adv-p-lex-np &
; 		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].

; adv-p-lex-np-main := adv-p-lex-np &
; 		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].
; 
adv-p-lex-np-exh := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS null] >].


adv-p-lex-np-nonexh := adv-p-lex-np &
		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS 1-list] >].


adv-p-lex-date :=  adv-p-lex & 
 [SYNSEM.LOCAL.CAT [HEAD.PTYPE ni,
		    VAL.COMPS.FIRST.LOCAL [CONT.RELS.LIST.FIRST niarg-relation,
					   CAT.HEAD noun_head]]].

adv-p-lex-iadj := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD i-adj_head].

;(MS 2005-11-10) getting rid of skip files.
;(FCB 2006-02-06) getting rid of main/sub again
; adv-p-lex-iadj-main := adv-p-lex-iadj &
; 		       [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

; adv-p-lex-iadj-sub := adv-p-lex-iadj &
; 		       [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].


adv-p-lex-p := adv-p-lex & 
            [SYNSEM.LOCAL.CAT [VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE nontop]]].

;(MS 2005-11-10) getting rid of skip files.
;(FCB 2006-02-06) getting rid of main/sub again
 adv-p-lex-p-main := adv-p-lex-p &
 		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD + ] >].

; adv-p-lex-p-sub := adv-p-lex-p &
; 		    [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD.MAIN-PRD - ] >].


adv-p-lex-tocomp := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE to, CASE mod]].

adv-p-lex-postp := adv-p-lex-p &
		    [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD [PTYPE postp-case]].

adv-p-lex-p-exh := adv-p-lex-p &
		   [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.VAL.COMPS null] >].


adv-p-lex-tocomp-main := adv-p-lex-p-main & adv-p-lex-tocomp.


adv-p-lex-postp-main := adv-p-lex-p-main & adv-p-lex-postp.

;(FCB 2006-02-06) getting rid of main/sub again
;adv-p-lex-postp-sub  := adv-p-lex-p-sub & adv-p-lex-postp.

adv-p-lex-postp-main-exh := adv-p-lex-postp-main & adv-p-lex-p-exh.

; (ERB 2002-01-10) To keep this from attaching to "empty-copula-id-rule"
; Vs, say COP -.  Might be too strong, and there might be another
; solution...
; (MS 2002-05-28) VN - to prevent ambiguity.

; <type val="adv-p-lex-vp">
; <name-ja>
; <description>verbの終止形につく「に」。
; <ex>捨てる に は 惜しい
; <nex>
; <todo>
; </type>
adv-p-lex-vp := adv-p-lex & 
[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & 
                                                [FORMAL.AHON -,
						 H-TENSE present,
                                                 VN -,
                                                 COP -]].

; <type val="adv-p-lex-vp-inf">
; <name-ja>
; <description>verbの活用形の語幹につく「に」。
; <ex>遊び に 行く
; <nex>
; <todo>
; </type>
adv-p-lex-vp-inf := adv-p-lex & 
[SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD verb_head & 
                                                [FORMAL.AHON -,
						 H-TENSE no_tense,
                                                 VN -,
                                                 COP -]].





adv-p-lex-naadj := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD na-adj_head].

adv-p-lex-parent := adv-p-lex & 
            [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD parent-end_head].


; (ERB 2001-08-02) This type used to say the OBJ must be LEX +,
; but that doesn't work for "kono neko to sono neko ga neru".
; Don't know if some other subtype did need the constraint.
; (MS 2002-1-7) The L-HAND and R-HAND are not bound. 
;(MS 2004-06-24) As the n-conjunction gets an index, it should be quantified
; (MS 2005-06-01) I try to unify the coordinated heads. It has to be shown if this
; is adequate (counterexamples?)
; (FCB 2005-06-26) Unifying heads stops things like: 商売 や 映画


; <type val="n_conj-p-lex">
; <name-ja>名詞並列助詞
; <description>２つの名詞（or名詞句）をつないで並列関係を表し、名詞句を作る。
; <ex>大根 と 人参 を 買う
; <ex>電話　や　手紙 の 連絡 
; <nex>友人 と 飲み に 行く
; <todo>
; </type>
n_conj-p-lex := conj-lex & 
            [SYNSEM [LKEYS.KEYREL conjunction-relation & #key &
                                    [ARG0 #index,
				     LBL #hndl,
                                     L-INDEX #arg,
                                     R-INDEX #mod],
		     LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT.HEAD noun_head,
						       CONT [HOOK.INDEX #mod]]] >,
				       J-POSTHEAD left],
                                VAL.COMPS.FIRST.LOCAL [CAT.HEAD noun_head,
						       CONT [HOOK.INDEX #arg],
						       BAR +]],
			    CONT n-conj-sem-type &
                               [HOOK [INDEX conj-ref-ind & #index],
				RELS <! #key , quant-relation & [PRED udef_q_rel,
								 ARG0 #index,
								 RSTR #rest] !>,
				HCONS <! qeq & [HARG #rest, LARG #hndl] !>]]]].


; (MS 2005-06-01) The restriction on the complement (to be a noun_head) was redundant.

; <type val="hyphen-conj-p-lex">
; <name-ja>名詞並列助詞記号
; <description>名詞と名詞をつないで並列関係を表す記号。n_conj-p-lexを参照
; <ex>北 − 北東 の 方向 を 見る
; <nex>北 − 見る
; <todo>
; </type>
hyphen-conj-p-lex := n_conj-p-lex &
            [SYNSEM [LOCAL.CAT.HEAD.PTYPE to,
		     LKEYS.KEYREL.PRED "to_c_and"]].


; (MS 2005-05-17) I am not sure that we need this. The only instance is "か", as in "東京からか". 
; Taking the entry out.

;postp-conj-p-lex := mod-p-lex & 
;            [SYNSEM [LKEYS.KEYREL #key & [L-INDEX #arg,
;					  R-INDEX #mod],
;		     LOCAL [CAT [HEAD nmod-p_head-avm & [MOD < [LOCAL [CAT.HEAD postp_head,
;								       CONT [HOOK.INDEX #mod]]] >,
;							 J-POSTHEAD left],
;                               VAL.COMPS.FIRST.LOCAL [CAT.HEAD postp_head,
;						      CONT [HOOK.INDEX #arg]]],
;			    CONT n-conj-sem-type &
;                               [HCONS <! !>,
;				RELS <! #key !>]]]].

; <type val="compl-conj-p-lex">
; <name-ja>承格助詞ト接続助詞
; <description>case-p-lex,comp-prpstn-lexの「と」どうしを繋ぐ接続助詞。
; <ex>犬 と または 猫 と 言う
; <nex>犬 と または 猫 と 遊ぶ
; <todo>
; </type>
compl-conj-p-lex := conj-lex & 
            [SYNSEM [LKEYS.KEYREL #key & [ARG0 #index,
					  L-HNDL #arg,
					  R-HNDL #mod],
		     LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT.HEAD case-p_head & [CASE #case,
									       PTYPE to],
						       CONT [HOOK.LTOP #mod]]] >,
				       J-POSTHEAD left],
				 VAL.COMPS.FIRST.LOCAL [CAT.HEAD case-p_head & [CASE #case,
										PTYPE to],
							CONT [HOOK.LTOP #arg]]],
			    CONT n-conj-sem-type &
				[HCONS <! !>,
				 HOOK.INDEX conj-ref-ind & #index,
				 RELS <! #key !>]]]].




;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- others;;;;;;;;;;;

;;;
;;; Determiners (kono/sono/ano/dono)
;;;

dt-lex := lexical_sign-word & 
 [SYNSEM  [LOCAL [CAT [HEAD det_head-avm & 
			    [J-SPEC.FIRST.LOCAL.CONT.HOOK [INDEX #ind,
							   LTOP #spechand]], 
		       VAL super-saturated],
		  CTXT.BACKGROUND <! !>,
		  CONT lex-det-sem-type & [HOOK [INDEX #ind,
						 XARG #ind],
					   RELS <! #key !>,
					   HCONS <! qeq &
						  [LARG #spechand,
						   HARG #hand] !>],
		  BAR +,
		  ARG-S <>],
	   LKEYS.KEYREL #key & [ARG0 #ind,
				RSTR #hand],
	   NON-LOCAL [AFFIX <! !>]],
  INFLECTED +].

; <type val="det-lex">
; <name-ja>連体詞
; <description>単独で名詞にのみかかる。現状ではdet-lexの直後にある名詞にしかかかれない。
; <ex>あの 犬 は 雌 だ
; <nex>あの の 犬 は 雌 だ
; <todo>Should also take wides scope over coordination: あの 犬 と 猫
; </type>
det-lex := dt-lex &
             [SYNSEM.NON-LOCAL.QUE <! !>].

; <type val="det-wh-lex">
; <name-ja>疑問連体詞
; <description>det-lexを参照。ただしこちらはwh疑問文に使う。このtypeがある文は必ず疑問文になってしまう
; <ex>どんな 色 が 好き です か
; <nex>どんな 行動 する
; <todo>(TK 07-03-23)疑問文になってほしくない場合もある。間接疑問文？(lkb::do-parse-tty "どんな 場合 でも 行く")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "どこ に どの 色 を 塗る か")。
; </type>
det-wh-lex := dt-lex &
             [SYNSEM [NON-LOCAL.QUE <! #top !>,
                      LOCAL [CONT.HOOK.LTOP #top,
			     CAT.HEAD.KEYS.KEY #pred],
		      LKEYS.KEYREL.PRED #pred & which_q_rel]].

; (MS 2002-04-17) DAI behaves like a definite determiner on counted nouns: 一本 - one book, 第一本 - the first book. 
; I've thus made it a determiner that specifies counted nouns. 
; I could not think of a solution that changes the card-rel to ord-rel, though.
; (MS 2003-12-19) Matrix 0.6


; <type val="card2ord-lex">
; <name-ja>接頭助数詞順序
; <description>数詞の直前について序数詞を作る助数詞。現状では「数詞+助数詞」の外側からこのtypeがかかっていく
; という解析になっている（「第２/巻」でなく「第/２巻」という解析）。
; <ex>第 ２ 巻 を 読む
; <nex>第 ２ リットル
; <todo>(TK 07-04-10)このtypeが、現状のように「数詞+助数詞」の外側からかかっていくのが良いのか、それとも
; 数詞に直接かかるべきなのかが分からない。
; </type>
card2ord-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD card2ord_head-avm & [J-SPEC.FIRST.LOCAL [CAT.HEAD.KEYS.KEY quantity_rel,
									       CONT.HOOK [INDEX #ind,
	       									 LTOP #spechand]],
	                                                   KEYS.KEY def_q_rel], 
                                 VAL super-saturated],
                            CTXT.BACKGROUND <! !>,
                            CONT lex-det-sem-type & [HOOK [INDEX #ind,
							   XARG #ind],
                                                     RELS <! #key !>,
                                                     HCONS <! qeq &
                                                             [LARG #spechand,
                                                              HARG #hand] !>],
                            BAR +,
			    ARG-S <>],
		     LKEYS.KEYREL #key &
			   [PRED def_q_rel,
			    ARG0 #ind,
			    RSTR #hand],
                     NON-LOCAL [AFFIX <! !>,
			     QUE <! !> ]],
             INFLECTED +].



; <type val="hes-lex">
; <name-ja>感動詞
; <description>感動詞のうち、すぐに言葉が出ない場合など、会話の間を繋ぎたい場合に使うもの。英語の「well」のような
; 感覚か。現状では文頭にしか使えないが、文中で使う場合も考えられる。
; <ex>ううん 余裕 は 無い
; <nex>
; <todo>(TK 07-03-23)これも解析できるようにすべき(lkb::do-parse-tty "余裕 は ううん 無い")。
; </type>
hes-lex   := lexical_sign-word &
            [SYNSEM [LOCAL [CAT  [HEAD hes_head-avm, VAL super-saturated],
                            CONT hes-sem-type,
                            CTXT.BACKGROUND <! !>,
			    ARG-S <>],
		     LKEYS.KEYREL.PRED hes_rel,
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].



; (MS 2005-05-17) Trying to put sentence particles into the type hierarchy of particles.

sap-lex  := p-lex-c & 
 [SYNSEM [LOCAL [CAT [HEAD sap_head & [FORMAL.SHON #1], 
		      VAL sap_sc & 
			   [COMPS #comps & 
				  [FIRST.LOCAL.CAT.HEAD.FORMAL.SHON #1]]],
		 CTXT.BACKGROUND <! !>,
		 ARG-S #comps],
	  NON-LOCAL [AFFIX <! !>]],
  INFLECTED +].

; (ERB 2001-12-28) For kudasai in VN + kudasai.  Brought in all relevant constraints
; from s-end-lex and s-end2-lex.

; (ERB 2002-01-02) This didn't work.  See notes at VERBAL ENDINGS, this file.

; (ERB 2002-01-14) comma_s-conj is taking sentences ending in 
; no+de as its OBJ.  
; (MS 2005-05-17) This is not needed any more!

;sap1-lex  := lexical_sign-word & 
;            [SYNSEM [LOCAL [CAT [HEAD sap1_head & [FORMAL.SHON #1], 
;                                 VAL sap_sc & [COMPS #comps & [FIRST.LOCAL.CAT.HEAD.FORMAL.SHON #1]]],
;                            CTXT.BACKGROUND <! !>,
;			    ARG-S #comps],
;                     NON-LOCAL [QUE <! !>,
;                             AFFIX <! !>]],
;             INFLECTED +].

; (ERB 2002-01-24) To force one order of combination in clauses with
; multiple conjunctions, require OBJ to be NUCL not_fin_conj.  (This
; probably isn't strictly correct, but I'll use it cut down ambiguity
; until we find a counterexample.)


; (ERB 2002-01-07) For conjunctions that allow non-propositional 
; right conjuncts.  This type doesn't supply a message for the
; right conjunct, since it would already have one.  However, since
; the right conjunct is also the head, these sentences won't go through
; a message-adding utterance rule.  So, the s-conj-nonprop-lex needs
; to supply a message for itself (and send the right handle up).
; [See further notes at s-conj-nonprop_head.]

; (ERB 2002-01-24) To force one order of combination in clauses with
; multiple conjunctions, require OBJ to be NUCL not_fin_conj.  (This
; probably isn't strictly correct, but I'll use it cut down ambiguity
; until we find a counterexample.)

; (MS 2002-02-07) The problem is that in the case of something like
; 食べれば行きますので教えて下さい NODE is not interpreted as an s-conj-lex
; and thus the sentence doesn't parse. I'll take that out and make another try.
; (MS 2005-06-07) These are all decl. They all identify AHON.
; (FCB 2005-06-27) Added ARG0 to messages
; e.g. (lkb::do-parse-tty "座る なら 寝る")
; very similar to v-cond-end-lex

; <type val="s-conj-lex">
; <name-ja>接続助詞
; <description>文どうしを繋ぐ役割をする助詞。
; <ex>叩く と 音 が する
; <nex>と 叩く 音 が する
; <nex>行く と 思う
; <todo>
; </type>
s-conj-lex := sap-lex &
 [SYNSEM [LOCAL [CAT [HEAD s-conj-nonprop_head &
			   [C-MOD < [LOCAL [CAT [HEAD verb_head],
					    BAR +,
					    CONT.HOOK [LTOP #main-h,
						      INDEX #main-i]]] >,
			    FORMAL.AHON #ahon,
			    SMOD decl],
		      VAL.COMPS.FIRST.LOCAL [CONT.HOOK [LTOP #sub-h,
							INDEX #sub-i],
					     CAT.HEAD [EMPTY -,
						       FORMAL.AHON #ahon],
					     NUCL nucl]],
		 NUCL nucl_minus,
		 CONT [HOOK [LTOP  #toph,
			     INDEX #topi],
		       RELS <!  conjunction-relation & #key & 
			     [LBL     #toph,
			      ARG0   #topi,
			      L-HNDL  #sub-h,
			      L-INDEX #sub-i,
			      R-HNDL  #main-h,
			      R-INDEX #main-i] !>,
		       HCONS <! !>]],
	  LKEYS.KEYREL #key,
	  NON-LOCAL.QUE <! !>]].


; <type val="s-conj-lex-fincomp">
; <name-ja>承用言接続助詞
; <description>用言やその活用したものの後について、２つの文を繋ぐ接続助詞。
; <ex>帰る から 片付ける
; <nex>右 から 何か が 来る
; <todo>
; </type>
s-conj-lex-fincomp := s-conj-lex &
		      [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FIN +].

; <type val="s-conj-lex-desusapsc">
; <name-ja>承用言接続助詞
; <description>用言や「べき」「そう」などの後について、２つの文を繋ぐ接続助詞。実際には用言の直後
; につくことは少ないと思われる。「copulaの否定形+と」の形か。
; <ex>無くなり そう でないと 買わ ない
; <nex>（早く行こう。）でないと 売り切れる
; <todo>
; </type>
s-conj-lex-desusapsc := s-conj-lex &
			[SYNSEM.LOCAL.CAT.VAL desu-sap_sc].


;s-conj-nonprop1-lex := s-conj-nonprop-lex & 
;                       [SYNSEM.LOCAL.CAT [HEAD [FORMAL.AHON #1,
;						SMOD decl],
;                                          VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORMAL.AHON #1]].

; (MS 2005-06-07) We seem not to use this any more.
;s-conj-nonprop2-lex := s-conj-nonprop-lex & 
;                       [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].



; (ERB 2002-01-07) LTOP was unbound.  Making it KEY.HANDEL.
; (FCB 2005-06-27) Added ARG0 to message

s-end-lex := sap-lex &
 [SYNSEM [ LOCAL [CAT [HEAD s-end_head-avm & [COP-ARG -],
		       VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #l,
							 INDEX #i]],
		  CONT [HOOK [ LTOP #l,
			       INDEX #i],
			RELS <!  !>,
			HCONS <! !>]]]].

;;; Pass up the AHON value (vs s-end2-lex which sets it to AHON +)
s-end1-lex := s-end-lex & 
 [SYNSEM.LOCAL.CAT [HEAD.FORMAL.AHON #1,
		    VAL.COMPS.FIRST.LOCAL.CAT.HEAD.FORMAL.AHON #1]].


; <type val="s-end1-decl-lex">
; <name-ja>終助詞平叙
; <description>文の末尾にあって、種々の意味を付加するもの。このtypeは平叙文に用いる。
; 用言・助動詞の終止形・否定形・過去形やna-adj-lexや「連用形+て」などの直後につく。
; <ex>行く よ
; <nex>
; <todo>
; </type>
s-end1-decl-lex := s-end1-lex &
 [SYNSEM [LOCAL [CAT.HEAD.SMOD decl,
		 CONT [ RELS <!  !>,
			HOOK.INDEX.SF prop]],
	  NON-LOCAL.QUE 0-dlist]].

; <type val="s-end1-declint-lex">
; <name-ja>終助詞平叙疑問
; <description>文の末尾にあって、平叙疑問文を作る。
; <ex>犬 だ ね
; <nex>ね 、 山田 くん
; <todo>
; </type>
s-end1-declint-lex := s-end1-lex &
 [SYNSEM [LOCAL [CAT.HEAD.SMOD decl,
		 CONT [RELS <! !>,
		       HOOK.INDEX.SF ne-sf]],
	  NON-LOCAL.QUE 0-dlist]].
;;;
;;; FIXME: lose - replace with "だ い" - check with MS
;;;	      
; <type val="s-end1-decl-minusahon-lex">
; <name-ja>終助詞平叙非丁寧
; <description>s-end1-decl-lexを参照。ただしこのtypeは聞き手や読み手に対する敬意を表す場合には使わない。
; また、助動詞「だ」の後にしかつかない。
; <ex>犬 だ い
; <nex>誰 だ い
; <todo>(TK 07-03-15)「だ い」で一語として扱うべき
; </type>
s-end1-decl-minusahon-lex := s-end1-decl-lex &
 [SYNSEM.LOCAL [CAT [HEAD.FORMAL.AHON -,
		     VAL.COMPS.FIRST [NON-LOCAL.QUE <! !>,
				      LOCAL.CAT.HEAD.COP +]],
		CTXT [C-INDICES.SPEAKER #1,
		      EMPATHY.EMPEE #1]]].
;;; FIXME-NOW change this type in lexicon
s-end1-decl-full-lex := s-end1-decl-lex.


; <type val="s-end1-quest-lex">
; <name-ja>終助詞疑問
; <description>文末にあって、文に疑問の意を加える。用言の終止形・過去形など、そのままでも文を終止させられる形の直後につく。
; <ex>行く か
; <nex>行け か
; <todo>
; </type>
s-end1-quest-lex := s-end1-lex &
 [SYNSEM [LOCAL [CAT.HEAD.SMOD quest,
		 CONT [RELS <! !>,
		       HOOK.INDEX.SF ques]],
	  NON-LOCAL.QUE 0-dlist]].

; <type val="s-end1-quest-minusahon-lex">
; <name-ja>終助詞疑問非丁寧
; <description>s-end1-quest-lexを参照。ただしこのtypeは聞き手や読み手に対しての丁寧を表す場合には使えない。
; <ex>行く の か い
; <nex>先生 の か い
; <todo>
; </type>
s-end1-quest-minusahon-lex := s-end1-quest-lex &
 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

; <type val="s-end1-quest-minusahon-vcomp-lex">
; <name-ja>終助詞疑問非丁寧
; <description>s-end1-quest-minusahon-lexを参照。このtypeは、用言の後につく。
; <ex>行く かい
; <nex>先生 かい
; <todo>
; </type>
s-end1-quest-minusahon-vcomp-lex := s-end1-quest-minusahon-lex &
 [SYNSEM [LOCAL [CAT [VAL.COMPS.FIRST [NON-LOCAL.QUE 0-dlist,
				       LOCAL.CAT.HEAD verb_head]]]]].


; <type val="s-end1-quest-minusahon-copcomp-lex">
; <name-ja>終助詞疑問非丁寧
; <description>s-end1-quest-minusahon-lexを参照。このtypeはwh-wordとcopulaのある文の末尾につく。
; <ex>誰 だ い
; <nex>本 だ い
; <todo>(TK 07-03-23)「だ い」を一語で扱っても良いのではないか。s-end1-decl-minusahon-lexも参照。
; </type>
s-end1-quest-minusahon-copcomp-lex := s-end1-quest-minusahon-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST [NON-LOCAL.QUE 1-dlist,
				    LOCAL.CAT.HEAD.COP +]].


; <type val="s-end1-neg-imp-lex">
; <name-ja>終助詞命令
; <description>文末にあって、文に否定の命令の意を加える。用言の終止形のみにつく。
; <ex>行く な
; <nex>行け な
; <todo>
; </type>
;; FCB can't inherent easily from s-end-lex as it has an extra proposition
;; FIXME - need to restrict to 終止形 
s-end1-neg-imp-lex := sap-lex &
 [SYNSEM [LKEYS.KEYREL #key,
	  LOCAL [CAT [HEAD s-end_head-avm & 
			   [COP-ARG -,
			    SMOD imp],
		      VAL.COMPS.FIRST.LOCAL 
			   [ CAT.HEAD.EMPTY -,
			     CONT.HOOK [LTOP #v-handle,	
					INDEX #ind &
					     [SF comm]]]],
		 CONT [HOOK [LTOP #neg-hand,
			     INDEX #ind],
		       RELS <! #key & neg-relation & 
			     [PRED "neg_v_rel",
			      LBL #neg-hand,
			      ARG0 individual,
			      ARG1 #neg1 ]!>,
		       HCONS <! qeq & [HARG #neg1, LARG #v-handle] !>]],
	  NON-LOCAL.QUE 0-dlist]].


;;; Set the AHON value to + (vs s-end1-lex which passes it up)
s-end2-lex := s-end-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-11-09) To get rid of skip files.

; <type val="s-end2-nemasc-lex">
; <name-ja>終助詞男性語
; <description>文の末尾につけて、男性が発したものであるという意味を添える。軽い疑問や願望を表すが、Dependenciesには
; それがあらわれていないように見える。また、このtypeに登録されているもの（「か な」など）は、実際には女性も使う。
; 終止形・過去形・否定形などの後につく。
; <ex>行く か な
; <nex>犬 か な
; <todo>
; </type>
s-end2-nemasc-lex := s-end2-lex &
 [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
		CONT[ RELS <! !>,
		      HOOK.INDEX.SF ques],
		CTXT.C-INDICES.SPEAKER.PNG.GEN masc]].

; <type val="s-end2-nefem-lex">
; <name-ja>終助詞女性語
; <description>文の末尾につけて、女性が発したものであるという意味を添える。平叙文でも疑問文でも使うはずだが、
; 疑問の意味はDependenciesには現れていないように見える。終止形・過去形・否定形などの後につく。
; <ex>行く かしら
; <nex>犬 かしら
; <todo>
; </type>
s-end2-nefem-lex := s-end2-lex &
 [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
		CONT[ RELS <! !>,
		      HOOK.INDEX.SF ques],
		CTXT.C-INDICES.SPEAKER.PNG.GEN fem]].

;;; FIXME: do we need? ask Melanie - need negative command
; <type val="s-end2-quest-lex">
; <name-ja>終助詞疑問
; <description>文の末尾につけて、疑問文であるという意味を付加する。このtypeには「な」が登録されているが、疑問文
; で使う場合は「か」(s-end1-quest-lex)と同じようなものなので、このtypeは必要かどうかよく分からない。
; <ex>行く な
; <nex>行け な
; <todo>(TK 07-03-15)禁止を意味するtypeが必要。(lkb::do-parse-tty "行く な")
; </type>
s-end2-quest-lex := s-end2-lex &
 [SYNSEM.LOCAL [CAT.HEAD.SMOD quest,
		CONT[ RELS <! !>,
		      HOOK.INDEX.SF ne-sf]]].



; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-02) For generation, these need PRED values on the arg1-relation.
; (MS 2005-11-09) These all have SMOD decl.
; (FCB 2008-02-18) currently treating as subordinating, not conjunction
; even though the parallel "のに" entry is a conjunction...

; <type val="s-ell-end-lex">
; <name-ja>終助詞後部省略
; <description>本来は接続助詞として２つの文を繋ぐはずが、後部の文章が省略されたために終助詞のようになったもの。
; このtypeによって文を終止したり、直後にcopulaを接続したりできる。
; <ex>勝っ た の は 打線 が 好調 だっ た から だ
; <ex>もう 野菜 を 買っ た のに
; <nex>打線 が 好調 だっ た から 勝っ た
; <todo> 
; </type>
s-ell-end-lex := sap-lex &
 [SYNSEM [LOCAL [CAT [HEAD s-end_head-avm & [EMPTY -,
					     SMOD decl],
		      VAL.COMPS.FIRST.LOCAL.CONT.HOOK [LTOP #v-handle]],
		 CONT [HOOK [INDEX #ind,
			     LTOP #handel],
		       RELS <! #key,
			     event-relation &
			     [LBL #left,
			      PRED "ellipses_rel",
			      ARG0 #ind  ] !>,
		       HCONS <! qeq & [HARG #main, LARG #v-handle],
			      qeq & [HARG #subord, LARG #left] !>]],
	  LKEYS.KEYREL subord-or-conj-relation & #key & 
		[ LBL #handel,
		  L-HNDL #main,
		  R-HNDL #subord],
	  NON-LOCAL.QUE <! !>]].


; (ERB 2001-12-10) Making these more like discourse adverbs like
; "well" and "so" in the LinGO grammar.  (Existing analysis gives
; them only a LBL and doesn't link that handle up to anything.
; In a sufficiently long sentence, this leads to non-scoping MRSs.)

; (ERB 2001-12-10) ... that means they must be scopal modifiers!
; (FCB 2006-06-01) make lexical_sign not lexical_sign_word
; the key pred's LTOP is not the HOOK.LTOP (it is the discourse rel)
; FIXME: maybe the #lhand and #rhand should introduce qeq


; (FCB 2006-06-20) reifying the similarities for idiom-lex and interj-lex
discourse-lex := lexical_sign & 
 [SYNSEM [LOCAL [CAT [HEAD final_head,
		      VAL super-saturated],
		 CONT [HOOK.LTOP #top,
		       RELS <! subord-or-conj-relation &
			     [ LBL #top,
			       PRED "discourse_x_rel",
			       L-HNDL #hand ],
			     #key & 
			     [ LBL #hand, 
			       ARG0 event] !>],
		 CTXT.BACKGROUND <! !>,
		 BAR +,
		 ARG-S <>],
	  LKEYS.KEYREL #key,
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>],
	  MODIFIED.PERIPH bool],
  INFLECTED +].

;;; (FCB 2006-06-20) interjections modify the main relation as a scopal modifier
;;; (lkb::do-parse-tty "それ 行け")
;;; when we loose utterances, try to constrain with MODIFIED.PERIPH -.
;;; to reduce ambiguity in  (lkb::do-parse-tty "東京 まで は 行く")
;;; note to self: doesn't work

; <type val="interj-lex">
; <name-ja>感動詞
; <description>日本語で一般的に感動詞と呼ばれるもの。文頭のみに出現する。現状では「アレッ」など、文中でも
; 使えそうなものも一部このtypeになってしまっている。
; <ex>それ 行け
; <ex>わっ 犬 だ
; <nex>あれ は わっ 犬 だ
; <todo>
; </type>
interj-lex := discourse-lex & 
 [SYNSEM [LOCAL [CAT [HEAD interj_head-avm & 
			   [ MOD < [LOCAL.CONT.HOOK.LTOP #rhand,
				    MODIFIED.PERIPH -] >]],
		 CONT interj-sem-type &
		     [RELS <! subord-or-conj-relation &
			    [ R-HNDL #rhand ],
			    interj-relation  !>]]]].

; (MS 2005-11-09) Subtypes to get rid of skip files.

interj-bar-lex := interj-lex &
		  [SYNSEM.LOCAL.BAR +].

; <type val="interj-robust-lex">
; <name-ja>感動詞
; <description>interj-lexを参照。"ROBUST +"は、曖昧性が多い語なのでspeechなどの他ではあまり解析させたくない語。
; <ex>１ 手 を 洗う
; <nex>
; <todo>
; </type>
interj-robust-lex := interj-lex &
		  [SYNSEM.NON-LOCAL.ROBUST +].


; <type val="excl-lex">
; <name-ja>感動詞
; <description>interj-lexを参照。ただしこちらはexcl-lexの手前がvmodの助詞の場合、文中にも出現することができる。
; <ex>いえいえ 今日 は 行く
; <ex>今日 は いえいえ 行く
; <nex>私 が いえいえ 行く
; <todo>
; </type>
excl-lex := idiom-lex &
            [SYNSEM [LOCAL [CAT.HEAD excl_head,
			    CONT excl-sem-type]]].

; (MS 2005-11-09) Subtypes to get rid of skip files.

; <type val="excl-robust-lex">
; <name-ja>感動詞
; <description>excl-lexを参照。"ROBUST +"は、曖昧性が多い語なのでspeechなどの他ではあまり解析させたくない語。
; <ex>あの ペン は どこ です
; <ex>ペン は あの どこ です
; <nex>ペン は どこ です あの
; <todo>
; </type>
excl-robust-lex := excl-lex &
		   [SYNSEM.NON-LOCAL.ROBUST +].

; <type val="excl-ahon-lex">
; <name-ja>感動詞尊敬
; <description>excl-lexを参照。このtypeは聞き手（読み手）に対する敬意を表す。
; <ex>すみません 今日 は 帰り ます
; <ex>今日 は すみません 帰り ます
; <nex>
; <todo>
; </type>
excl-ahon-lex := excl-lex &
		   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON + ].

;;; (FCB 2006-06-20) idioms are coordinate constructions with the main relation
;;; (lkb::do-parse-tty "あの 行く")

idiom-lex := discourse-lex & 
 [SYNSEM [LOCAL [CAT [HEAD idiom_head & 
			   [C-MOD < [LOCAL.CONT.HOOK [LTOP #rhand,
						      INDEX #ind]] > ]], 
		 CONT [HOOK.INDEX #ind,
		       RELS <! [R-HNDL #rhand],
			     arg0-relation !>]]]].


; <type val="greeting-lex">
; <name-ja>挨拶感動詞
; <description>excl-lexを参照。このtypeは挨拶に使われる。これの後に読点が打たれることが多いが、その場合は
; 解析することができない。
; <ex>さようなら 今日 は 帰る
; <ex>今日 は さようなら 帰る
; <nex>さようなら 借りる
; <todo>
; </type>
greeting-lex := idiom-lex &
                [SYNSEM [LOCAL.CONT greeting-sem-type]].

; (MS 2005-11-09) Subtype to get rid of skip files.

; <type val="greeting-ahon-lex">
; <name-ja>挨拶感動詞敬語
; <description>聞き手（読み手）への敬意を表す挨拶表現。greeting-lexを参照。
; <ex>失礼 しました 、 また 報告 に 伺い ます
; <nex>うち の 子 が 失礼 しました
; <todo>
; </type>
greeting-ahon-lex := greeting-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].



;;;;;;;;;;;;;;;;;;;;LEXIKAL TYPES - NOUNS;;;;;;;;;;;


; (ERB 2001-11-05) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.


n-lex-super := lexical_sign & 
         [SYNSEM [LOCAL [ CAT.HEAD noun_head,
			  CONT [ HOOK [INDEX #ind,
				       LTOP #top,
				       XARG nothing]]],
		  LKEYS.KEYREL [ARG0 #ind,
				LBL #top]],
          INFLECTED +].

n-lex := n-lex-super & lexical_sign-word.

; (MS 2005-07-04) This is nonsense, I think. It was used only for mitai.
;exceptional-n-lex := n-lex &
;[SYNSEM [LOCAL [CAT [HEAD exceptional_noun_head,
;		     VAL noun_sc],
;		CONT common-noun-sem-type & 
;		    [RELS <! #key !>,
;		     HCONS <! !>],
;		BAR -],
;	 LKEYS.KEYREL #key,
;	 NON-LOCAL [QUE <! !>,
;		    AFFIX <! !>]],
; J-NEEDS-AFFIX -,
; INFLECTED +].


ordinary-or-wh-n-lex := n-lex &
                  [SYNSEM [LOCAL [CAT [HEAD ordinary_noun_head-avm & [KEYS.KEY #pred],
                                       VAL noun_sc & [SPR.FIRST #spr]],
				  ARG-S < #spr >,
                                  CONT common-noun-sem-type & [HOOK.INDEX #ind & [PNG.PN three],
							       RELS <! #key !> ]],
			   LKEYS.KEYREL #key & [ARG0 #ind, PRED #pred],
                           NON-LOCAL.AFFIX <! !>]].

ordinary-n-lex := ordinary-or-wh-n-lex &
                  [SYNSEM [NON-LOCAL.QUE <! !>,
                           LOCAL.CONT [HCONS <! !>]],
                   STEMTYPE noun-stem].

; (MS 2005-09-02) This is not necessary any more. We move the entries to date-noun-lex.

;possibly-adv-n-lex := ordinary-or-wh-n-lex & 
;                      [STEMTYPE poss-adv-stem,
;                       SYNSEM [NON-LOCAL.QUE <! !>,
;                               LOCAL [CONT common-noun-sem-type &
;                                          [HCONS <! !>,
;					   HOOK.INDEX #ind,
;                                           RELS <! #key !>]],
;			       LKEYS.KEYREL #key & [ARG0 #ind]]].


;;; (FCB 2003-08-05) added for mi and sa
; (MS 2005-03-15) This is not correct: It should take an adjective as argument!
; FIXME!

; <type val="adj2n-suffix-lex">
; <name-ja>接尾辞形容詞名詞化
; <description>形容詞の後にあってそれを名詞化する。現状では形容詞の後につけられずに名詞の後につく形になって
; しまっている。また、形容動詞の名詞化もこのtypeによって行われるべきかもしれない。
; <ex>春 の 暖か さ
; <nex>あの 車 さ に は かなわ ない
; <todo>(TK 07-03-23)名詞でなくi-adj-lexの後につけられるようにすべき。また、na-adj-lexを名詞化
; するtypeも必要。
; </type>
adj2n-suffix-lex := n-lex &
 [SYNSEM [LOCAL [CAT [HEAD adj2n-suffix_noun_head &  
			   [J-POSTHEAD right,
			    MOD null,
			    VN -],
		      VAL noun_sc & [SPR.FIRST #spr]],
		 BAR -,
		 ARG-S < #spr >,
		 CONT common-noun-sem-type & [HOOK.INDEX #ind & [PNG.PN three],
					      RELS <! #key !>,
					      HCONS <! !> ]],
	  LKEYS.KEYREL #key & [ARG0 #ind],
	  NON-LOCAL.AFFIX <! !>]].	   


; (ERB 2001-10-23) 自分 unbound RELS values because it was a direct subtype
; of pron-lex, which says nothing about the semantics.  In addition, the
; constraint CONT personal-pronoun-sem-type is repeated on many types below.
; So, I'm going to make a subtype, pers-pron-lex, that bears this constraint
; and is also the type for 自分.

pron-lex := n-lex & 
           [SYNSEM [LOCAL [CAT [HEAD pron_head-avm,
                               VAL super-saturated],
                           BAR +,
			   ARG-S <>],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]]].

pers-pron-lex := pron-lex &
                 [ SYNSEM [LKEYS.KEYREL real-pron-relation & #key & [PRED pron_rel],
			   LOCAL.CONT personal-pronoun-sem-type &

					  [RELS.LIST.FIRST #key]]].

std-pron-lex := pers-pron-lex &
 [ SYNSEM.LKEYS.KEYREL pron-relation &
		       [ARG0.PRONTYPE std_pron]].

; (MS 2005-02-28) Renamed the pers-pron-selfemp-lex.
; This is actually only the reflexive 自分

; <type val="reflexive-pronoun-lex">
; <name-ja>再帰代名詞
; <description>再帰動詞（主語と目的語が同じものを指す動詞）の目的語に使える代名詞。
; このtypeは一人称にも二人称にも三人称にも使える。
; <ex>自分 を 省みる
; <nex>
; <todo>
; </type>
reflexive-pronoun-lex := pers-pron-lex &
			 [ SYNSEM [LOCAL [CONT [HOOK.INDEX #ind],
					  CTXT.EMPATHY.EMPEE #ind],
				   LKEYS.KEYREL pron-relation &
					 [ARG0.PRONTYPE refl],
				   NON-LOCAL [QUE <! !>,
					      REL <! #ind !>]]].


; (MS 2005-02-28) Renamed the pron-honsubj-selfemp-lex. 
;This is actually only the honorific reflexive. Thus, it
; inherits from the reflexive-pronoun-lex and we don't need the 
; pron-honsubj-lex any more. ご自分

; <type val="reflexive-pronoun-honsbj-lex">
; <name-ja>再帰代名詞尊敬
; <description>reflexive-pronoun-lexを参照。このtypeは主語への敬意に表す場合に使う。
; <ex>ご 自分 を 省み て ください
; <nex>
; <todo>
; </type>
reflexive-pronoun-honsbj-lex := reflexive-pronoun-lex &
			    [SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
					   CONT [HOOK.INDEX #1],
					   CTXT [C-INDICES.SPEAKER #2,
						 BACKGROUND <! obj-honor_rel &
							     [POLARITY +,
							      HONORER #2,
							      HONORED #1] !>]]].
			   
; (MS 2005-02-28) renamed pron-sp-ref-lex. No example.

pron-firstperson-ref-lex := std-pron-lex &
		   [SYNSEM [LKEYS.KEYREL [ARG0 [PNG.PN one]],
			    LOCAL [CAT.HEAD.FORMAL.SHON -,
				   CONT [HOOK.INDEX #1],
				   CTXT [C-INDICES.SPEAKER #1,
					 EMPATHY.EMPEE #1,
					 BACKGROUND <! obj-honor_rel &
						     [POLARITY -,
						      HONORER #1,
						      HONORED #1] !>]]]].



; (MS 2005-02-28) renamed pron-add-ref-lex. そちら

; <type val="pron-secondperson-ref-lex">
; <name-ja>代名詞二人称
; <description>二人称の代名詞。文の読み手、会話の聞き手や話し相手を指す。複合名詞は作らない。
; <ex>そっち が 悪い
; <nex>そっち 悪い
; <todo>
; </type>
pron-secondperson-ref-lex := std-pron-lex &
                    [SYNSEM [LKEYS.KEYREL [ARG0 [PNG.PN two]],
			     LOCAL [CAT.HEAD.FORMAL.SHON +,
                                   CONT [HOOK.INDEX #1],
                                   CTXT [C-INDICES [SPEAKER #2,
                                                    ADDRESSEE #1],
                                         BACKGROUND <! obj-honor_rel &
                                                     [POLARITY +,
                                                      HONORER #2,
                                                      HONORED #1] !>]]]].

; (MS 2005-03-01) added addressee honorification: そちら, 君

; <type val="pron-secondahon-ref-lex">
; <name-ja>代名詞二人称尊敬
; <description>pron-secondperson-ref-lexを参照。このtypeは読み手、聞き手に対する尊敬を表す。
; <ex>あなた の 本 を 読み まし た
; <nex>あなた 本 を 読み まし た
; <todo>
; </type>
pron-secondahon-ref-lex := pron-secondperson-ref-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; <type val="pron-secondminusahon-ref-lex">
; <name-ja>代名詞二人称非丁寧
; <description>pron-secondperson-ref-lexを参照。このtypeは読み手、聞き手に対する尊敬を表す場合には使えない。
; <ex>お前 は 何 を 考え て いる
; <nex>社長 、 お前 の 給料 は いくら だ
; <todo>
; </type>
pron-secondminusahon-ref-lex := pron-secondperson-ref-lex &
			   [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].


; (MS 2005-02-28) added the clear singular cases, such as 君

pron-secondsg-ref-lex := pron-secondperson-ref-lex &
			 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twosg].

pron-second-sg-ahon-ref-lex := pron-secondperson-ref-lex &
 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twosg,
  SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON + ].

pron-second-sg-xahon-ref-lex := pron-secondperson-ref-lex &
 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twosg,
  SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON - ].

; (MS 2005-02-28) added the clear plural cases, such as 君達

pron-secondpl-ref-lex := pron-secondperson-ref-lex &
			 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twopl].

pron-second-pl-ahon-ref-lex := pron-secondperson-ref-lex &
 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twopl,
  SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON + ].

; <type val="pron-second-pl-xahon-ref-lex">
; <name-ja>代名詞二人称複数非尊敬
; <description>pron-secondperson-ref-lexを参照。このtypeは相手が複数人いる場合に使い、聞き手への
; 敬意を表す場合には使えない。
; <ex>君達 が 今日 の 対戦 チーム です か
; <nex>君達 を 行う
; <todo>
; </type>
pron-second-pl-xahon-ref-lex := pron-secondperson-ref-lex &
 [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN twopl,
  SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON - ].




; (MS 2005-02-28) renamed pron-sp-add-ref-lex. We do not need the distinction
; between inclusion of the addressee and exclusion, because the pronouns don't give
; this distinction. This can inherit from pron-firstperson-ref-lex. 私達
;  (MS 2005-03-01) added types for honorification: こちら

; <type val="pron-firstpl-ref-lex">
; <name-ja>代名詞一人称複数
; <description>一人称の代名詞で、複数の人を指すもの。
; <ex>我等 が 作る
; <nex>
; <todo>
; </type>
pron-firstpl-ref-lex := pron-firstperson-ref-lex &
                       [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN onepl].

; <type val="pron-firstplahon-ref-lex">
; <name-ja>代名詞一人称複数尊敬
; <description>一人称の代名詞で、複数の人を指すもの。このtypeは聞き手への敬意を表す場合に使われる。
; <ex>私 ども が 参り ます
; <nex>私 ども が いらっしゃい ます
; <todo>
; </type>
pron-firstplahon-ref-lex := pron-firstpl-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-02-28) added the clear singular first person pronoun type. 私

pron-firstsg-ref-lex := pron-firstperson-ref-lex &
                       [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN onesg].

; (MS 2005-03-01) added types for honorification: 私、ぼく

; <type val="pron-firstsgahon-ref-lex">
; <name-ja>代名詞一人称単数尊敬
; <description>一人称の代名詞で、１人の人を指すもの。このtypeは聞き手（読み手）への敬意を表す場合に使う。
; <ex>小生 が 参り ます
; <nex>小生 が いらっしゃい ます
; <todo>
; </type>
pron-firstsgahon-ref-lex := pron-firstsg-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; <type val="pron-firstsgminusahon-ref-lex">
; <name-ja>代名詞一人称単数非尊敬
; <description>一人称の代名詞で、１人の人を指すもの。このtypeは聞き手（読み手）への敬意を表す場合には使えない。
; <ex>俺 が やる
; <nex>
; <todo>
; </type>
pron-firstsgminusahon-ref-lex := pron-firstsg-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

; (MS 2005-02-28) renamed pron-ent-ref-lex.

pron-thirdperson-ref-lex :=  std-pron-lex &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN three]]].


; (MS 2005-02-28) added the clear singular third person pronoun type. 彼女

pron-thirdsg-ref-lex := pron-thirdperson-ref-lex  &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN threesg]]].

; (MS 2005-03-01) we need gender for the third person singular. 彼、彼女, それだけ

; <type val="pron-thirdsgfem-ref-lex">
; <name-ja>代名詞三人称単数女性
; <description>三人称の代名詞のうち、一人の女性を指すもの。複合名詞は作らない。
; <ex>彼女 が 行く
; <nex>
; <todo>
; </type>
pron-thirdsgfem-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN fem].

; <type val="pron-thirdsgmasc-ref-lex">
; <name-ja>代名詞三人称単数男性
; <description>三人称の代名詞のうち、一人の男性を指すもの。複合名詞は作らない。
; <ex>彼 が 行く
; <nex>
; <todo>(TK 07-04-11)男性を指すとは限らないものも登録されている（「誰々」「誰それ」など）。
; </type>
pron-thirdsgmasc-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN masc].

; <type val="pron-thirdsgneut-ref-lex">
; <name-ja>代名詞三人称単数中性
; <description>三人称の代名詞のうち、一つの中性のものを指すもの。複合名詞は作らない。
; <ex>それだけ が 在る
; <nex>それだけ 雨 が 降っ た
; <todo>(TK 07-04-11)「それ」はpron-demon-lexなのに何故「それだけ」がこのtypeなのか。
; </type>
pron-thirdsgneut-ref-lex := pron-thirdsg-ref-lex &
			   [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN neut].

; (MS 2005-03-01) added honorification: あちら

; <type val="pron-thirdsgneutahon-ref-lex">
; <name-ja>代名詞三人称単数中性
; <description>pron-thirdsgneut-ref-lexを参照。このtypeは聞き手（読み手）への敬意を表す場合に使う。
; <ex>あちら は どなた です か
; <nex>あちら に 座り ます
; <todo>
; </type>
pron-thirdsgneutahon-ref-lex := pron-thirdsgneut-ref-lex &
			    [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].


; (MS 2005-02-28) added the clear plural third person pronoun type. 彼ら

pron-thirdpl-ref-lex := pron-thirdperson-ref-lex  &
                  [SYNSEM.LKEYS [KEYREL [ARG0.PNG.PN threepl]]].

; (MS 2005-03-01) third person plural can be andro (彼ら) or neutr (それら).

; <type val="pron-thirdplandro-ref-lex">
; <name-ja>代名詞三人称複数男性
; <description>三人称の代名詞のうち、複数の男性を指すもの。複合名詞は作らない。
; <ex>彼ら が 作る
; <nex>
; <todo>(TK 07-04-11)このtypeの女性版も必要では？（例:「彼女ら」）
; </type>
pron-thirdplandro-ref-lex := pron-thirdpl-ref-lex &
			     [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN andro].


; <type val="pron-thirdplneut-ref-lex">
; <name-ja>代名詞三人称複数中性
; <description>三人称の代名詞のうち、複数の中性のものを指すもの。複合名詞は作らない。
; <ex>あれら は 何 です か
; <nex>
; <todo>
; </type>
pron-thirdplneut-ref-lex := pron-thirdpl-ref-lex &
			     [SYNSEM.LKEYS.KEYREL.ARG0.PNG.GEN neut].



; (MS 2005-03-01) gender neutr for all demonstrative pronouns. 

; <type val="pron-demon-lex">
; <name-ja>指示代名詞物事
; <description>ある場所や方角にある物事を指す指示代名詞。複合名詞は作らない。「あの」など、直接名詞を
; 修飾するものはdet-lexで登録されている。
; <ex>
; <nex>
; <todo>
; </type>
pron-demon-lex := pron-lex &
 [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i & [PNG.GEN neut]],
	  LOCAL.CONT ppron-sem-type &
		       [RELS <! #key & 
			      generic-nom-relation,
			      quant-relation !>,
			HOOK.INDEX #i]]].

;; FCB 2007-05-12 specialized
;; should redo with ALTKEY and inheritence from supertype

; <type val="pron-demon-ko-lex">
; <name-ja>指示代名詞物事近称
; <description>話し手に近いある場所や方角などにある物事を指す指示代名詞。
; <ex>これ が 辞書 です
; <nex>これ 、 もう 帰り なさい
; <todo>
; </type>
pron-demon-ko-lex := pron-lex &
 [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i & [PNG.GEN neut]],
	  LOCAL.CONT ppron-sem-type &
		       [RELS <! #key & 
			      generic-nom-relation,
			      quant-relation & [PRED "_kono_q_rel"] !>,
			HOOK.INDEX #i]]].
; <type val="pron-demon-so-lex">
; <name-ja>指示代名詞物事中称
; <description>話し手から遠く、聞き手に近い場所にある物事をなどを指す、中称の指示代名詞。
; <ex>それ が 辞書 です
; <nex>それ 、 行く よ
; <todo>
; </type>
pron-demon-so-lex := pron-lex &
 [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i & [PNG.GEN neut]],
	  LOCAL.CONT ppron-sem-type &
		       [RELS <! #key & 
			      generic-nom-relation,
			      quant-relation & [PRED "_sono_q_rel"] !>,
			HOOK.INDEX #i]]].
; <type val="pron-demon-a-lex">
; <name-ja>指示代名詞物事遠称
; <description>話し手からも聞き手からも遠い場所にある物事などを指す、中称の指示代名詞。
; <ex>あれ が 辞書 です
; <nex>あれ 、 誰 も 居 ない
; <todo>
; </type>
pron-demon-a-lex := pron-lex &
 [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i & [PNG.GEN neut]],
	  LOCAL.CONT ppron-sem-type &
		       [RELS <! #key & 
			      generic-nom-relation,
			      quant-relation & [PRED "_ano_q_rel"] !>,
			HOOK.INDEX #i]]].


; <type val="pron-loc-ref-lex">
; <name-ja>指示代名詞場所
; <description>ある場所や方角を指す指示代名詞。複合名詞は作らない。
; <ex>会場 は ここ です
; <nex>会場 ここ です
; <todo>
; </type>
pron-loc-ref-lex  := pron-lex &
                  [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
				 LOCAL.CONT lpron-sem-type &
					  [HOOK.INDEX #i,
					   RELS.LIST.FIRST #key ]]].



;  TT&FCB 2003-09-03 took away [SYNSEM [LOCAL [CAT [ VAL.SPR.FIRST.LOCAL.KEYS.KEY.PRED 'def]]
; so that we could actually parse these things!
; otherwise unification fails with quantify-n-infl-rule
; (MS 2003-12-19) Fixed that.
; (FCB 2006-08-28) added SYNSEM.LOCAL.CAT.HEAD.FIN -
; to stop spurious unification with adv-p-lex-np

day-lex := n-lex & 
 [SYNSEM [LOCAL [CAT [HEAD temporal-noun_head & 
			   [FIN -],
		      VAL noun_sc & 
			   [SPR.FIRST #spr & 
				      [LOCAL.CAT.HEAD.KEYS.KEY def_q_rel]]],
		 CONT [HOOK [LTOP #hand],
		       RELS <! #key !>,
		       HCONS <! !>],
		 CTXT.BACKGROUND <! !>,
		 ARG-S < #spr >],
	  LKEYS.KEYREL contentful-nom-relation & #key & [LBL #hand],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]]].

; <type val="dofw-n-lex">
; <name-ja>時間名詞曜日
; <description>時間を表す名詞のうち、曜日を表すもの。date-noun-lexを参照。
; <ex>日曜 荷物 が 届く
; <ex>日曜 に 荷物 が 届く
; <nex>
; <todo>
; </type>
dofw-n-lex  := day-lex & 
 [SYNSEM [LOCAL.CAT.HEAD dofw_noun_head-avm,
	  LKEYS.KEYREL dofw-relation    ]].


dofm-n-lex := day-lex & 
 [SYNSEM [LOCAL.CAT.HEAD dofm_noun_head-avm,
	  LKEYS.KEYREL dofm-relation ]].


mofy-n-lex := day-lex & 
 [SYNSEM [LOCAL.CAT.HEAD temp_numeral_head-avm & [J-POSTHEAD compound],
	  LKEYS.KEYREL mofy-relation    ]].

; <type val="relational-n-lex">
; <name-ja>関係名詞
; <description>「名詞+nounmod-p-ncomp-relmod-lex+relational-n-lex」で、何らかの比較や範囲を表す。それ以外
; ではordinary-nohon-n-lexと同じ働きをする。ただし現状では「relational-n-lex+noun」の複合名詞が作れない。
; <ex>線 より 内側 に 入る
; <ex>線 の 内側 に 入る
; <nex>
; <todo>(TK 07-03-23)「relational-n-lex+ordinary-nohon-n-lex」も解析できるようにすべき。
; (lkb::do-parse-tty "上級 クラス") (lkb::do-parse-tty "後方 支援")
; </type>
relational-n-lex := n-lex &
 [SYNSEM [LOCAL [CAT [HEAD relational_noun_head,
		      VAL noun_sc & 
			   [SPR.FIRST #spr & 
				      [LOCAL.CAT.HEAD.KEYS.KEY def_q_rel]]],
		 CONT [HOOK [LTOP #hand],
		       RELS <! #key !>,
		       HCONS <! !>],
		 CTXT.BACKGROUND <! !>,
		 ARG-S < #spr >],
	  LKEYS.KEYREL contentful-nom-relation & #key & [LBL #hand],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]]].

; (MS 2003-07-14) With PRED string (matrix.tdl), it is not possible to use types here and therefore I cannot state PRED def (which overrides PRED udef in the quantify-n-infl-rule). Default-Unification might help here.
; (MS 2003-10-08) I'll use the KEY value instead.
; (MS 2005-11-09) These needed to link the KEYS.KEY, otherwise we parse (and generate) 第花子

name-lex  := n-lex & 
                  [SYNSEM [LOCAL [CAT [HEAD name_head-avm & [KEYS.KEY #pred],
                                       VAL noun_sc &
                                          [SPR.FIRST #spr & [LOCAL.CAT.HEAD.KEYS.KEY def_q_rel]]],
                                  CONT mod-id-nominal-sign-sem-type &
                                      [RELS <! #key !>,
				       HOOK.INDEX #ind,
                                       HCONS <! !>],
				  CTXT.BACKGROUND <! !>,
				  ARG-S < #spr >],
			   LKEYS.KEYREL named-relation & #key & [ARG0 #ind, PRED #pred],
                           NON-LOCAL [QUE 0-dlist,
				      AFFIX <! !>]]].


person-name-lex := name-lex.


; <type val="surname-lex">
; <name-ja>固有名詞人・姓
; <description>固有名詞のうち、姓として使われる。組織名の一部として使われる可能性もあるがその場合はあまり
; 有名でない場合が多い。
; <ex>後藤田 氏 を 任命 する
; <nex>後藤田 に 行く
; <todo>
; </type>
surname-lex := person-name-lex & loc-or-surname-lex &
                  [SYNSEM.LOCAL.CAT.HEAD surname_head].

; <type val="first_name-lex">
; <name-ja>固有名詞人・名
; <description>固有名詞の一つ。人名のうちで（姓名の）名としてしか使わないもの。
; <ex>大輔 の 名字 は 何 です か
; <nex>将軍 より 大輔 という 姓 を 頂い た
; <todo>
; </type>
first_name-lex := person-name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD first_name_head-avm].

;;; names which can be first or surname, artists' names
;;; (do-parse-tty "タモリ")

; <type val="other_name-lex">
; <name-ja>固有名詞人・その他
; <description>人名を表す固有名詞のうち、姓や名以外のもの。あだ名・芸名・四股名など。また、姓と名の両方で使う
; ものもこのtypeで登録している。
; <ex>番組 の 司会 は タモリ だ
; <ex>千秋 は 姓 な のか 名 な のか 分から ない
; <nex>武蔵丸 に 行く
; <todo>
; </type>
other_name-lex := person-name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD other_name_head-avm].


; <type val="ippan-name-lex">
; <name-ja>固有名詞全能
; <description>固有名詞のうち、他のtypeに当てはまらないもの。作品・神仏・法律の名など。ブランド名や列車名など
; どのtypeが適当か分からないものや、複数のtypeにまたがるもの（「マック」inst_name,product-name,other_name）も
; これに含む。ippan-nameと他のtypeにまたがるようなもの（「恵比寿」ippan-name,loc_name）は、ippan-nameのみの登録とする。
; <ex>同僚 と キャッツ を 見る
; <nex>キャッツ する
; <todo>
; </type>
ippan-name-lex := name-lex & 
                  [SYNSEM.LOCAL.CAT.HEAD ippan_head-avm].

; <type val="loc_name-lex">
; <name-ja>固有名詞場所
; <description>固有名詞のうち、地名として使われるもの。組織名の一部として使われる可能性もある（「奈良 銀行」など）。
; <ex>京都 に 住む
; <nex>京都 が 住む
; <todo>
; </type>
loc_name-lex := loc-or-surname-lex & 
                [SYNSEM.LOCAL [CAT.HEAD loc_name_head-avm]].
                               

; <type val="inst_name-lex">
; <name-ja>固有名詞組織
; <description>固有名詞の一つ。組織名としてしか使わないもの。
; <ex>日本 も ＷＴＯ に 加盟 し た
; <nex>ＷＴＯ する
; <todo>
; </type>
inst_name-lex := loc-or-surname-or-instname-lex &
                  [SYNSEM.LOCAL [CAT.HEAD inst_name_head-avm]].
                               
                   
; <type val="agent-name-lex">
; <name-ja>固有名詞主体
; <description>
; <ex>北朝鮮 が 参加 する
; <nex>
; <todo>(TK 07-04-04)このtypeが必要かどうかわからない
; </type>
agent-name-lex := name-lex & 
                  [SYNSEM.LOCAL [CAT.HEAD surname_head-avm]].


; <type val="product-name-lex">
; <name-ja>固有名詞商品
; <description>固有名詞の一つ。商品名や製品名として使われる。
; <ex>新しい ウィンドウズ が 出る
; <nex>ウィンドウズ し た
; <todo>
; </type>
product-name-lex := name-lex &
                  [SYNSEM.LOCAL [CAT.HEAD product_name_head-avm]].

; (MS 2005-09-30) Added types for names that can be ambiguous.

; <type val="loc-or-surname-or-instname-lex">
; <name-ja>固有名詞人場所組織
; <description>固有名詞のうち、人と場所と組織について使われるもの。
; <ex>お茶の水 女子 大学 と お茶の水 博士 の 名前 の 由来 は お茶の水 という 地名 だ
; <nex>お茶の水 する
; <todo>
; </type>
loc-or-surname-or-instname-lex := name-lex &
                  [SYNSEM.LOCAL [CAT.HEAD name_head & [J-POSTHEAD compound]]].

; <type val="loc-or-surname-lex">
; <name-ja>固有名詞人場所
; <description>固有名詞のうち、人と場所について使われるもの。組織名として使われる可能性もある。
; <ex>高石 に 住む 高石 さん に 会う
; <nex>高石 する
; <todo>
; </type>
loc-or-surname-lex :=  loc-or-surname-or-instname-lex.

; <type val="surname-or-instname-lex">
; <name-ja>固有名詞人組織
; <description>固有名詞のうち、人と組織について使われるもの。
; <ex>ギネス の ビール
; <nex>ギネス する
; <todo>
; </type>
surname-or-instname-lex := loc-or-surname-or-instname-lex.

; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.
; (FCB 2005-04-11) Added  SYNSEM.LOCAL.CAT.HEAD.MOD null, to stop 
; interjections popping up all over the place in (do-parse-tty "この こと が 起きる")

nom-lex := n-lex-super & 
           [SYNSEM [LOCAL [CAT [HEAD nom_head-avm & 
				     [MOD null],
				VAL.SPR #spr],
                            CTXT.BACKGROUND <! !>,
			   ARG-S #spr,
                          BAR +],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]]].

; (MS 2003-12-19) Matrix 0.6

temp_numeral-basic-lex  := n-lex & 
           [SYNSEM [LOCAL [CAT [HEAD temp_numeral_head-avm,
                                VAL temp_noun_sc &
                                     [SPR.FIRST #spr,
				      COMPS #comps & [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
									      XARG #i],
								   CAT.HEAD.KEYS.KEY 'temp_loc]]]],
                           CONT common-noun-sem-type &
                               [HOOK [INDEX #i,
				      LTOP #hand]],
                           CTXT.BACKGROUND <! !>,
			   ARG-S < #spr . #comps >],
		    LKEYS.KEYREL.ARG0 #i,
                    NON-LOCAL.AFFIX <! !>]].


temp_numeral-lex := temp_numeral-basic-lex &
                    [SYNSEM [LOCAL [CAT.HEAD.J-POSTHEAD compound,
				    CONT common-noun-sem-type &
                                        [RELS <! #key !>,
					 HOOK.INDEX #i,
                                         HCONS <! !>]],
			     LKEYS.KEYREL #key & [ARG0 #i]]].

; <type val="temp_numeral-whq-lex">
; <name-ja>承日付時間名詞疑問
; <description>temp_numeral-nonwh-lexを参照。ただしこのtypeは、当該の時間がいつであるかを
; （「いつ」よりも具体的に）尋ねる場合に使う。
; <ex>３ 日 何時 に 行く か
; <ex>来月 何日 に 行く か
; <nex>何時 ３ 日 に 行く か
; <nex>何日 来月 に 行く か
; <todo>(TK 07-04-18)日付表現がうまくできていない。temp_numeral-nonwh-lexを参照。
; (TK 07-04-18)また、(lkb::do-parse-tty "何時 ３ 日 に 行く か")は解析できないほうが良い。
; temp_numeral-nonwh-lexも参照。
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "何月 何日 に 行く")。
; </type>
temp_numeral-whq-lex := temp_numeral-lex &
                        [SYNSEM [NON-LOCAL.QUE <! #top !>,
                                 LOCAL.CONT.HOOK.LTOP #top]].

; <type val="temp_numeral-nonwh-lex">
; <name-ja>承日付時間名詞
; <description>時間を表す名詞のうち、日付表現の後にもつくことができるもの。それ以外については
; date-noun-lexと同様。ただし、現状では日付表現がうまくできていないこともあり、date-noun-lexも
; このtypeも同じような振舞いをする。
; <ex>３ 日 朝 に 着く
; <ex>今日 朝 に 着く
; <nex>３ 時 朝 に 着く
; <nex>朝 今日 に 着く
; <todo>(TK 07-04-18)日付表現がうまくできていないため、(lkb::do-parse-tty "３ 日 朝 に 着く")も
; (lkb::do-parse-tty "朝 ３ 時 に 着く")も解析できない。
; (TK 07-04-18)また、(lkb::do-parse-tty "朝 今日 に 着く")は解析できないほうが良いと思われる。
; </type>
temp_numeral-nonwh-lex  := temp_numeral-lex &
                           [SYNSEM.NON-LOCAL.QUE <! !>].

; <type val="temp_numeral-dur-lex">
; <name-ja>時間名詞期間
; <description>ある一定の、継続する時間を表す名詞。date-noun-lexと同じように、ordinary-nohon-n-lex
; と同じような振舞いをする他、ADV_NP_RULEによって副詞化することができる。
; <ex>短時間 煮る
; <nex>
; <todo>(TK 07-04-13)FIXME:「temp_numeral-dur-lex+vn-lex」の形のときに、何故かREL-CL-OBJ1-GAP-RULE
; とRELATIVE-CLAUSE-RULEが出て不要な曖昧性が増えてしまう（たとえvn-intrans-lexでも同様）。
; (lkb::do-parse-tty "短時間 労働")
; </type>
temp_numeral-dur-lex := temp_numeral-basic-lex &
                         [SYNSEM [NON-LOCAL.QUE <! !>,
				  LOCAL.CONT [RELS <! #key !>,
					      HCONS  <! !>],
				  LKEYS.KEYREL #key]].

;;; FCB 2003-08-14 食事 中 juu/chuu 
;;; Should probably be more of an operator
;;; should take an event noun/temporal noun as argument ???

; <type val="temp_numeral-dur-suffix-lex">
; <name-ja>時間接尾辞期間
; <description>vn-lexや名詞などの直後について、その状態や行為がその期間続くことを表す接尾辞。
; ただし、現状ではdate-noun-lexの直後にしかつかない状態と思われる。
; <ex>今日 じゅう に 帰る
; <nex>世界 じゅう の 飛行機
; <todo>(TK 07-04-13)FIXME:以下の文も解析できるようにすべき。
; (lkb::do-parse-tty "食事 中")(lkb::do-parse-tty "休暇 中 の 職員")
; </type>
temp_numeral-dur-suffix-lex := temp_numeral-dur-lex &
			       [SYNSEM.LOCAL [CAT.HEAD.J-POSTHEAD right,
					      BAR -]].


; <type val="temp_numeral-dur-whq-lex">
; <name-ja>時間名詞期間疑問
; <description>temp_numeral-dur-lexを参照。このtypeはその期間がどのくらいであるかを尋ねる場合に使う。
; また、このtypeのある文は全て疑問文になってしまう。
; <ex>何日間 居 ます か
; <nex>
; <todo>(TK 07-04-13)疑問文になってほしくない場合もある。間接疑問文？(lkb::do-parse-tty "何時間 の 労働 でも 耐える")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "何月 に 何日間 働く か")。
; </type>
temp_numeral-dur-whq-lex := temp_numeral-lex &
                            [SYNSEM [NON-LOCAL.QUE <! #top !>,
                                     LOCAL.CONT.HOOK.LTOP #top]].


; (MS 2005-11-09) These all seem to have "mo" affixes.

affix-noun-lex := n-lex &
                  [SYNSEM [LOCAL [CAT [HEAD [MOD null,
                                             C-MOD null,
                                             J-SPEC null,
                                             QUANTIFIABLE -,
                                             COP-ARG -],
                                       VAL noun_sc & [SPR #spr]],
                                  CONT common-noun-sem-type &
                                      [HCONS <! !>,
				       HOOK.INDEX #i,
                                       RELS <! #key !>],
                                  CTXT.BACKGROUND <! !>,
				  ARG-S #spr,
                                  BAR +],
			   LKEYS.KEYREL #key & [ARG0 #i],
                           NON-LOCAL [QUE <! !>,
				      AFFIX <! mo !> ]]].
                                       
;;;;;;;;;;;;;;;;;; numeral classifiers ;;;;;;;;;;;;;;;;;;;;;;;

; (ERB 2001-08-06) Redoing numeral-classifiers along with new analysis
; of number names.


; (ERB 2001-12-05) spr-obj-num-cl-lex has slightly different semantic constraints,
; so replace num-cl-sem-type here with num-cl-sem-type-super and further
; constrain on subtypes.

; (MS 2002-02-01) added some necessary restrictions.
; (FCB 2006-05-02) changed supertype to lexical_sign to allow
; the HOOK.LTOP to be different from the KEYREL.LBL

numeral-classifier := lexical_sign &
[ SYNSEM [ LOCAL [ CAT.HEAD num-cl_head &
			    [KEYS [KEY quantity_rel]],
                   CONT num-cl-sem-type-super,
                   BAR + ],
           NON-LOCAL [QUE <! !> ,
                   AFFIX <! !>]],
  J-NEEDS-AFFIX -,
  INFLECTED +,
  STEMTYPE noun-stem].

; (ERB 2004-1-16) New semantic analysis has num-cls introducing more
; relations, with the total number depending on the semantic type.

spr-only-num-cl-lex := numeral-classifier &
 [ SYNSEM.LOCAL [ CAT [ VAL spr-arg &
			    [ SPR #spr &
				  [FIRST [OPT - ,
					  LOCAL.CAT [ HEAD int_head &
							   [ ST-ALONE + ],
						      VAL saturated ]]]]],
		  ARG-S #spr,
		  CONT num-cl-sem-type]].

; (ERB 2001-08-21) For "numeral classifiers" that go before the
; numbers, i.e., $, ＄, ￥...
; I'm leveraging the fact that ordinary numeral classifiers never
; have objects.  So all numeral classifiers are HEAD num-cl, and
; num-cl is a subtype of init_head.

; (ERB 2001-09-12) I found one of these that can be a modifier ("No."),
; so I'm changing the types to cross-classify the order and the
; possible MOD values.

; (ERB 2004-1-18) These also will make no semantic contribution in
; the new analysis. ... except to hook up the XARG and LTOP of the
; COMPS element to the appropriate values. ... but this works differently
; for measure and individuating numeral classifiers.

obj-only-num-cl-lex := numeral-classifier &
 [ SYNSEM.LOCAL [CAT [VAL obj-arg &
			[ COMPS #comps & 
				[FIRST [OPT - ,
					LOCAL [ CAT [ HEAD int_head &
							   [ ST-ALONE + ],
						      VAL saturated ]]]]]],
		  ARG-S #comps,
		  CONT num-cl-sem-type]].

; (ERB 2001-12-05) Some numeral classifiers take both a specifier and
; an object, namely those that can take 半 as an object.  (In 二年半,
; 年 has to be the head for semantic reasons.)

; (ERB 2004-1-18) measure-num-cl-lex is now contributing a whole mess
; of relations.  Need to allow cross-classification with this type
; without creating conflicting specifications on the RELS value.
; Use LKEYS.ALTKEYREL to stash the plus rel, and then pull it on in
; the relevant subtype.  Also, add constraints so that the XARG
; of the han_rel gets bound properly.  Mention of XARG looks okay
; here, because it's not related to anything in the MOD value.

spr-obj-num-cl-lex := numeral-classifier &
[ SYNSEM [ LOCAL [ CAT [ VAL spr-obj-arg &
                                [ SPR.FIRST #spr &
					    [OPT - ,
					     LOCAL [ CAT [ HEAD int_head &
								[ ST-ALONE + ],
							   VAL saturated ],
						     CONT.HOOK [ LTOP #spr_h,
								 XARG #xarg ]]],
				  COMPS.FIRST #comps &
					    [OPT - ,
					     LOCAL [ CAT.HEAD han_head,
						     CONT.HOOK [ LTOP #obj_h,
								 XARG #xarg ]]]]],
		   ARG-S < #spr , #comps >],
	   LKEYS.ALTKEYREL plus-relation &
		           [ ARG1 #xarg,
			     ARG2 #spr_h,
			     ARG3 #obj_h ]]].

                         

; (ERB 2001-09-13) Type for extra entries of "No." and "bangou"
; that attach to numbers already marked by gou or ban.  This will
; get strings like
;
; 口座No.1234号を閉じる
;
; and also unfortunately strings like
;
; 口座No.No.1234を閉じる
;
; and providing double parses for strings like
;
; 口座No.1234を閉じる
;
; there is presumably real (two-way) amibguity to both of these:
; as 番号 is also a noun.
;
; 口座番号1234を閉じる
; 口座番号1234号を閉じる
;
; I don't know how to rule this out.  The semantic representations
; will reflect Atusko's intuitions that there's something redundant
; here.
;
; (ERB 2001-09-13) This creates so much ambiguity, we should probably wait
; until the data requires it.
;

; Types for different MOD possibilities. 
; (ERB 2004-1-18) Francis has convinced me that there is also an
; ambiguity in the case of mensural classifiers (e.g., 円、メートル、
; etc) between direct modification and the anaphoric use, linked 
; to the head noun by の.  Therefore, this dimension of classification
; is no longer mod v. nomod, but individuating vs. measure.  I
; expect to see some more types in here as we extend the analysis
; to other NumCl types.


; (ERB 2004-1-18) Put constaints on semantics etc for individuating
; numeral classifiers here.

; (ERB 2004-1-16) Per Francis, the individuate-rel can be left
; implicit.  Presumably an inference engine could get it from 
; the card-rel. No need for that extra quant-rel either.

; (ERB 2004-1-18) Constraints on the SPR don't belong here,
; as a few oddballs actually take a COMPS instead.  


individuating-num-cl-lex := numeral-classifier &
 [ SYNSEM.LOCAL [ CAT.HEAD num-cl-mod_head & 
			   [ MOD < [ LOCAL intersective-mod &
					   [ CONT.HOOK #hook ]]>],
		  CONT [ RELS <! !>,
			 HCONS <! !>,
			 HOOK #hook ]]].

; FIXME: FCB this stops things from floating
;
; individuating-num-cl-lex := numeral-classifier &
;  [ SYNSEM [ LOCAL [ CAT.HEAD num-cl-mod_head & 
; 			     [ MOD < [ LOCAL intersective-mod &
; 					     [ CONT.HOOK #hook ]]>],
; 		    CONT [ RELS <! [ LBL #lbl,
; 				     PRED "numcl_x_rel",
; 				     ARG0 event,
; 				     ARG1 #x ] !>,
; 			   HCONS <! !>,
; 			   HOOK #hook &
; 				[LTOP #lbl,
; 				 INDEX #x ]]]]].



; (ERB 2002-01-22) We don't want an attachment ambiguity between
; posthead NumClPs and prehead modifiers.  Restrict posthead
; NumClPs to modifying things that are [NUCL +].  (These same
; guys also modify PPs, but those are [NUCL bool] from the P,
; regardless of what's inside, so this shouldn't pose any problems.
; (Famous last words!)  This leads to funny looking trees (because
; the supposedly floated quantifier is attaching low), but the MRS
; looks fine, so leave it for now.

; (MS 2005-01-07) Changing the head from num-cl-n-or-p-mod_head to num-cl-nmod_head,
; because I don't need the p-modification any more, because I have introduced the 
; floating rules.

anymod-ind-num-cl-lex := individuating-num-cl-lex &
[ SYNSEM.LOCAL.CAT.HEAD num-cl-nmod_head &
                        [ MOD < [LOCAL.NUCL nucl_plus ] > ]].

; (ERB 2001-09-12) Some num-cl like things can't "float" (i.e., show 
; up outside the PP.  So these have a more specific MOD value).

noun-mod-ind-num-cl-lex := individuating-num-cl-lex &
[ SYNSEM.LOCAL.CAT.HEAD num-cl-nmod_head ].

; (FCB 2005-02-10) Adverbial numeral classifiers
; this is a supertype for event and floating classifiers
;;; (FCB 2005-01-28) added J-POSTHEAD left so they only modify following verbs

adv-num-cl-lex := numeral-classifier &
[ SYNSEM.LOCAL [CAT [HEAD num-cl-adv_head &
			  [J-POSTHEAD left,
			   MOD < [ LOCAL.CONT.HOOK [LTOP #top,
						    INDEX #ind]] >],
		     VAL [COMPS < >,
			  SUBJ < >]],
		CONT [HOOK [LTOP #top,
			    INDEX #ind],
		      HCONS <! !>]]].

; (MS 2004-12-27) Floated numeral classifiers, modifying verbs,
; semantically counting their subjects. This type is needed for 
; the lexical rule that makes the numeral classifier float.
; only for non-zpros.
; (FCB 2007-07-03) FIXME: measure classifiers should also float

floated-num-cl-lex := adv-num-cl-lex &
 [ SYNSEM.LOCAL [CAT [HEAD num-cl-float_head, 
		      VAL.SPR.FIRST.LOCAL.CONT.HOOK.XARG #xarg],
		 CONT [HOOK.XARG #xarg,
		       RELS <! !>]]].

floated-sbj-num-cl-lex := floated-num-cl-lex &
[ SYNSEM.LOCAL [CAT [HEAD [MOD < [ LOCAL.CONT.HOOK [ LTOP #ltop,
						     XARG #xarg & full_ref-ind]] >],
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
						      XARG #xarg]]]]].

floated-obj-num-cl-lex := floated-num-cl-lex &
[ SYNSEM.LOCAL [CAT [HEAD [MOD < [ LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #ltop,
									       INDEX #xarg & full_ref-ind]] >],
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK  [ LTOP #ltop,
						      XARG #xarg]]]]].


; (FCB 2005-01-17) Added event classifiers
; 回、遍、度  not sure about 発, 拳 etc


; <type val="event-num-cl-lex">
; <name-ja>助数詞回数
; <description>数詞の直後にあって、その行為をした回数を表す。
; <ex>テキスト を ５ 回 読ん だ
; <nex>５ 回 犬 が 居る
; <todo>
; </type>
event-num-cl-lex := adv-num-cl-lex & 
[ SYNSEM.LOCAL [CAT [HEAD num-cl-event_head,
		     VAL [SPR.FIRST.LOCAL.CONT.HOOK [LTOP #top,
						     XARG #ind]]],
		CONT [HOOK [LTOP #top,
			    INDEX #ind],
		      RELS <! !>]]].


; (ERB 2004-1-18) These ones are differentiated from the 
; individuating ones by their semantic contribution (and
; presumably eventually by their lack of fussiness in what
; ontological types they'll modify), but they can serve as
; modifiers in the same way.  [We may want to separate out
; the syntactic details of the MOD possibilities from this
; semantic distinction at some point, but leave that for now.]
; For now, say that they can only show up as premodifiers of Ns.

; (ERB 2004-1-18) Need to leave length of RELS list underspecified,
; since spr-obj-num-cl-lex adds a plus-relation to tie in the 
; complements "han".  Furthermore, need to hold off
; on relating the LBL of the noun-relation to number,
; as it might end up being identified with the LTOP
; of the SPR or with the plus-relation.

; (ERB 2004-1-20) At the moment, the only connection between the
; measure phrase semantics and the degree-rel is through label
; sharing.  Dan seemed to think that this might need to be
; elaborated at some point, but this will do for now.  In
; the paper (Bender & Siegel 2004, IJCNLP-04) I'm going to 
; write as if there were another role (EARG, for Extent ARG)
; in the degree-rel to tie things together.
; (FCB 2005-08-07) fixed 'unspec_adj_rel, specified ARG0 to event
; make the whole thing look like a modifier from outside
measure-num-cl-lex := numeral-classifier &
[ SYNSEM [ LKEYS.KEYREL #key,
	   LOCAL [ CAT [HEAD num-cl-nmod_head & 
			    [ MOD < [ LOCAL intersective-mod &
					    [ CONT.HOOK.INDEX #ind ]] >]],
		   CONT [ HOOK [ LTOP #lattr,
				 INDEX #darg,
				 XARG #ind ],
			  RELS.LIST < quant-relation &
				      [ PRED udef_q_rel,
					ARG0 #unit-ind,
					RSTR #harg ],
				      #key & noun-relation &
				      [ LBL #unit-lbl,
					ARG0 #unit-ind ],
				      degree-relation & 
				      [ LBL #lattr,
					PRED degree_rel,
					ARG0 event,
					ARG1 #darg, 
					ARG2  #unit-ind ],
				      arg1-relation &
				      [ LBL #lattr,
					PRED unspec_adj_rel,
					ARG0 #darg & event,
					ARG1 #ind ], ... >,
			  HCONS <! qeq & 
				 [ HARG #harg,
				   LARG #unit-lbl ] !>]]]].

; Cross-classified subtypes:

; (ERB 2001-11-01) I need three separate rules that promote numeral
; classifier phrases to NPs: one for "true" NumCls like 本、匹、etc.,
; one for word like 円、階、etc., and one for numbers used as numeral
; classifiers.  In order to distinguish between the first two, I'm
; going to say that the 本 type is always ALTKEY no_rel, while the
; 円 type is always ALTKEY relation.

; (ERB 2001-11-14) To keep the nominal-numcl rules straight, I'm
; typing the KEY values.  Putting that info in here for lack of a
; better place right now.

; 本、個、匹、人、 etc.

; (MS 2003-09-26) As Matrix Ver.0.5 does not include no-relation any
; more, I'll erase that here.

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-16) Changing semantic analysis to fit with Francis's
; thinking better.  These ones are the "individuating" classifiers.
; Putting all the constraints here for now and worrying about
; generalizing later.

;num-cl-mod-lex := num-cl-lex & anymod-ind-num-cl-lex &
;                  [ SYNSEM.LKEYS [ KEYREL reg-quantity-relation & [PRED 'reg-quantity_rel],
;					 ALTKEYREL no-relation ]].

; (ERB 2004-1-16) Per Francis, the individuate-rel can be left
; implicit.  Presumably an inference engine could get it from 
; the card-rel. No need for that extra quant-rel either.

; (ERB 2004-1-18) Moved constraints on the semantics of these
; guys up to individuating-num-cl-lex.  Still need to hook up
; XARG and LTOP of SPR to appropriate things.

; <type val="num-cl-spr-only-ind-lex">
; <name-ja>助数詞可算
; <description>数詞の後について数を表す。可算名詞の時にしか使わない
; <ex>１ 人 の 老人 が 居る
; <nex>１ 人 の 年月 が 流れ た
; <todo>
; </type>
num-cl-spr-only-ind-lex := spr-only-num-cl-lex & anymod-ind-num-cl-lex &
  [ SYNSEM.LOCAL [CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ INDEX #xarg,
							LTOP #ltop ],
		       VAL.SPR.FIRST.LOCAL.CONT.HOOK [ XARG #xarg,
						       LTOP #ltop ]],
		  CONT.HOOK [XARG #xarg]]].

; <type val="num+cl-spr-only-ind-lex">
; <name-ja>数詞＋助数詞
; <description>茶筌は「一つ」〜「九つ」を一語にしますので特別なエントリーが必要だ。
; 基本的に数字と助数詞を一緒にした物です。
; <ex>一つ の 石 が 倒れ た
; <todo>Add "tsu" as a predicate in some way
; </type>
; (FCB 2007-07-03) FIXME: these should also float

n_num+cl-spr-only-ind-lex := numeral-classifier &
 [ SYNSEM [LOCAL [ CAT [ VAL super-saturated,
			 HEAD num-cl-nmod_head & 
			     [ MOD < [ LOCAL intersective-mod &
					     [ CONT.HOOK [ LTOP #ltop,
							   INDEX #ind ],
					       NUCL nucl_plus ] ] > ]],
		   CONT [ RELS <!  const-relation &
				[ LBL #ltop,
				  ARG1 #ind,
				  CARG #carg ] !>,
			  HCONS <! !>,
			  HOOK [ INDEX #ind,
				 LTOP #ltop, 
				 XARG  #ind ] ]],
	    LKEYS.KEYREL.CARG #carg  ]].



; 番、号

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-18) Hook up XARG and LTOP of SPR with appropriate
; things.  This looks mighty similar to the above.  Consider just
; having this type further constrain the MOD value?

; <type val="num-cl-spr-only-ind-nmod-lex">
; <name-ja>助数詞序数詞化
; <description>数詞の後にあって序数詞を作る
; <ex>今 シーズン の 第 ３ 号 の ホームラン です
; <nex>号 ３ の ホームラン です
; <todo>
; </type>
num-cl-spr-only-ind-nmod-lex := spr-only-num-cl-lex & noun-mod-ind-num-cl-lex &
  [ SYNSEM.LOCAL [CAT [ HEAD.MOD.FIRST.LOCAL.CONT.HOOK [ INDEX #xarg,
							LTOP #ltop ],
		       VAL.SPR.FIRST.LOCAL.CONT.HOOK [ XARG #xarg,
						       LTOP #ltop ]],
		  CONT.HOOK [XARG #xarg]]].


; 円、年、階、etc

; (ERB 2003-12-03) Norm-relation is gone, so here the type of ALTKEY
; will be noun-rel.  It doesn't really matter what it is exactly, as
; long as it contrasts with no-relation, because the only information
; we take from it presently is the PRED value.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Constraint length of RELS list and 
; relate SPR..LTOP/XARG to noun-relation.  

num-cl-spr-only-meas-lex := spr-only-num-cl-lex & measure-num-cl-lex &
  [ SYNSEM [ LKEYS.KEYREL [ LBL #lbl,
			    ARG0 #xarg ],
	     LOCAL [ CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
							 XARG #xarg ],
		     CONT.RELS <! *top*, *top*, *top*, *top* !> ]]].

; ￥、＄、etc.

; (ERB 2003-12-03) Norm-relation is gone, so here the type of ALTKEY
; will be noun-rel.  It doesn't really matter what it is exactly, as
; long as it contrasts with no-relation, because the only information
; we take from it presently is the PRED value.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Constraint length of RELS list and 
; relate COMPS..LTOP/XARG to noun-relation.  

; <type val="num-cl-obj-only-meas-lex">
; <name-ja>接頭助数詞
; <description>数詞の直前につくtypeの助数詞。不可算名詞に対して使う。
; <ex>この 商品 は ￥ ５ です
; <nex>この 商品 は ５ ￥ です
; <todo>
; </type>
num-cl-obj-only-meas-lex := obj-only-num-cl-lex & measure-num-cl-lex &
  [ SYNSEM [ LKEYS.KEYREL [ LBL #lbl,
			    ARG0 #xarg ],
	     LOCAL [ CAT.VAL.COMPS.FIRST.LOCAL.CONT.HOOK [ LTOP #lbl,
							   XARG #xarg ],
		     CONT.RELS <! *top*, *top*, *top*, *top* !> ]]].

; numbers used as numcls

; (MS 2003-09-26) As Matrix Ver.0.5 does not include no-relation any
; more, I'll erase that here.

; (ERB 2003-12-03) We still need some mechanism for separating the mod
; numcls from the nomods in the nominal-numcl rules.  Melanie has
; resurrected no-relation, and I'm putting it back in here.

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.


num-cl-obj-only-nmod-ind-lex-super := obj-only-num-cl-lex & noun-mod-ind-num-cl-lex.

; No., 番号

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; <type val="num-cl-obj-only-nmod-ind-lex">
; <name-ja>
; <description>数詞の前にあって序数詞を作る。省略不可。num-cl-obj-only-meas-lexを参照。
; <ex>Ｎｏ １ ５ の 資料 を ご覧 ください
; <nex>５ Ｎｏ
; <todo>
; </type>
num-cl-obj-only-nmod-ind-lex := num-cl-obj-only-nmod-ind-lex-super.

; (ERB 2001-09-13) This creates so much ambiguity, we should probably wait
; until the data requires it.

;num-cl-spr-obj-nmod-lex := spr-obj-num-cl-lex & noun-mod-ind-num-cl-lex.

; 年、 時、ヶ月 etc. with 半

; (ERB 2004-1-18) Removed KEY and ALTKEY constraints from here
; for new analysis.

; (ERB 2004-1-18) Pull plus-relation from ALTKEYREL onto RELS list,
; relate its LBL to LBL of noun-relation in KEYREL, ARG1 to ARG0.

num-cl-spr-obj-meas-lex := spr-obj-num-cl-lex & measure-num-cl-lex &
   [ SYNSEM [ LKEYS [ KEYREL [ LBL #lbl,
			       ARG0 #xarg ],
		      ALTKEYREL #altkey & [ LBL #lbl,
					    ARG1 #xarg ]],
	     LOCAL [ CONT.RELS <! *top*, *top*, *top*, *top*,
				   #altkey !> ]]].







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

basic-subcategorizing-n-lex := n-lex & 
                         [SYNSEM [LOCAL [CAT [HEAD ordinary_noun_head-avm &
                                                   [QUANTIFIABLE -],
                                              VAL subcategorizing-noun_sc &
						   [SPR.FIRST #spr,
						    COMPS #comps]],
                                         CONT [HCONS <! !>],
                                         BAR +,
					 ARG-S < #spr . #comps >],
                                  NON-LOCAL [QUE <! !>,
                                          AFFIX <! !>]]].

subcategorizing-n-lex := basic-subcategorizing-n-lex & 
                         [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
				  LOCAL.CONT common-noun-sem-type &
						 [HOOK.INDEX #i,
						  RELS <! #key !>]]].

subcategorizing-poss-n-lex := subcategorizing-n-lex &
                              [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD p_head & [PTYPE nattr]].

; (MS 2001-12-19) This is 'only' (DAKE, NOMI) and 'each' (GOTONI). I'll make the semantics parallel to the Lingo examples.

temp_mod-lex := lexical_sign-word & 
            [SYNSEM [LOCAL [CAT [HEAD temp_mod_head,
                                 VAL super-saturated],
			    ARG-S < >,
                            CTXT.BACKGROUND <! !>],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]],
             INFLECTED +].


; (MS 2003-12-19) Matrix 0.6
; (MS 2005-12-07) Linking LTOP and LBL.

temp_nmod-lex := temp_mod-lex & 
            [SYNSEM [LKEYS.KEYREL #key,
		     LOCAL [CAT.HEAD temp_nmod_head &
				   [MOD < [LOCAL [CAT.VAL saturated,
						  CONT.HOOK [LTOP #hand,
							     INDEX #arg]]]> ],
			   CONT simple-adj-sem-type &
				    [RELS <! #key & adj-relation & [ARG1 #arg, LBL #hand ] !>,
				     HOOK [INDEX #arg,
					   LTOP #hand],
				     HCONS <! !>]]]].

; (MS 2005-11-09) Subtype in order to get rid of skip files.
; This shouldn't undergo the empty rules.

; <type val="temp_nmod-nonempty-lex">
; <name-ja>???
; <description>???
; <nex>一つ の 物 が 倒れ た
; <todo>stop this modifying dummy nouns
; </type>
temp_nmod-nonempty-lex := temp_nmod-lex &
 [SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL.CAT.HEAD noun_head-avm & [EMPTY +]] > ].
			  







; (ERB 2001-11-28) Constrain these to head-adj-1

; (MS 2003-10-29) There was a mistake on the RELS that prevented the RELS to pass up.

noun_mod-lex := lexical_sign-word &
            [SYNSEM [LKEYS.KEYREL #key & [ARG1 #inst, 
					  LBL #handle],
		     LOCAL [CAT [HEAD noun_mod_head-avm &
				      [MOD < [LOCAL intersective-mod &
						    [ CONT.HOOK [INDEX #inst,
								 LTOP #handle]]] > ], 
				 VAL super-saturated],
			    ARG-S < >,
			    CONT simple-verb-sem-type &
				[RELS <! #key !>,
                                 HCONS <! !>],
                            BAR -],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]], 
             INFLECTED +].

; (ERB 2002-01-10) Some are prehead, like 単なる ...

; <type val="noun_mod-lex-l">
; <name-ja>普通接頭詞
; <description>単独では働かず、普通名詞・固有名詞・サ変名詞の直前にあって何らかの意味を付加するtype。
; 名詞的な働きをする複合語を作る。「大」など同表記でordinary-nohon-n-lexとしても使う場合は
; ordinary-nohon-n-lexのみの登録。
; <ex>彼 は 反 体制 を 貫い た
; <nex>彼 は 反 の 体制 を 貫い た
; <nex>彼 は 体制 反 だ
; <todo>
; </type>
noun_mod-lex-l := noun_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD left ].

; Idiom Implementation (CH 060804)
; (CH 2006-08-04) Introduced idiom-A-adnominal-lex, which is an idiom that
;  is completely fixed and unambiguous and corresponds to an adnominal word.
idiom-A-adnominal-lex := noun_mod-lex-l.

; (MS 2005-11-09) Subtype to get rid of skip files.

; <type val="noun_mod-lex-l-relational">
; <name-ja>関係性接頭詞
; <description>noun_mod-lex-lを参照。このtypeはrelational-n-lexの直前のみにつく。
; <ex>一番 前 の 席 に 座る
; <nex>一番 の 席 に 座る
; <todo>
; </type>
noun_mod-lex-l-relational := noun_mod-lex-l &
			     [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD relational_noun_head ].

; (ERB 2002-01-10) ... and some are posthead, like 等 (distinct
; from particle use of 等)  (Assuming this is intersective, may
; not be.)

; <type val="noun_mod-lex-r">
; <name-ja>普通接尾詞
; <description>単独では働かず、普通名詞・固有名詞・サ変名詞の直後にあって何らかの意味を付加するtype。
; 名詞的な働きをする複合語を作る。「軍」など同表記でordinary-nohon-n-lexとしても使う場合は
; ordinary-nohon-n-lexのみの登録。 
; <ex>水道 の カルキ 臭 が 強い
; <nex>水道 の カルキ の 臭 が 強い
; <nex>水道 の 臭 は カルキ だ
; <todo>複数形を表す接尾辞を別のクラスにすべき（「方」「がた」「達」「たち」「等」「ら」「共」「ども」）。
; </type>
noun_mod-lex-r := noun_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right ].


; (MS 2005-07-05) changed RELS.LIST.FIRST.LBL #handle to LTOP

pp_mod-lex := lexical_sign-word &
            [SYNSEM [LKEYS.KEYREL #key & [ARG1 #inst, 
					  LBL #handle],
		     LOCAL [CAT [HEAD pp_mod_head-avm &
				      [MOD < [LOCAL intersective-mod &
						    [ CONT [HOOK [XARG #inst,
								  LTOP #handle]]]] > ], 
				 VAL super-saturated],
			    ARG-S < >,
			    CONT simple-adj-sem-type &
				[RELS <! #key !>,
                                 HCONS <! !>],
                            BAR +],
                     NON-LOCAL [QUE <! !>,
                             AFFIX <! !>]], 
             INFLECTED +].


pp_mod-lex-r := pp_mod-lex &
                  [ SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right ].




; (MS 2001-10-23) this shall be for ookina, chiisana
; (FCB 2005-04-09) linked LBL so that it scopes
; should really reify some of this out with i-adj and na-adj I suppose

; <type val="pred-adj-lex">
; <name-ja>連体形容詞
; <description>形容詞のうち、連体詞のような使い方をするもの。活用はしない。det-lexと違い、連用修飾語を受ける
; ことができる。
; <ex>大きな 犬
; <ex>とても 大きな 犬
; <ex>耳 が 大きな 犬
; <nex>
; <todo>
; </type>
pred-adj-lex := lexical_sign-word &
 [SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
			   [MOD < [LOCAL intersective-mod & 
					 [CAT [HEAD ordinary_noun_head,
					       VAL saturated]]] >,
			    MARK null,
			    C-MOD null,
			    J-SPEC null,
			    J-POSTHEAD rels,
			    H-TENSE no_tense,
			    FIN +,
			    AUX aux_minus,
			    COP -,
			    LIGHT -,
			    MAIN-PRD -,
			    COP-ARG -], 
		      VAL adj_sc &
			   [SUBJ #sbj & 
				 [FIRST.LOCAL.CONT.HOOK.INDEX #sbjind]]],
		 ARG-S #sbj,
		 CONT [RELS <! #key !>,
		       HOOK [XARG #sbjind,
			     INDEX #ind,
			     LTOP #top],
		       HCONS <! !>],
		 BAR -],
	  LKEYS.KEYREL #key & 
		[LBL #top,
		 ARG0 event & #ind,
		 ARG1 #sbjind],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]], 
  INFLECTED +].


; (MS 2005-11-09) Subtypes in order to get rid of skip files.

hon-prefix-lex := lexical_sign-affix &
                  [SYNSEM [LOCAL [CAT [HEAD hon-prefix_head,
                                       VAL super-saturated],
				  ARG-S < >,
                                  CONT [RELS <! !>,
                                        HCONS <! !>],
                                  CTXT.BACKGROUND <! !>,
                                  BAR -],
                           NON-LOCAL [QUE <! !>,
                                   AFFIX <! !>]], 
                   INFLECTED +].

; <type val="hon-prefix2n-lex">
; <name-ja>尊敬接頭詞名詞接続
; <description>名詞の直前にあって、その名詞やそれに関係する人への尊敬の意を表す。まれに親しみの意
; で使う場合もある。
; <ex>お 父上 の 病状 は いかが です か
; <ex>お 馬 さん に 乗る
; <nex>お 走って ください
; <todo>
; </type>
hon-prefix2n-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT [HEAD ordinary_noun_head,
							       VAL.SPR 1-list ]]> ].

; <type val="hon-prefix2vn-lex">
; <name-ja>尊敬接頭詞動詞接続
; <description>動詞の連用形やvnの直前にあって、その行為をする相手への敬意を表す。
; <ex>しばらく お 待ち ください
; <ex>多く の 方々 に ご 参加 いただい て 光栄 です
; <nex>ご 降雨 する
; <todo>
; </type>
hon-prefix2vn-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD vn_head ] > ].

; <type val="hon-prefix2na-lex">
; <name-ja>尊敬接頭詞形容動詞接続
; <description>形容動詞の直前にあって、その状態にある人物への敬意をあらわす。今のところ「お 元気」しか
; 想定されていないが、「ご 立派」などもこのtypeで解析すべきかもしれない。
; <ex>斉藤 さん は お 元気 です か
; <nex>
; <todo>
; </type>
hon-prefix2na-lex := hon-prefix-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.MOD < [ LOCAL.CAT.HEAD na-adj_head ] > ].



; (ERB 2001-09-06) Sentences with commas in them have broken HCONS values.  So 
; I'm adding HCONS <! !> to see if that helps.                   

; (MS 2003-08-22) Added scopal-mod information just to avoid spurious ambiguity.
; (FCB 2005-04-12) To get the MRS to scope link LTOP.

comma-lex := lexical_sign &
             [SYNSEM [LOCAL [CAT [VAL super-saturated,
				  HEAD.MOD < [LOCAL scopal-mod &
						    [CONT.HOOK.LTOP #ltop]] >],
			     ARG-S < >,
                             CONT[ HOOK.LTOP #ltop,
                                   RELS <! !>,
                                   HCONS <! !> ],
                             CTXT.BACKGROUND <! !>],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]],
              INFLECTED +].

; <type val="comma-pmod-lex">
; <name-ja>承助詞読点
; <description>p-lexやs-conj-lexの直後につく読点「、」。
; <ex>私 が 、 行く
; <ex>私 が 行く と 、 彼 が 帰る
; <ex>私 の 、 本
; <nex>行き 、 帰る
; <todo>
; </type>
comma-pmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-pmod_head].

; <type val="comma-advmod-lex">
; <name-ja>承副詞読点
; <description>副詞やdate-nounなどをADV_NP_RULEによって副詞化したものにつく読点「、」。
; <ex>いよいよ 、 松井 の 登場 だ
; <nex>右 、 左 を 見る
; <todo>
; </type>
comma-advmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-advmod_head].

comma-sapmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-sapmod_head].

comma-infvmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-infvmod_head].

comma-vmod1-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-vmod1_head].

comma-vmod2-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-vmod2_head].

; <type val="comma-interjmod-lex">
; <name-ja>承感動詞読点
; <description>interj-lexの後につく読点「、」。
; <ex>エッ 、 僕 です
; <nex>右 、 左 です
; <todo>(TK 07-04-09)excl-lexやgreeting-lexにつくtypeも必要ではないか。
; (lkb::do-parse-tty "どうも 、 夕刊 です")(lkb::do-parse-tty "さようなら 、 また 来る")
; </type>
comma-interjmod-lex := comma-lex &
                  [SYNSEM.LOCAL.CAT.HEAD comma-interjmod_head].

; (ERB 2002-01-14) Special comma entry that picks up infinitival
; verbs and gives them a CMOD value.  To get semantics right,
; copy up LTOP, INDEX, from the OBJ.

; (ERB 2002-01-15) Restrict this to OBJs that are C-MOD null to
; keep real TE forms out.

comma-lex-2 := lexical_sign &
[SYNSEM [LOCAL [CAT [ VAL obj-arg & [ UNSAT +,
				      COMPS obl-1-arg & #comps &
					    [FIRST.LOCAL [ CAT [ HEAD verb_head &
								      [ FIN -,
									ADJ -,
									VN -,
									C-MOD null,
									MODUS infinitive],
								 VAL saturated ],
							   CONT [ HOOK #hook ]]]],
		      HEAD punct_head2],
		ARG-S #comps,
                CONT[ RELS <! !>,
                      HCONS <! !>,
                      HOOK #hook ],
                CTXT.BACKGROUND <! !>],
         NON-LOCAL [QUE <! !>,
                 AFFIX <! !>]],
 INFLECTED +].


; <type val="parenthesis-end-lex">
; <name-ja>普通括弧閉
; <description>parenthesis-init-lexを参照。このtypeは閉じる（横書きなら右側、縦書きなら下側に来る）方。
; <ex>主人公 は ポチ （ 犬 ） です
; <nex>主人公 は ポチ ） 犬 ） です
; <nex>主人公 は ポチ 【 犬 ） です
; <todo>parenthesis-init-lexを参照。
; </type>
parenthesis-end-lex := lexical_sign &
             [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg & 
				   [COMPS obl-2-args & #comps &
					  < [LOCAL [CAT [HEAD head & [QUANTIFIABLE +],
							   VAL saturated],
						      CONT.HOOK #hook]],
					      [LOCAL.CAT.HEAD parent-init_head] >],
				  HEAD parent-end_head], 
			     ARG-S #comps,
			     CONT[ HOOK #hook,
				   RELS <! !>,
				   HCONS <! !> ],
			     CTXT.BACKGROUND <! !>],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]],
              INFLECTED +].


; <type val="parenthesis-init-lex">
; <name-ja>普通括弧開
; <description>開く記号と閉じる記号を併せて用い、それらに囲まれた部分を他の部分と別個に扱う場合に用いる。
; このtypeは開く（横書きなら左側、縦書きなら上側に来る）方。このtypeによって引用文も作ることができる
; （ただしこのtypeで登録されているものは本来引用文には使われない）。また、これら括弧開と括弧閉は１つ１つ
; 対応関係になっているが、現状では「（ 犬 ＞」のように違うものどうしでも解析できてしまう。
; <ex>主人公 は ポチ （ 犬 ） です
; <nex>主人公 は ポチ （ 犬 】 です
; <nex>主人公 は ポチ （ 犬 （ です
; <todo>(TK 07-03-23)やはり括弧開と括弧閉は１つ１つの対応関係にするべき。
; </type>
parenthesis-init-lex := lexical_sign &
                        [SYNSEM [LOCAL [CAT [HEAD parent-init_head,
                                             VAL super-saturated],
					ARG-S < >,
                                        CONT[ RELS <! !>,
                                              HCONS <! !> ],
                                        CTXT.BACKGROUND <! !>],
                                 NON-LOCAL [QUE <! !>,
                                         AFFIX <! !>]],
                         INFLECTED +].




quotation-name-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL super-saturated,
                                           HEAD quotation-name-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].



quotation-name-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					    [COMPS obl-2-args & #comps &
						   < [LOCAL.CAT [HEAD name_head,
							     VAL saturated]],
						 [LOCAL.CAT.HEAD quotation-name-init_head] > ],
					   HEAD quotation-name-end_head],
				      ARG-S #comps,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +]. 


quotation-noun-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL super-saturated,
                                           HEAD quotation-noun-init_head],
				      ARG-S < >,
                                      CONT  [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


quotation-noun-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL [CAT [HEAD noun_head,
									VAL saturated],
                                                                    CONT.HOOK #hook ]],
						 [LOCAL.CAT.HEAD quotation-noun-init_head] > ],
					   HEAD quotation-noun-end_head],
				      ARG-S #comps,
                                      CONT [ HOOK #hook,
                                             RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +]. 


quotation-sentence-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL super-saturated,
                                           HEAD quotation-sentence-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].

; (MS 2004-08-24) linked INDEX and XARG to INDEX and XARG of the complement.
; (MS 2004-12-15) we need to link the whole HOOK, which can then be accessed by 
; conjunctions (「 居る 」 や 「 来る 」 や 「 行く 」 の 尊敬語 。)

quotation-sentence-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL [CAT [HEAD verb_head,
								    VAL saturated],
							       CONT [ HOOK #hook]]],
						       [LOCAL.CAT.HEAD quotation-sentence-init_head] >],
					   HEAD quotation-sentence-end_head],
				      ARG-S #comps,
				      CONT [ HOOK #hook,
					     RELS <! !>,
					     HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
			       NON-LOCAL [QUE <! !>,
					  AFFIX <! !>]],
		       INFLECTED +].


quotation-sap-init-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL super-saturated,
                                           HEAD quotation-sap-init_head],
				      ARG-S < >,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


quotation-sap-end-lex := lexical_sign &
                      [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
					     [COMPS  obl-2-args & #comps &
						     < [LOCAL.CAT [HEAD noun_head,
							     VAL saturated]],
						 [LOCAL.CAT.HEAD quotation-sap-init_head] >],
					   HEAD quotation-sap-end_head],
				      ARG-S #comps,
                                      CONT [ RELS <! !>,
                                              HCONS <! !> ],
                                      CTXT.BACKGROUND <! !>],
                               NON-LOCAL [QUE <! !>,
                                       AFFIX <! !>]],
                       INFLECTED +].


; (MS 2004-12-20) This is for definition sentences, such as 「 来る 」 の 尊敬語
; (FCB 2008-02-20) restrict to things with an event index (e.g. not nouns)
; as they have their own quotation-noun-end-lex
; allow only sentence-valid (not utterances).
quotation-definition-end-lex :=  lexical_sign &
 [SYNSEM [LOCAL [CAT [VAL obj-obj2-arg &
			  [COMPS  obl-2-args & #comps &
				  < [LOCAL [CAT [HEAD sentence-valid & 
						      [EMPTY -],
						 VAL saturated],
					    CONT.HOOK [LTOP #vlabel,
						       INDEX event]]],
				    [LOCAL.CAT.HEAD quotation-noun-init_head] >],
		      HEAD quotation-definition-end_head],
		 ARG-S #comps,
		 CONT [HOOK [LTOP #ltop,
			     INDEX #index],
		       RELS <! #key  & noun-arg1-relation &
			     [LBL #ltop,
			      PRED "nom_rel",
			      ARG0 #index,
			      ARG1 #arg1],
			     quant-relation & 
			     [PRED udef_q_rel,
			      ARG0 #index,
			      RSTR #rstr]  !>,
		       HCONS <! qeq & [HARG #rstr, LARG #ltop],
			      qeq & [HARG #arg1, LARG #vlabel] !> ],
		 CTXT.BACKGROUND <! !>],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>],
	  LKEYS.KEYREL #key],
  INFLECTED +].
                       

; <type val="ordinary-nohon-n-lex">
; <name-ja>普通名詞
; <description>日本語で一般的に普通名詞とよばれるもの。助詞を伴って主語・述語・目的語などになることができる。
; 活用はしない。
; <ex>犬 が 吠える
; <ex>猫 の 犬 で ある 
; <nex>犬 する 
; <todo>
; </type>
ordinary-nohon-n-lex := ordinary-n-lex & [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; Idiom Implementation (CH 060804)
; (CH 2006-08-04) Introduced idiom-A-noun-lex, which is an idiom that
;  is completely fixed and unambiguous and corresponds to a noun.
; <type val="idiom-A-noun-lex">
; <name-ja>
; <description>慣用表現で使われている普通名詞。
; <ex>
; <nex>
; <todo>
; </type>
idiom-A-noun-lex := ordinary-nohon-n-lex.

; (MS 2003-12-19) Matrix 0.6

; <type val="ordinary-nohon-indef-n-lex">
; <name-ja>普通名詞不定称連語
; <description>不定称の普通名詞。このtypeは「wh-word+か」の形を取っているが、WH疑問の意味を表さず、また代名詞
; でもない。
; <ex>いくつか の 時計
; <nex>いくつか は 知ら ない
; <todo>(TK 07-05-08)複合名詞を作れてしまうが、複合名詞で使うことはないので修正すべき。
; (TK 07-05-08)副詞的な働きもできるようにすべき(lkb::do-parse-tty "時計 が いくつか ある")。
; (TK 07-05-08)なぜ「何か」がこのtypeで、「何 か」がordinary-nohon-plusbar-indefspec-n-lexなのか不明。
; </type>
ordinary-nohon-indef-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY indef_q_rel].

; <type val="ordinary-nohon-minusbar-n-lex">
; <name-ja>普通名詞要複合
; <description>ordinary-nohon-n-lexを参照。ただしこのtypeは必ず他の名詞（名詞句）やnoun_mod-lex-rとともに現れる。
; 他の名詞（名詞句）とはCOMPOUNDS-RULEで、noun_mod-lex-rとはSUFFIX-RULEで直結される。
; <ex>
; <ex>
; <nex>
; <todo>(TK 07-04-23)普通名詞でも使いそうなもやsuffixかprifixとしてしか使わないもの、またsuffixでもprifixでも
; 使うが意味が異なるもの（「来」など）などの、このtypeでは適当でないものしか登録されていなかったので、
; 全て他のtypeに移した。
; このtypeは使わない（あるいは削除する）方向で検討。
; </type>
ordinary-nohon-minusbar-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.BAR -].
; <type val="ordinary-nohon-plusbar-n-lex">
; <name-ja>普通名詞非複合
; <description>ordinary-nohon-n-lexを参照。ただしこのtypeは複合名詞を作らない。
; <ex>いつも の 席 に 座る
; <nex>いつも 本 を 読む
; <todo>
; </type>
ordinary-nohon-plusbar-n-lex := ordinary-nohon-n-lex & [SYNSEM.LOCAL.BAR +].

; (MS 2005-11-09) To get rid of skip files.

; <type val="ordinary-nohon-threepl-n-lex">
; <name-ja>普通名詞三人称複数
; <description>ordinary-nohon-n-lexを参照。このtypeは三人称複数形を表す。日本語では一般的に通常の普通名詞として
; 扱われることが多い。
; <ex>人々 が 笑う
; <nex>
; <todo>(TK 07-04-11)「人々」「子供 達」の登録しかないが、少なくともこれらは複合名詞を作らないのではないか。
; </type>
ordinary-nohon-threepl-n-lex := ordinary-nohon-n-lex & [SYNSEM.LKEYS.KEYREL.ARG0.PNG.PN threepl].

; <type val="ordinary-nohon-plusbar-indefspec-n-lex">
; <name-ja>普通名詞不定称連語非複合
; <description>ordinary-nohon-indef-n-lexを参照。ただしこのtypeは、複合名詞を作らない。
; <ex>何 か の はずみ
; <nex>何 か は 知ら ない
; <todo>(TK 07-05-08)副詞的な働きもできるようにすべき(lkb::do-parse-tty "理由 が 何 か ある")。
; (TK 07-05-08)なぜ「何 か」がこのtypeで、「何か」がordinary-nohon-indef-n-lexなのか不明。
; </type>
ordinary-nohon-plusbar-indefspec-n-lex := ordinary-nohon-plusbar-n-lex & 
[SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LKEYS.KEYREL.PRED "_indef_n_rel"].


; (MS 2004-12-24) Changed the name from ordinary-nohon-minusbar-right-n-lex.
; (MS 2005-07-04) But we have the noun_mod-lex-r and noun_mod-lex-l for these!

;ordinary-suffix-n-lex := ordinary-nohon-minusbar-n-lex & 
;				       [SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD right].

; (MS 2004-12-24) Changed the name from ordinary-nohon-minusbar-left-n-lex.

;ordinary-prefix-n-lex := ordinary-nohon-minusbar-n-lex & 
;				       [SYNSEM.LOCAL.CAT.HEAD.J-POSTHEAD left].



; <type val="ordinary-honsubj-n-lex">
; <name-ja>普通名詞尊敬
; <description>ordinary-nohon-n-lexを参照。ただしこのtypeは敬意を表される対象である人・物などに使われる。
; <ex>御社 が なさる 業務
; <nex>
; <todo>
; </type>
ordinary-honsubj-n-lex := ordinary-n-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                         CONT.HOOK.INDEX #1,
                                         CTXT [C-INDICES.SPEAKER #2,
                                               BACKGROUND <! obj-honor_rel &
                                                           [POLARITY +,
                                                            HONORER #2,
                                                            HONORED #1] !>]]].

; <type val="ordinary-honsubj-plusbar-n-lex">
; <name-ja>普通名詞尊敬不複合
; <description>ordinary-honsubj-n-lexを参照。ただしこのtypeは複合名詞を作らない。
; <ex>先生 が いらっしゃる
; <nex>橋本 先生
; <todo>
; </type>
ordinary-honsubj-plusbar-n-lex := ordinary-honsubj-n-lex &
				  [SYNSEM.LOCAL.BAR +].



ordinary-honobj-n-lex := ordinary-n-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
                             CONT.HOOK.INDEX #1,
                             CTXT [C-INDICES.SPEAKER #2,
				BACKGROUND <! obj-honor_rel &
                                                   [POLARITY +,
                                                    HONORER #2,
                                                    HONORED #1] !>]]].



;TITLE

; (MS 2002-1-7) This had to be changed because it's not allowed to have one index identified between two words.
; It's kind of hacked to parallel the English solution. I still believe in the head-specifier construction here.
; (FCB 2007-05-18) Try it as more like noun_mod - I think we want the noun to be head, not the title

title-lex := lexical_sign &
[SYNSEM [LKEYS.KEYREL #key,
	  LOCAL [CAT [HEAD noun_mod_head-avm &  
			   [J-POSTHEAD right,
			    MOD < [LOCAL intersective-mod &
					 [ CONT.HOOK [INDEX #nameind,
						      LTOP #handle]]] > ], 
		      VAL super-saturated],
		 ARG-S < >,
		 CONT nominal-sign-sem-type &
		     [HOOK [INDEX #titleind],
		      RELS <! #key &
			    [LBL #titlehand,
			     ARG0 #titleind],
			    [PRED udef_q_rel,
			     ARG0 #titleind,
			     RSTR #restr],
			    title-id-relation &
			    [ARG1 #titleind,
			     ARG2 #nameind,
			     LBL #handle] !>,
		      HCONS <! qeq & [LARG #titlehand,
				      HARG #restr]!>],
		 BAR -],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]], 
 INFLECTED +].
                               
; (MS 2005-03-15) Institutions can attach to all kinds of names, like 田中大学。

; <type val="title-inst-lex">
; <name-ja>称号接尾辞組織
; <description>固有名詞の直後について、組織名を作る接尾辞。
; <ex>田中 大学
; <ex>ボンド 研究室
; <nex>移動 研究室
; <todo>(TK 07-04-25)ordinary-nohon-n-lexやvn-lexの後について組織名を作るtypeも必要。
; (lkb::do-parse-tty "考古学 研究室")(lkb::do-parse-tty "衆議院 予算 委員会")
; </type>
title-inst-lex := title-lex & 
[SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD name_head].


; (MS 2001-12-14) Changing the SPR from pn_head to noun_head, because some titles (sama) can be attached to functions. 
; e.g. GAKUSEI SAMA. 
; (MS 2005-10-21) I want the title to have its own pred: it's a difference between "san" and "shachou"!

title-pers-lex := title-lex & 
[SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD noun_head].


; <type val="title-pers-honsubj-lex">
; <name-ja>称号接尾辞人名尊敬
; <description>名詞（固有名詞を含む）の直後について、それに対する敬意を添える接尾辞。
; <ex>中村 様
; <ex>お 星 様
; <nex>その 様 は まさに 地獄 だ
; <todo>
; </type>
title-pers-honsubj-lex := title-pers-lex &
 [SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
                CONT.HOOK.INDEX #1,
                CTXT [C-INDICES.SPEAKER #2,
                      BACKGROUND <! obj-honor_rel &
                                  [POLARITY +,
                                   HONORER #2,
                                   HONORED #1] !>]]].

; <type val="title-pers-minus-honsubj-lex">
; <name-ja>称号接尾辞人名非尊敬
; <description>title-pers-honsubj-lexを参照。ただしこのtypeは敬意を表すべき相手には使えない。
; <ex>中村 君
; <ex>バイト 君
; <nex>君 は 誰 だ
; <todo>
; </type>
title-pers-minus-honsubj-lex := title-pers-lex  &
 [SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
                CONT.HOOK.INDEX #1,
                CTXT [C-INDICES.SPEAKER #2,
                      BACKGROUND <! obj-honor_rel &
                                  [POLARITY -,
                                   HONORER #2,
                                   HONORED #1] !>]]].


;WH-WORDS

; (ERB 2001-10-04) In order to keep adv_np_rule from over applying,
; I'm going to constrain these to be KEY reg-nom_rel.
; (MS 2003-12-19) Matrix 0.6

wh-word-lex  := n-lex &  
                     [SYNSEM [LOCAL [CAT [VAL noun_sc & [SPR #spr & [FIRST.LOCAL.CAT.HEAD.KEYS.KEY which_q_rel]],
                                          HEAD temporal-noun_head & [MOD null]],
				     ARG-S #spr,
                                     CONT [HOOK.LTOP #top,
                                           RELS <! #key !>,
                                           HCONS <! !>]],
			      LKEYS.KEYREL #key & reg-nom-relation & [LBL #top],
                              NON-LOCAL [QUE <! #top !>,
                                      AFFIX <! !>]]].

; (ERB 2001-09-19) We were getting massive overgeneration in 
; sentences like Xはどこですか because the SUBCAT values of どこ
; which is an instance of this type was completely underspecified.
; Fixing that.

; (ERB 2001-09-19) Sentences with いつ and どこ aren't producing
; scopable MRSs, so I'm working on the semantics of this type.
; Also, I don't see why どこ is a temp_rel, so I'm going to split
; this type.


; (ERB 2001-11-14) Adding dokoka and itsuka, which have a lot
; in common with doko and itsu, so I'm making a supertype.


quant-word-temp-or-place-lex := n-lex &
                    [SYNSEM [LOCAL [CAT [ HEAD temporal-noun_head & [MOD null],
                                          VAL super-saturated ],
				    ARG-S < >,
                                    CONT [RELS <! #key & noun-relation &
                                                    [ LBL #h,
                                                      ARG0 #ind ],
                                                    quant-relation & 
                                                    [ ARG0 #ind,
                                                      RSTR #h2 ] !>,
                                           HCONS <! qeq &
                                                     [ HARG #h2,
                                                       LARG #h ] !> ]],
			     LKEYS.KEYREL #key,
                             NON-LOCAL [AFFIX <! !>]]].

wh-word-temp-or-place-lex := quant-word-temp-or-place-lex &
[ SYNSEM [ LOCAL.CONT [ RELS.LIST.REST.FIRST.PRED which_q_rel,
                        HOOK.LTOP #top ],
           NON-LOCAL.QUE <! #top !> ]].

indef-word-temp-or-place-lex := quant-word-temp-or-place-lex &
[ SYNSEM [ LOCAL.CONT.RELS.LIST.REST.FIRST.PRED indef_q_rel,
           NON-LOCAL.QUE <! !> ]].

; (ERB 2001-10-03) Chaning the hierarchy for temporal relations.
; いつ behaves like 去年 or 翌日 in terms of occurring as a modifier
; without に, so it's relation is a non-future-date_rel.  (Was
; temp_rel.)

; <type val="wh-word-temp-lex">
; <name-ja>疑問代名詞時間
; <description>当該の場所がどこであるかを尋ねるときに使う代名詞。このtypeがある文は必ず疑問文になる。
; また、date-nounのようにADV_NP_RULEによって副詞的に働くこともできる。
; <ex>いつ 行く
; <ex>いつ の 話 だ
; <nex>
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "いつ だ か 知ら ない")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "いつ どこ に 行く")。
; </type>
wh-word-temp-lex := wh-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL non-future-date-relation     ].

; <type val="wh-word-place-lex">
; <name-ja>疑問代名詞場所
; <description>当該の場所がどこであるかを尋ねるときに使う代名詞。このtypeがある文は必ず疑問文になる。
; <ex>どこ に 行く
; <nex>
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "どこ でも 良い")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "いつ どこ に 行く")。
; </type>
wh-word-place-lex := wh-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL place-relation ].

; <type val="wh-word-person-lex">
; <name-ja>疑問代名詞人
; <description>当該の人が誰であるかを尋ねるときに使う代名詞。このtypeがある文は必ず疑問文になる。
; <ex>誰 が 行く
; <nex>誰 か い ない か
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "誰 でも 良い")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "いつ 誰 と 行く")。
; </type>
wh-word-person-lex := wh-word-temp-or-place-lex &
[ SYNSEM [LOCAL.CAT.HEAD.KEYS.KEY pron_rel,
	  LKEYS.KEYREL  pron-relation]].

; <type val="wh-word-thing-lex">
; <name-ja>疑問代名詞物
; <description>当該の物が何であるかを尋ねるときに使う代名詞。このtypeがある文は必ず疑問文になる。
; <ex>何 を 読む
; <nex>何 金 が 無い の か
; <todo>(TK 07-03-22)必ずしも疑問文で使われるとは限らない。間接疑問？
; (lkb::do-parse-tty "何 が あっ て も 行く")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "いつ 何 を 買う か")。
; </type>
wh-word-thing-lex := wh-word-temp-or-place-lex &
[ SYNSEM [LOCAL.CAT.HEAD.KEYS.KEY pron_rel,
	  LKEYS.KEYREL  pron-relation]].


; (ERB 2001-11-14) itsuka and dokoka.

; <type val="indef-word-temp-lex">
; <name-ja>不定称連語・時間
; <description>「不定称の時間代名詞+か」で構成される連語。不特定の時間を表し、１個の名詞あるいは副詞
; のように働く。この連語そのものは疑問を表すものではない。
; <ex>いつか 直す
; <nex>新作 の 発売 は いつか
; <todo>
; </type>
indef-word-temp-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL non-future-date-relation ].

; <type val="indef-word-place-lex">
; <name-ja>不定称連語・場所
; <description>「不定称の場所代名詞+か」で構成される連語。不特定の場所を表し、１個の名詞あるいは副詞
; のように働く。この連語そのものは疑問を表すものではない。
; <ex>そろそろ どこか に 落ち着き たい
; <nex>醤油 が ある の は どこか
; <todo>
; </type>
indef-word-place-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL place-relation ].

; (ERB 2001-11-14) dareka

; <type val="indef-word-person-lex">
; <name-ja>不定称連語・人
; <description>「不定称の人称代名詞+か」で構成される連語。不特定の人を表し、１個の名詞あるいは副詞
; のように働く。この連語そのものは疑問を表すものではない。
; <ex>そこ に 誰か が 居る
; <nex>そこ に 居る の は 誰 か
; <todo>
; </type>
indef-word-person-lex := indef-word-temp-or-place-lex &
[ SYNSEM.LKEYS.KEYREL reg-nom-relation & [ PRED "person" ]].

; (ERB 2001-10-04) My new adv_np_rule, meant for date expressions,
; is applying to いくら because the type of its key isn't sufficiently
; constrained.  I'm going to say it's a reg-nom_rel for now.

; <type val="wh-word-quantity-lex">
; <name-ja>疑問代名詞数量
; <description>当該のものの数量がどのくらいであるかを尋ねる場合に使う代名詞。このtypeがあるとその文
; は必ず疑問文になる。
; <ex>パン は いくら です か
; <nex>いくら 君 でも 無理 だ
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "いくら でも 出す")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "誰 が いくら 出す か")。
; </type>
wh-word-quantity-lex  := n-lex &
                    [SYNSEM [LOCAL [CAT [HEAD temporal-noun_head & [MOD null],
                                         VAL noun_sc & [SPR #spr & [FIRST.LOCAL.CAT.HEAD.KEYS.KEY which_q_rel]]],
				    ARG-S #spr,
                                    CONT [RELS <! #key,
                                                   [PRED "part-of_rel",
                                                    LBL #h1,
                                                    ARG0 #x1],
						quant-relation & 
						[PRED udef_q_rel,
						 ARG0 #x1,
						 RSTR #h2]!>,
                                          HCONS <! qeq & [HARG #h2,
                                                           LARG #h1] !>,
                                          HOOK.LTOP #top]],
			     LKEYS.KEYREL #key & reg-nom-relation,
                             NON-LOCAL [QUE <! #top !>,
                                     AFFIX <! !>]]].

                  




; <type val="wh-word-honsubj-lex">
; <name-ja>疑問代名詞人尊敬
; <description>wh-word-person-lexを参照。このtypeは敬意を表される対象である人に使われる。
; <ex>どなた が 来る か
; <nex>
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "どなた でも 良い")
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "どなた が どこ に いらっしゃる か")。
; </type>
wh-word-honsubj-lex := wh-word-person-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON +,
               CONT.HOOK.INDEX #1,
               CTXT [C-INDICES.SPEAKER #2,
                     BACKGROUND <! obj-honor_rel &
                                 [POLARITY +,
                                  HONORER #2,
                                  HONORED #1] !>]]].


; (MS 2001-10-18) A new analysis for koto that takes a VP.
; (ERB 2002-01-14) In an attempt to rein in non-prop GA, I made
; things like "tabeta" [SMOD unmarked].  Change the requirement
; on the SPR here from [SMOD decl] to [SMOD unmarked].
; (MS 2003-10-08) Problems with Matrix 0.5?
; (FCB 2004-01-07) Fixed problem with koto HOOK by coindexing INDEX with ARG0
; (MS 2004-12-17) But it should not take an empty copula.
; (MS 2005-01-26) BAR + on the SPR is not right, VNs for nom-pred-vn-lex are not BAR +
; (FCB 2005-03-01) but we need BAR+ on the SPR for nom-pred-lex
; (MS 2005-06-24) The verb should be plain form: "食べること", "*食べますこと"
; (FCB 2005-06-27) Added ARG0 to message 

nom-pred-lex-basic := nom-lex & 
       [SYNSEM [LOCAL [CAT [VAL.SPR.FIRST [LOCAL [CONT.HOOK.LTOP #verb-hand,
						 CAT [HEAD verb_head & 
							   [MAIN-PRD -,
							    MODUS uttmodus,
							    FORMAL.AHON -,
							    SMOD unmarked,
							    EMPTY -]],
						  BAR bool]]],
                      CONT  nom-pred-sem-type &
			   [RELS <! [ PRED #k-pred,
				      LBL #nom-hand,
				      ARG0 #i,
				      ARG1 #nom-arg],
				  quant-relation & 
				  [ PRED udef_q_rel,
				    ARG0 #i, 
				    RSTR #restr] !>,
			    HOOK [LTOP #nom-hand,
				  INDEX #i],
                           HCONS <! qeq &
                                   [HARG #restr,
                                    LARG #nom-hand],
                                   [HARG #nom-arg,
                                    LARG #verb-hand] !> ]],
		LKEYS.KEYREL.PRED #k-pred]].

; (FCB 2005-03-01) added BAR+ on the SPR for nom-pred-lex
; removes spurious ambiguity for e.g., (do-parse-tty "見積もる こと")
; <type val="nom-pred-lex">
; <name-ja>承用言形式名詞
; <description>nom-common-lexを参照。このtypeはi-adj-lex、動詞、助動詞の連体形などを受ける。
; <ex>割っ た の は 誰 だ
; <ex>見積もる こと
; <ex>台風 が 来る 時 は 行か ない
; <ex>元気 な こと は 素晴らしい
; <nex>出発 し 時 に 雨 が 降っ た
; <todo>
; </type>
nom-pred-lex := nom-pred-lex-basic & 
 [SYNSEM.LOCAL.CAT [VAL nom_sc & [SPR.FIRST.LOCAL[ CAT.VAL saturated,
						   BAR +]]]].

; <type val="nom-pred-vn-lex">
; <name-ja>承サ変接尾辞名詞化
; <description>サ変を受けて、完了の意味を持つ名詞句を作る。
; <ex>ドキュメント は 作成 済 です
; <ex>使用 済 の オイル は 捨てる
; <nex>ドキュメント は 作り 済 です
; <todo>(TK 07-04-06)vn-intrans-lexにしかつくことができない点は修正すべき。
; </type>
nom-pred-vn-lex := nom-pred-lex &
		   [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD vn_head].

; <type val="nom-exceptional-pred-lex">
; <name-ja>承用言形式名詞形容動詞化
; <description>nom-pred-leを参照。このtypeはi-adj-lex、動詞、助動詞の連体形を受けてna-adjの
; ような働きをするものを作る。
; <ex>行く よう だ
; <ex>暖かい よう な 気 が する
; <ex>面倒 な よう だ
; <nex>来 よう な 気配 が ない
; <todo>
; </type>
nom-exceptional-pred-lex :=  nom-pred-lex &
			     [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].




; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.

; <type val="nom-common-lex">
; <name-ja>承連体詞形式名詞
; <description>日本語で一般的に形式名詞と言われるもの。名詞のうち、単独で働くことができず、必ず
; 他の語を受ける。文頭に来ることはなく、複合名詞を作ることもない。このtypeはdet-lexやdet-wh-lexを受ける。
; <ex>そんな 事 は 無い
; <nex>事 は 急 を 要する
; <todo>
; </type>
nom-common-lex := nom-lex & lexical_sign-word &
                  [SYNSEM [LKEYS.KEYREL #key & [ARG0 #i],
			   LOCAL [CAT.VAL nom_sc & [SPR.FIRST.LOCAL [CAT.HEAD det_head & [SMOD decl]]],
				  CONT common-noun-sem-type &
							  [HOOK.INDEX #i,
							   RELS <! #key !>,
							   HCONS <! !> ]]]].

; <type val="nom-exceptional-common-lex">
; <name-ja>承連体詞形式名詞形容動詞化
; <description>nom-common-lexを参照。このtypeはdet-lexを受けて、na-adj-lexのような働きの句を作る。
; <ex>あの よう な 人
; <ex>その よう だ
; <nex>行く よう だ
; <todo>
; </type>
nom-exceptional-common-lex := nom-common-lex &
			      [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].

; (ERB 2001-11-07) Need a supertype for nominalizers that is
; like nouns but inherits from lexical_sign and not
; lexical_sign-word.  nom-lex inherits from this supertype.
; Non-nominalizer subtypes of nom-lex will also get 
; lexical_sign-word.

; (MS 2003-01-15) The co-indexing of the SPRs handel with the LTOP handel leads to not scoping MRSs. Took that out.
; (FCB 2005-04-11) Added  SYNSEM.LOCAL.CAT.HEAD.MOD null, to stop 
; interjections popping up all over the place in (do-parse-tty "これ の こと が 起きる")

; <type val="nom-dummy-lex">
; <name-ja>承助詞形式名詞
; <description>nom-common-lexを参照。このtypeは「名詞+の（連体修飾の助詞）」の形を受ける。
; <ex>鉄道 の こと に 詳しい
; <ex>これ の こと が 起きる
; <nex>
; <todo>
; </type>
nom-dummy-lex := nom-lex & lexical_sign-word &
 [SYNSEM [LOCAL [CAT [VAL nom_sc & 
			  [SPR.FIRST.LOCAL  [CAT.HEAD nspec-p_head & 
						      [SMOD decl],
					     CONT [HOOK.INDEX #spri]]]],
		 CONT nom-sem-type &
		     [HOOK.INDEX #i,
		      RELS diff-list & 
				 <! #key,
				  unspec-compound-relation & 
				  [PRED compound_rel,
				   ARG2 #spri,
				   ARG1 #i] !>,
		      HCONS <! !>]],
	  LKEYS.KEYREL #key & [ARG0 #i]]].

; <type val="nom-exceptional-dummy-lex">
; <name-ja>承助詞形式名詞形容動詞化
; <description>nom-dummy-lexを参照。このtypeは「名詞+の（連体修飾の助詞）」の形を受けてna-adj-lexの
; ような働きをするものを作る。
; <ex>夢 の よう な 生活
; <nex>夢 な よう な 生活
; <todo>
; </type>
nom-exceptional-dummy-lex := nom-dummy-lex &
 [SYNSEM.LOCAL.CAT.HEAD exceptional_noun_head].


; (MS 2005-01-27) This seems not to be used any more.

;nom-transitive-lex := nom-lex & lexical_sign-word &
;       [SYNSEM [LOCAL [CAT [VAL nom_sc & [SPR.FIRST.LOCAL [CAT.HEAD nspec-p_head & [SMOD decl];,
;                                                 CONT [HOOK.INDEX #spri]]]],
;                      CONT nom-sem-type &
;                          [HOOK [INDEX #i],
;                           RELS diff-list & 
;                                 <! #key !>,
;                           HCONS <! !>]],
;		LKEYS.KEYREL #key & [ARG0 #i, ARG1 #spri]]].


;;;;;;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- adjectives;;;;;;;;;;;;;;;;;;


adj-lex := lexical_sign-word & 
           [SYNSEM [LOCAL [CAT.HEAD adj_head,
                           BAR +],
                    NON-LOCAL.AFFIX <! !>]].

;;; FCB linked LBL to TOP (also done in na-adj-sem-type-basic)

na-adj-stem-lex  := adj-lex & 
 [SYNSEM.LOCAL [CAT.HEAD na-adj-basic_head & 
			 [MAIN-PRD -,
			  MOD null],
		CONT [ HOOK [INDEX #event,
			     LTOP #handle],
		       RELS <! [ARG0 #event,
				LBL #handle] !>,
		       HCONS <! !>],
		BAR +],
  J-NEEDS-AFFIX -,
  INFLECTED +].

na-adj-basic-lex := na-adj-stem-lex & 
  [SYNSEM [LOCAL [CAT [ VAL adj_sc & 
			   [SUBJ #sbj & [FIRST.LOCAL.CONT.HOOK.INDEX #arg]]],
		 ARG-S #sbj,
		 CONT na-adj-sem-type & [HOOK.XARG #arg,
					 RELS <! #key !>]],
	  LKEYS.KEYREL #key & [ARG1 #arg]]].
; <type val="na-adj-lex">
; <name-ja>形容動詞語幹
; <description>日本語で一般的に形容動詞と呼ばれているものの語幹。後に助動詞「だ」「なり」「たり」を伴う。
; 本来はその３つのうちのどれを伴うかでtypeを分けなければいけないが、現状では１つに混同されている。
; 「堂々」は「たり」しか伴わないが「はるか」は「だ」「なり」どちらでも異和感がないので２つのtypeでも
; よいかもしれない。
; <ex>彼 の やり方 は 強引 だ
; <nex>強引 し て 割り込ん だ
; <todo>
; </type>
na-adj-lex := na-adj-basic-lex & [SYNSEM.NON-LOCAL [QUE <! !>]].

na-adj-negative-lex := na-adj-lex & [SYNSEM [LOCAL.CAT.HEAD.MODUS negative,
                                             NON-LOCAL [QUE <! !>]]].

; (MS 2005-03-30) This seems not to be used any more.
;exceptional-adj-lex := adj-lex & [SYNSEM [LOCAL [CAT [HEAD exceptional-adj_head,
;                                                      VAL adj_sc & [SUBJ #sbj & [FIRST.LOCAL.CONT.HOOK.INDEX #arg]]],
;						 ARG-S #sbj,
;                                                CONT na-adj-sem-type & [RELS <! #key !>,
;									HOOK.XARG #arg],
;                                                BAR +],
;					  LKEYS.KEYREL #key & [ARG1 #arg],
;                                          NON-LOCAL [QUE <! !>]]].

na-adj-wh-lex := na-adj-basic-lex &
             [SYNSEM [NON-LOCAL.QUE <! #top !>,
                      LOCAL.CONT.HOOK.LTOP #top]].

; (MS 2002-05-02) this is for 的 that is separated by CHASEN.
; (MS 2004-12-21) but wrongly assumed that this modifies its noun. it should be the
; head of the phrase in 時間的な継続, such that it can be subcategorized for by な

; <type val="na-adj-suffix-lex">
; <name-ja>接尾辞形容動詞化
; <description>名詞の直後にあって形容動詞の語幹に近いものを作る。na-adj-lexのような働きをする他、
; 他の用言や助動詞なしにrelative clauseを作れる。ただし、現状では直後に「に」をつけて副詞的に働く
; ことができず、また、直後に名詞がついた場合はrelative clauseのうちのsubject gapとしてしか解析できない。
; <ex>時間 的 な 継続
; <ex>時間 的 継続
; <ex>時間 的 に 継続 する
; <ex>平和 的 な 解決
; <ex>平和 的 解決
; <ex>平和 的 に 解決 する
; <nex>平和 的 解決 する
; <todo>(TK 07-04-11)直後に「に」をつけて副詞的に働けるようにすべき(lkb::do-parse-tty "平和 的 に 解決 する")。
; (TK 07-04-11)adverbを格として取る動詞の場合にも解析できない(lkb::do-parse-tty "考え が 革新 的 に なる")。
; (TK 07-04-11)また、上記の例にある(lkb::do-parse-tty "時間 的 継続")のような場合、「時間 的 /継続」で
; REL-CL-SBJ-GAP-RULEしか出ない点は、RELATIVE-CLAUSE-RULEも出せるようにした方が良いかもしれない（「継続が
; 時間的だ」という解析に疑問があるため）。
; </type>
na-adj-suffix-lex := na-adj-stem-lex & 
 [SYNSEM [LOCAL [CAT [HEAD [MODUS indicative,
			    MAIN-PRD -],
		      VAL sbj-narg_transitive & 
			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			    COMPS.FIRST [OPT -,
					 LOCAL.CONT.HOOK.INDEX #objind]]],
		 CONT [ HOOK [ LTOP #ltop,
			       INDEX #index,
			       XARG #sbjind],
			RELS <! #key !>]],
	  LKEYS.KEYREL #key & arg12-relation &
		[LBL #ltop,
		 ARG0 #index,
		 ARG1 #sbjind,
		 ARG2 #objind],
	  NON-LOCAL [QUE <! !>]],
  J-NEEDS-AFFIX -,
  INFLECTED +].

; <type val="na-adj-go-lex">
; <name-ja>ヲ目的格形容動詞
; <description>格は主格（「が」格）目的格（「を」格）が取れる。通常は後ろにcopulaを伴う。
; <ex>犬 が 餌 を 好き だ
; <nex>犬 が 餌 に 好き だ
; <todo>
; </type>
na-adj-go-lex := na-adj-stem-lex & 
  [SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ga-wo_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
		 CONT [HOOK.XARG #sbjind,
		      RELS <! #key !> ]],
	   NON-LOCAL.QUE <! !>,
	   LKEYS.KEYREL #key & arg12-relation & 
		 [ARG1 #sbjind,
		  ARG2 #objind]]].

; <type val="na-adj-gg-lex">
; <name-ja>ガ目的格形容動詞
; <description>格は主格（「が」格）目的格（「が」格）が取れる。通常は後ろにcopulaを伴う。
; 目的格の欠けている文では出現しない。格が２つとも「は」の場合（例えば「犬 は 餌 は 好き だ」）
; はこのtypeでなくna-adj-go-lexを選択すべき。
; <ex>犬 が 餌 が 好き だ
; <nex>犬 が 餌 に 好き だ
; <todo>
; </type>
na-adj-gg-lex := na-adj-stem-lex & 
  [SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ga-ga_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
		  CONT [HOOK.XARG #sbjind,
			RELS <! #key !> ]],
	   NON-LOCAL.QUE <! !>,
	   LKEYS.KEYREL #key & arg12-relation & 
		 [ARG1 #sbjind,
		  ARG2 #objind]]].

; (TK 07-12-19)
; <type val="na-adj-ng-lex">
; <name-ja>ニ主格ガ目的格形容動詞
; <description>格は主格（「に」格）目的格（「が」格）が取れる。主格
; （「に」格）の現れない文では出現しない。通常は後ろにcopulaを伴う。
; <ex>私 に 車 が 必要 だ
; <ex>車 が 私 に 必要 だ
; <nex>車 が 必要 だ
; <todo>(lkb::do-parse-tty "車 が 私 に 必要 だ")の場合、「が」を格として取れない。
; また、「に」格がobligatoryになっていない（主格をobligatoryにできない）
; </type>
na-adj-ng-lex := na-adj-stem-lex & 
  [SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ni-ga_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
		 CONT [HOOK.XARG #sbjind,
		      RELS <! #key !> ]],
	   NON-LOCAL.QUE <! !>,
	   LKEYS.KEYREL #key & arg12-relation & 
		 [ARG1 #sbjind,
		  ARG2 #objind]]].


;;;;;;;;;;;;;;;;;;;;;;;;;LEXIKAL TYPES -- adverbs;;;;;;;;;;;;;;;;;;


adv-super-lex := lexical_sign-word & 
 [SYNSEM [LOCAL [CAT.VAL super-saturated,
		 ARG-S < >,
		 CTXT.BACKGROUND <! !>,
		 BAR +],
	  NON-LOCAL [AFFIX <! !>]],
  INFLECTED +,
  J-NEEDS-AFFIX -].

; normal adverbs
adv-lex := adv-super-lex &
 [SYNSEM.LOCAL.CAT.HEAD adv_head-avm].

; degree adverbs (modify adjectives/other adverbs)
adv-deg-lex := adv-super-lex & 
 [SYNSEM.LOCAL.CAT.HEAD   adv_deg_head-avm].

; numerical degree adverbs (modify other adverbs and numbers) 
adv-deg-num-lex := adv-super-lex & 
 [SYNSEM.LOCAL.CAT.HEAD  adv_deg_num_head-avm].


; (ERB 2001-09-06) HCONS isn't sufficiently constrained on this type.  
; Making it be exactly one thing long.

; (ERB 2001-09-06) Editing the semantics of this type to match
; the English type pp_wh_le.  E.g., how = in which way.
; In Japanese, there are the following instances:
; ikaga = in which way
; dou = in which way
; donokurai = to which extent
; naze = for which reason
; ikani = in which way
;
; (NB ikaga seems to have another use, too.)

; (ERB 2001-09-06) In order to do the above, changing CONT value
; to wh-adv-sem-type.


; (ERB 2001-11-28) Constrain these to intersective head-adj rules.


; <type val="adv-wh-lex">
; <name-ja>副詞疑問
; <description>副詞のうち、何らかのものに対する疑問を表すもの。このtypeがあるとその文は必ず疑問文になってしまう。
; 「どのくらい」のように機能が一部wh-word-lexと重なるのではないか。
; <ex>なぜ 行く
; <nex>
; <todo>(TK 07-03-23)間接疑問文にも対応すべき(lkb::do-parse-tty "なぜ 行く か を 聞く")。wh-word-thing-lexも参照。
; (TK 07-04-18)wh疑問のtypeに共通だが、１つの文にwhを表す語が複数あると解析できなくなる
; (lkb::do-parse-tty "なぜ どこ に も 無い の か")。
; </type>
adv-wh-lex := adv-lex &
             [SYNSEM [NON-LOCAL.QUE <! #head-hd !>,
		      LKEYS [KEYREL #key & [ARG1 #ind,
					    LBL #head-hd],
			     ALTKEYREL #altkey],
		      LOCAL [CAT.HEAD [MOD < [LOCAL intersective-mod &
						    [ CONT.HOOK [ LTOP #head-hd,
							     INDEX #ind]]] >,
				       COP-ARG +,
				       J-POSTHEAD left],
			     CONT wh-adv-sem-type &
				      [HOOK [LTOP #head-hd,
					     INDEX #ind],
				       RELS <! #key , #altkey , quant-relation !> ]]]].

; (ERB 2001-09-06) For dou, which wants to modify a V (i.e., something that is
; HEAD verb & LEX +.
; (MS 2005-12-19) But this needs a different semantics and cannot inherit from adv-wh-lex.

lex-mod-adv-wh-lex := adv-wh-lex &
                      [ SYNSEM.LOCAL.CAT.HEAD.MOD < [LEX +] > ].

; (ERB 2001-09-13) Getting rid of J-POSTHEAD value intersective, in system
; with only two HMRs.  See notes in japgram.tdl and rule-types.tdl.


; (ERB 2001-11-28) Constraining intersective adverbs to stay out of
; head-adjunct-rule3.  

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)


;;; FCB led gently by the hand by DPF (2006-05-01)

isect-mod-lex := lexical_sign-word &
 [SYNSEM [LOCAL [CAT.HEAD [MOD < [LOCAL intersective-mod & 
					[CONT.HOOK [LTOP #handel,
						    INDEX #modified]]] >,
			   COP-ARG +,
			   J-POSTHEAD left],
		 CONT i-sect-adv-sem-type &
			  [HOOK [INDEX #ind,
				 LTOP #handel],
			   RELS <! #key !>]],
	  LKEYS.KEYREL #key & adv-relation & 
		[ARG0 #ind & event,
		 ARG0.E.TENSE no_tense,
		 ARG1 #modified,
		 LBL #handel],
	  NON-LOCAL.QUE <! !>]].

isect-adv-lex := isect-mod-lex & adv-lex.
;;; 美しい

; Idiom Implementation (CH 060804)
; (CH 2006-08-04) Introduced idiom-A-isect-adv-lex, which is an idiom that
;  is completely fixed and unambiguous and corresponds to an adverb.

; <type val="deg-adv-lex">
; <name-ja>副詞形容詞・副詞修飾
; <description>i-adj-stem-lexやna-adj-lex、またadverbを修飾するための副詞。
; <ex>少し 多い 砂糖 
; <ex>とても 多く 入れる
; <ex>より きれい に する
; <ex>もう ちょっと 走る
; <nex>少し 走る
; <todo>(TK 07-04-19)verbを修飾することができないので、「少し」などはこのtypeの他に
; isect-adv-lexの登録もある。そのため、上記の「少し 多い 砂糖」のようにi-adj-stem-lex
; の終止形・連体形の場合に「少し」で双方の選択肢が出てしまう。
; そのため、このtypeをverbも修飾できるようにすべき。
; (TK 07-04-19)また、「na-adj-lex+copula」を修飾する場合、deg-adv-lexがna-adj-lexにかかる
; 形が良いのか、isect(or scopal)-adv-lexがcopulaにかかる形が良いのか、決めておく必要
; がある。(lkb::do-parse-tty "少し 過剰 だ")
; (TK 07-04-19)更に、(lkb::do-parse-tty "少し 良く する")の場合、「良く する」という行為が
; 「少し」と考えるならisect-adv-lexを、「少し 良い」状態に「する」と考えるならdeg-adv-lex
; を選択するような曖昧性が出る。
; </type>
deg-adv-lex := isect-mod-lex & adv-deg-lex.
;;; とても 

; <type val="deg-adv-num-lex">
; <name-ja>副詞数量修飾
; <description>数量表現を修飾するための副詞。
; <ex>およそ 千 人 が 行く
; <nex>失敗 など およそ 考え られ ない
; <todo>
; </type>
deg-adv-num-lex := isect-mod-lex & adv-deg-num-lex.
;;; およそ

; (ERB 2001-11-28) Constraining scopal adverbs to stay out of the
; intersective head-adj rules.

; (ERB 2001-11-30) And making them grab the INDEX and LTOP like
; true scopal modifiers!

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)


scopal-adv-lex := adv-lex &
 [SYNSEM [LOCAL [CAT.HEAD [MOD < [LOCAL scopal-mod & 
					[ CONT.HOOK.LTOP #h2,
					  NUCL nucl_plus]] > ],
		 CONT scopal-adv-sem-type &
			  [HOOK [INDEX #ind,
				 LTOP #top],
			   RELS <! #key & scopal-adv-relation & 
				 [ARG0 #ind,
				  ARG1 #h1,
				  LBL #top]!>,
			   HCONS <! qeq & [HARG #h1,
					   LARG #h2] !> ]],
	  LKEYS.KEYREL #key, 
	  NON-LOCAL.QUE <! !>]].

;;; the adverb's index is hook.index
scopal-adv-regular-lex := scopal-adv-lex &
 [SYNSEM.LOCAL [CAT.HEAD [J-POSTHEAD left,
			 COP-ARG +],
		CONT [ HOOK.INDEX #ind,
		       RELS <! [ ARG0 #ind ] !> ]]].

; (MS 2005-11-09) To get rid of skip files.

scopal-adv-regular-negmod-lex := scopal-adv-regular-lex &
 [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.KEYS.KEY "_neg_v_rel" ].

; (MS 2004-12-15) This doesn't have to be COMPS null on the modifiee, otherwise we
; don't get relative-clause-obj-gap rules. But it should be COP-ARG -, such that
; we will not get spurious ambiguity in the case of 人が食べるべきだ

; <type val="scopal-adv-right2left-lex">
; <name-ja>
; <description>用言の終止形や「連用形+て」の直後について、
; <ex>食べ て ばかり いる
; <ex>
; <nex>
; <todo>
; </type>
scopal-adv-right2left-lex := scopal-adv-lex &
			  [SYNSEM.LOCAL.CAT.HEAD [J-POSTHEAD right,
						  COP-ARG -,
						  MOD < [LOCAL.CAT.HEAD verb_head] > ]].


; (MS 2005-11-09) To get rid of skip files.
; (TK 08-06-18) commented out  (->beki-end-lex) 
; <type val="scopal-adv-right2left-presentmod-lex">
; <name-ja>
; <description>scopal-adv-right2left-lexを参照。ただしこのtypeは現在時制で使える語にしかかかれない。
; <ex>行く べき だ
; <ex>行く べき 人
; <nex>
; <todo>(TK 07-04-27)「動詞+補助動詞+べき+copula」の形が解析できない。(lkb::do-parse-tty "やっ て おく べき だ")
; (TK 07-04-27)過去時制の語にもかかるべき場合がある。(lkb::do-parse-tty "行く べき だっ た")
; </type>
;scopal-adv-right2left-presentmod-lex := scopal-adv-right2left-lex &
;					[SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD [H-TENSE present,
;											  FORMAL.AHON -]].


;;;;;;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- numbers;;;;;;;;;;;;;;;;;;


; (ERB 2001-08-06) Redoing the numbers following Jeff Smith's analysis
; of English number names.

; (ERB 2001-08-07) Took out identification of LBL and MOD's LBL.
; Will be making these MOD none eventually anyway.

; (ERB 2001-08-07) card-lex can no longer modify anything.  They will
; be SPRs of numeral classifiers and other entities.  The MOD none
; constraint is on int_head.

; (ERB 2004-1-16) They're still not modifying anything directly, but
; semantically it's going to look like they are.  So, I've updated the
; definitions of the relevant relations (integer-relation, and its
; subtypes).  Now card-lex needs to identify the ARG1 of the
; const-relation and any plus or times relations (the modified thingy)
; with its XARG, so that other card-lexes and the numeral classifier
; can get at it.  Modify card-lex, card-sem-type, card-with-object and
; card-with-specifier appropriately.

; (ERB 2004-1-18) Making special entry for 何 in numeral classifier
; phrases.  Assume for the moment (probably incorrectly) that
; 何十年 etc are ungrammatical, because I don't know what their
; semantics should look like.  This entry will share some but not
; all of the constraints on card-lex, so I'm going to create a 
; supertype card-lex-super:
; (FCB 2006-06-20) make these lexical_sign-aword (not lexical_sign-word) so they scope again 

card-lex-super := lexical_sign-aword & 
            [SYNSEM [LOCAL [CAT [ HEAD int_head-avm,
				  VAL [SUBJ null,
				       COMPS 0-1-list & #comps]],
			    ARG-S #comps,
                            CTXT.BACKGROUND <! !>,
                            BAR bool],
                    NON-LOCAL [QUE <! !>,
                            AFFIX <! !>]], 
	     INFLECTED +].

card-lex := card-lex-super & 
            [SYNSEM [LOCAL [CAT.HEAD.KEYS.KEY #pred,
			    CONT card-sem-type & [ RELS.LIST.FIRST #key]],
		     NON-LOCAL [QUE <! !>,
				AFFIX <! !>],
		     LKEYS.KEYREL #key & [PRED #pred]]].

; (ERB 2004-1-18) Special type for 何 in numeral classifier phrases.

; <type val="nan-card-lex">
; <name-ja>数詞不定
; <description>数量が分からない、または数量をたずねる場合に使う。後に必ず助数詞を伴う。
; 現状ではこのtypeを使っても数量を尋ねる疑問文になっていないようにDependenciesからは読み取れる。
; <ex>何 回 クリック する か
; <nex>何 を クリック する か
; <todo>(TK 07-03-22)wh-word-thing-lexを参照。(lkb::do-parse-tty "何 回 でも クリック する")
; </type>
nan-card-lex := card-lex-super &
 [ SYNSEM.LOCAL [ CAT [ VAL super-saturated,
			HEAD nan_int ],
		  CONT [ RELS <! quant-relation &
			         [ PRED which_q_rel,
				   ARG0 #ind,
				   RSTR #harg ],
			         noun-relation &
			         [ PRED number_rel,
				   ARG0 #ind,
				   LBL #larg ],
			         arg12-relation &
			         [ PRED unspec_rel,
				   LBL #ltop,
				   ARG1 #xarg,
				   ARG2 #ind ] !>,
			 HCONS <! qeq &
				[ HARG #harg,
				  LARG #larg ] !>,
			 HOOK [ LTOP #ltop,
				XARG #xarg ]]]].
				   

; (ERB 2001-08-06) Subtypes of card-lex are cross-classified on
; two dimensions: their value and their valence.

card-value := card-lex.
card-valence := card-lex.

; (ERB 2001-08-06) Subtypes of card-valence are cross-classified
; on two dimensions:  Whether or not there's a SPR and whether or
; not there's an OBJ.  This can't be done with optionality, since
; there is a semantic difference between hyaku with a complement
; and hyaku without a complement.

card-specification := card-valence.
card-complementation := card-valence.

card-no-object := card-complementation &
		  [ SYNSEM.LOCAL.CAT.VAL [ COMPS null]].

card-with-object := card-complementation & 
            [SYNSEM [LOCAL [CAT.VAL [ COMPS obl-1-arg &
					    < [LOCAL [ CAT [ VAL saturated,
							     HEAD int_head ],
						       CONT.HOOK [ XARG #xarg,
								   LTOP #term2 ]]] >],
			    CONT [ HOOK.XARG #xarg,
				   RELS.LIST.REST.FIRST plus-relation & 
					     [ ARG1 #xarg,
					       ARG3 #term2 ]]]]].


card-no-specifier := card-specification &
                     [ SYNSEM [ LOCAL.CAT.VAL [ SPR null ],
                                      LKEYS [KEYREL #key,
                                             ALTKEYREL #key ]]].

card-with-specifier := card-specification & 
            [SYNSEM [LOCAL [ CONT.HOOK.XARG #xarg,
			     CAT.VAL.SPR obl-1-arg &
				       [FIRST [LOCAL [ CAT [ VAL saturated,
							     HEAD int_head ],
						       CONT.HOOK [ XARG #xarg,
								   LTOP #factor2 ]]]]],
		     LKEYS [KEYREL.LBL #factor1,
			    ALTKEYREL times-relation & 
				       [ ARG1 #xarg,
					 ARG2 #factor1,
					 ARG3 #factor2 ]]]].

; (ERB 2001-08-06) Cross-classified subtypes of card-valence:

card-with-object-with-specifier := card-with-object & card-with-specifier &
     [ SYNSEM [LKEYS.ALTKEYREL #altkey &
				 [ LBL #term1 ],
		     LOCAL.CONT [HOOK.LTOP #top,
				 RELS <! relation, [ LBL #top,
					       ARG2 #term1 ], #altkey !> ]]].

card-with-object-no-specifier := card-with-object & card-no-specifier &
     [ SYNSEM [LKEYS.KEYREL.LBL #term1,
		     LOCAL.CONT [HOOK.LTOP #top,
			   RELS <! relation, [ LBL #top,
                                                ARG2 #term1 ] !> ]]].

card-no-object-with-specifier := card-no-object & card-with-specifier &
     [ SYNSEM [LKEYS.ALTKEYREL #altkey & [LBL #top],
		     LOCAL.CONT [HOOK.LTOP #top,
				 RELS <! relation, #altkey !> ]]].

card-no-object-no-specifier := card-no-object & card-no-specifier &
     [ SYNSEM.LOCAL.CONT [ RELS <! [ LBL #top ] !>,
                           HOOK.LTOP #top ]].

; (ERB 2001-08-16) Further subtypes based on constraints on SPR for
; big numbers (they're all int4- on the SPR after man, except oku).

card-with-specifier4 := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int4- ].

card-no-object-with-specifier4 := card-no-object-with-specifier & card-with-specifier4.

card-with-object-with-specifier4 := card-with-object-with-specifier & card-with-specifier4.

card-with-specifier4x := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int4x ].

card-no-object-with-specifier4x := card-no-object-with-specifier & card-with-specifier4x.

card-with-object-with-specifier4x := card-with-object-with-specifier & card-with-specifier4x.



; (ERB 2001-08-16) Further subtypes for constraints on SPR for juu, hyaku,
; and sen that takes 2-9 SPR, can stand alone, can be SPR of man, etc. 

card-with-specifier1 := card-with-specifier &
[ SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD int1 ].

card-no-object-with-specifier1 := card-no-object-with-specifier & card-with-specifier1.

card-with-object-with-specifier1 := card-with-object-with-specifier & card-with-specifier1.

; (ERB 2001-08-16) For sen that takes ichi as SPR, can be SPR of man, etc.
; can't stand alone.

card-with-specifier_ichi := card-with-specifier &
[ SYNSEM.LOCAL.CAT [ HEAD.ST-ALONE -,
                     VAL.SPR.FIRST.LOCAL.CAT.HEAD int_ichi ]].

card-no-object-with-specifier_ichi := card-no-object-with-specifier & card-with-specifier_ichi.

card-with-object-with-specifier_ichi := card-with-object-with-specifier & card-with-specifier_ichi.

; (ERB 2001-08-06) Subtypes for numbers of different values:

card_ichi := card-value &
             [ SYNSEM [ LOCAL.CAT.HEAD int_ichi,
			LKEYS.KEYREL.CARG "1" ]].

card1 := card-value &
             [ SYNSEM.LOCAL.CAT.HEAD int1 ].

card2 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int2 ].

card3 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int3 ].

card4 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int4 ].

; (ERB 2001-08-16) For the sen that doesn't need a SPR, can be COMPS
; of man, but not SPR of man.

card4z := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int4z ].

card5 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int5 ].

; (ERB 2001-08-21) For ersatz numbers.
card5x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int5x ].

card9 := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int9 ].

; (ERB 2001-08-21) For ersatz numbers.
card9x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int9x ].

card13 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int13 ].

; (ERB 2001-08-21) For ersatz numbers.
card13x := card-value &
         [ SYNSEM.LOCAL.CAT.HEAD int13x ].

card17 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int17 ].

card21 := card-value &
          [ SYNSEM.LOCAL.CAT.HEAD int21 ].

; (ERB 2001-08-06) Cross-classified subtypes inheriting from both
; card-value and card-valence hierarchies.

card_ichi_no_valence := card_ichi & card-no-object-no-specifier.
card_1_no_valence := card1 & card-no-object-no-specifier.
card_2_no_valence := card2 & card-no-object-no-specifier.
card_3_no_valence := card3 & card-no-object-no-specifier.

; (ERB 2001-08-16) For sen that takes no SPR, can't be SPR of man, etc.
card_4_no_valence := card4z & card-no-object-no-specifier.

; (ERB 2001-08-21) For ersatz numbers.
card_4e_no_valence := card4 & card-no-object-no-specifier.
card_5x_no_valence := card5x & card-no-object-no-specifier.
card_9x_no_valence := card9x & card-no-object-no-specifier.
card_13x_no_valence := card13x & card-no-object-no-specifier.

card_2_object_only := card2 & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int1- ].

card_3_object_only := card3 & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int2- ].

; (ERB 2001-08-16) For sen that takes no SPR, can't be SPR of man, etc.
card_4_object_only := card4z & card-with-object-no-specifier &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3-].
  
card_2_spr_only := card2 & card-no-object-with-specifier1.
card_3_spr_only := card3 & card-no-object-with-specifier1.
card_4_spr_only := card4 & card-no-object-with-specifier1.
card_4_spr_only_2 := card4 & card-no-object-with-specifier_ichi.
card_5_spr_only := card5 & card-no-object-with-specifier4.
card_9_spr_only := card9 & card-no-object-with-specifier4x.
card_13_spr_only := card13 & card-no-object-with-specifier4.
card_17_spr_only := card17 & card-no-object-with-specifier4.
card_21_spr_only := card21 & card-no-object-with-specifier4.

card_2_spr_object := card2 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int1- ].

card_3_spr_object := card3 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int2- ].
  
card_4_spr_object := card4 & card-with-object-with-specifier1 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3- ].

card_4_spr_object_2 := card4 & card-with-object-with-specifier_ichi &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int3- ].

; (ERB 2001-08-16) Either kind of sen okay as COMPS.

card_5_spr_object := card5 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int4x ].

card_9_spr_object := card9 & card-with-object-with-specifier4x &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int5- ].

card_13_spr_object := card13 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int9- ].

card_17_spr_object := card17 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int13- ].

card_21_spr_object := card21 & card-with-object-with-specifier4 &
[ SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD int17- ].

; (ERB 2001-12-05) For 半 in 二年半.  I'm not sure there's
; anything else in this class.

; <type val="han-lex">
; <name-ja>数詞補助詞
; <description>「数詞+助数詞」の形の直後について、「数詞+0.5+助数詞」の意味にする。現状では「数詞+助数詞」
; の形自体がうまく解析されないため、han-lexを使った文もうまく解析されない。また、このtypeでは「半」しか
; 想定されていないが、「余り」「強」「弱」「以上」「未満」などもこの仲間ではないか。
; <ex>二 年 半
; <nex>半 人前
; <todo>(TK 07-03-26)(lkb::do-parse-tty "二 年 未満")これもこのtypeで解析すべきでは？
; </type>
han-lex := lexical_sign-word &
[ SYNSEM [ LOCAL [ CAT [ HEAD han_head,
                         VAL super-saturated ],
		   ARG-S < >,
                   CONT card-sem-type &
                       [ HOOK.LTOP #top,
                         RELS <! #key !>]],
	    LKEYS.KEYREL #key & [ LBL #top,
				     CARG ".5" ],
           NON-LOCAL [ QUE <! !>,
                    AFFIX <! !> ]]].

;;;;;;;;;;;;;;;;;;;;;;;;;Date expressions;;;;;;;;;;;;;;;;;;;;;;

; ERB (2001-09-24) Overhauling the date expressions.  The general
; plan is treat them as nouns, which take up to three arguments:
; a determiner (この、その、あの、どの）
; an OBJ2 (月 for 日 and 年 for 月)
; an integer as OBJ (1-12 for 月、1-31 for 日、unlimited for 年)
; The first two of these are optional, although ordered.
; The third is obligatory, and must occur right next to the head.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-10-06) date_noun_head-avm instead of ordinary_noun_head-avm,
; because the behaviour in compounds and adjuncts is different:
; 今年三月

date-lex := n-lex & 
[ SYNSEM [ LOCAL [ CAT [ HEAD date_noun_head-avm,
                         VAL [SPR.FIRST #spr &
					[OPT + ,
					LOCAL [ CAT.HEAD det_head,
						CONT det-sem-type &
							 [ HOOK.INDEX ref-ind]]],
			      COMPS #comps,
			      SUBJ null]],
		   ARG-S < #spr . #comps >,
                   CONT date-sem-type & [RELS.LIST.FIRST #key],
                   CTXT.BACKGROUND <! !> ],
	    LKEYS.KEYREL #key,
           NON-LOCAL [QUE <! !>,
                   AFFIX <! !>]]].

; (MS 2003-12-19) Matrix 0.6

date-with-int-lex := date-lex &
 [ SYNSEM [ LOCAL.CAT.VAL [ COMPS < [OPT - ,
				     LOCAL [ CAT [ HEAD int_head,
						   VAL saturated ],
					     CONT.HOOK.LTOP #h]] >],
	    LKEYS.KEYREL.ARG1 #h ]].

; ERB (2001-08-28) To accomodate Chasen's parsing of 八月 etc as one word


date-no-int-lex := date-lex &
 [ SYNSEM [ LOCAL.CAT.VAL [COMPS 0-1-list ],
	    LKEYS [ ALTKEYREL const-relation &
			      [ LBL #hand ],
		    KEYREL.ARG1 #hand ]]].

; (MS 2004-12-02) For generation, these need PRED values for the prep-mod-relation.

date-with-object2-lex := date-lex &
 [ SYNSEM.LOCAL [ CAT.VAL [ COMPS < [OPT - ,
				     LOCAL [ CAT.VAL saturated,
					     CONT.HOOK.INDEX #objind ]] >],
		  CONT [ RELS.LIST.REST.FIRST prep-mod-relation &
					      [ PRED "prep",
						ARG1 #selfind,
						ARG2 #objind,
						LBL #h2 ],
			 HOOK [LTOP #h2,
						      INDEX #selfind ]]]].

date-no-object2-lex := date-lex &
                      [ SYNSEM.LOCAL.CAT.VAL.COMPS 0-1-list].

date-with-object2-with-int-lex := date-with-object2-lex & date-with-int-lex &
 [ SYNSEM.LOCAL.CONT [ RELS <! relation, relation !> ]].

date-no-object2-with-int-lex := date-no-object2-lex & date-with-int-lex &
 [ SYNSEM.LOCAL.CONT [ RELS <! relation !> ]].

; ERB (2001-08-28) For 八月 etc as single words.

date-with-object2-no-int-lex := date-with-object2-lex & date-no-int-lex &
 [ SYNSEM [LOCAL.CONT.RELS <! relation, relation, #altkey !>,
	   LKEYS.ALTKEYREL #altkey ]].

date-no-object2-no-int-lex := date-no-object2-lex & date-no-int-lex &
 [ SYNSEM [LOCAL.CONT.RELS <! relation, #altkey !>,
	   LKEYS.ALTKEYREL #altkey ]].



nichi-lex := date-lex &
 [ SYNSEM.LKEYS.KEYREL dofm-relation ].

gatsu-lex := date-lex &
 [ SYNSEM.LKEYS.KEYREL mofy-relation ].

toshi-lex := date-lex &
 [ SYNSEM.LKEYS.KEYREL yofc-relation     ].

; <type val="date-ersatz-lex">
; <name-ja>前処理用日付認識詞
; <description>Chasenが文を形態素解析する場合に、日付として認識されたものがこのtypeとなる。
; Chasenを通さない場合には使われることがない。
; <ex>２００７―０３―１５
; <nex>
; <todo>
; </type>
date-ersatz-lex := date-no-object2-no-int-lex &
 [ SYNSEM.LKEYS [KEYREL.PRED "dateersatz",
		 ALTKEYREL.CARG "ersatz" ]].

nichi-no-object2-lex := nichi-lex & date-no-object2-with-int-lex.
gatsu-no-object2-lex := gatsu-lex & date-no-object2-with-int-lex.
toshi-no-object2-lex := toshi-lex & date-no-object2-with-int-lex.

nichi-with-object2-lex := nichi-lex & date-with-object2-with-int-lex &
                         [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY mofy_rel ] >].

gatsu-with-object2-lex := gatsu-lex & date-with-object2-with-int-lex &
                         [ SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel ] >].

; ERB (2001-08-28) For 八月 etc as single words.
; add the number in the lexical entry itself

n_obj2_month-lex := gatsu-lex & date-with-object2-no-int-lex &
  [SYNSEM.LOCAL.CAT.VAL.COMPS < [LOCAL.CAT.HEAD.KEYS.KEY yofc_rel] >].

n_-_month-lex := gatsu-lex & date-no-object2-no-int-lex.

;;;;;;;;;;; Other date expressions ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; (ERB 2001-10-04)  Making a separate type for date nouns,
; as they are semantically already different from ordinary nouns
; and might also have different subcategorization.
; (MS 2001-11-29) Giving those another head type, in order to prevent overgeneration of the adv_np rule.

date-n-lex := n-lex &
 [ SYNSEM [ LOCAL [ CAT [ HEAD date_noun_head-avm,
			  VAL noun_sc & [SPR.FIRST #spr]],
		    ARG-S < #spr >,
		    CONT date-noun-sem-type & [HOOK.INDEX #i,
					       RELS <! #key !>],
		    CTXT.BACKGROUND <! !> ],
	    LKEYS.KEYREL #key &  [ARG0 #i],
	    NON-LOCAL [QUE <! !>,
		       AFFIX <! !>]]].

; (ERB 2001-10-04) Both of these kinds of nouns can be used
; as adverbs on their own, but only the former can be marked with ni.

; 来年、再来年、来月、来週、前日、前月、翌日

; <type val="date-noun-lex">
; <name-ja>時間名詞
; <description>名詞のうち、時間を表すもの。普通名詞と同じ働きをする場合もあるが、ADV_NP_RULEによって
; 副詞化させることができる。
; <ex>再来年 に 選挙 が ある
; <ex>再来年 選挙 が ある
; <ex>再来年 の 選挙
; <nex>再来年 する
; <todo>
; </type>
date-noun-lex := date-n-lex &
[ SYNSEM.LKEYS.KEYREL future-date-relation ].


date-noun-minusbar-lex := date-noun-lex &
			  [SYNSEM.LOCAL.BAR -].

; (MS 2005-08-17) This is necessary to prevent spurious ambiguity:
; 間 (kan) is a noun_mod-lex-r and 間 (aida) a date-noun-plusbar-lex.
; The date-noun-plusbar-lex cannot be part of a compound!

; <type val="date-noun-plusbar-lex">
; <name-ja>時間名詞
; <description>date-noun-lexを参照。連体修飾されなければこのtypeは出現しない。また、複合名詞を作らない。
; 現状では副詞句を作れず、用言の修飾を受けた場合にはletrative clauseのgap-ruleにするかどうかの選択肢が出てしまう。
; <ex>行く 間
; <ex>授業 の 間
; <nex>授業 間 寝る
; <todo>(TK 07-03-15)(lkb::do-parse-tty "間 の 本")これはこのtypeで解析されないほうがよい。
; </type>
date-noun-plusbar-lex := date-noun-lex &
			  [SYNSEM.LOCAL.BAR +].

; 去年、今月、毎日、本日

; <type val="date-noun-adv-lex">
; <name-ja>時間名詞「に」接続不可
; <description>date-noun-lexを参照。ただしこちらは後にadv-p-lexの「に」をつけられない。
; <ex>毎月 雑誌 を 買う
; <ex>毎月 の 行事
; <nex>毎月 に 雑誌 を 買う
; <todo>
; </type>
date-noun-adv-lex := date-n-lex &
[ SYNSEM [LOCAL.CAT.HEAD.FIN -,
	  LKEYS.KEYREL non-future-date-relation ]]. 


date-noun-adv-minusbar-lex := date-noun-adv-lex &
 [SYNSEM.LOCAL.BAR -].

;;;;;;;;;;;;;;;;;;;;;;;;;Disjunctions for LKB;;;;;;;;;;;;;;;;;;

; (ERB 2001-01-07) Need a type grouping together saps and
; sentence-valid.

utt-valid := final_head.

sentence-valid := utt-valid.

temporal-noun_head := noun_head-avm &
                      [J-SPEC null,
                       QUANTIFIABLE -].

;<TT>
; (TT 2003-08-14) pred-noun 「為」に動詞句を修飾させるため

; temporal-or-nadv_head  := noun_head-avm &
; 		      [QUANTIFIABLE -, 
; 		       J-SPEC null].

; temporal-noun_head := temporal-or-nadv_head.


; nadv_head := temporal-or-nadv_head &
; 	     [MOD null].

; (TT 2003-08-14) <！>要修正: とりあえず、RELATIVE-CLAUSE-RULE で解析が通るようにした。
;                 本来は HEAD-SPECIFIER-RULE を使うべき。

; nadv-lex := n-lex & noun_head-avm &
;               [ SYNSEM [ LOCAL [ CAT [ HEAD nadv_head,
;                                        VAL noun_sc & [SPR.FIRST #spr]],
; 				 ARG-S < #spr >,
; 				 KEYS.KEY #key &  [ARG0 #i],
;                                  CONT nadv-sem-type & [HOOK.INDEX #i,
; 							    RELS.LIST.FIRST #key],
;                                  CTXT.BACKGROUND <! !> ],
; 			 NON-LOCAL [QUE <! !>,
; 				    AFFIX <! !>]]].

; nadv-lex := n-lex & noun_head-avm &
;        [SYNSEM.LOCAL [CAT [HEAD nadv_head, 
; 			   VAL.SPR.FIRST.LOCAL [CAT [HEAD verb_head & [MAIN-PRD bool,
; 								       MODUS uttmodus,
;                                                                         SMOD unmarked],
; 						     VAL saturated],
;                                                  KEYS [KEY.LBL #verb-hand],
;                                                  BAR +]],
;                       CONT  nom-pred-sem-type &
;                           [RELS <! [ARG0 #i,
;                                      LBL #nom-hand,
;                                      ARG1 #prpstn-hand],
;                                   quant-rel & [ARG0 #i, PRED 'udef,
;                                                 RSTR #restr],
;                                   prpstn_rel & [LBL #prpstn-hand,
;                                                 MARG #soa] !>,
;                            HOOK [LTOP #nom-hand],
;                            HCONS <! qeq &
;                                    [HARG #restr,
;                                     LARG #nom-hand],
;                                    [HARG #soa,
;                                     LARG #verb-hand] !> ]]].

;;;</TT>


adj-or-adv_head := final_head.

numbers_head := final_head.


;;;;;;;;;;;;;;LEXICAL PRINCIPLES;;;;;;;;;;;;;;;


subj-honor-ctxt := ctxt &
 [C-INDICES.SPEAKER #sp,
  BACKGROUND <! subj-honor_rel &
	      [HONORER #sp,
	       POLARITY bool] !>].





;;;;;;;;;;;;;;VERBAL ENDINGS;;;;;;;;;;;;;;;


; (ERB 2002-01-02) I've made some changes to verbal endings for
; the sake of getting VN + kudasai.  My first idea was to treat
; this kudasai as an sap, like te+kudasai.  This didn't work because
; of sentences with modifiers (including topic-wa, conjunction, etc.)
; that were looking to modify a sentence_valid head.  So, as a 
; second try, making kudasai in VN + kudasai parallel to nasai in
; tabenasai.  This entails adding a vn-vend-rule like the 
; vstem-vend-rule and making most verbal endings require [VN -],
; while the new kudasai requires [VN +].  Because the new kudasai
; is an eventual subtype of v-end-lex, I need to move the constraint
; identifying VN and SPR.VN to appropriate subtypes.

; (ERB 2002-01-14) Likewise the constraint identifying the KEY.LBL
; and LTOP needs to be moved to subtypes.

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-24) We need unificable SHON information between v-end and v-stem.
; DPF spurring on FCB 2009-03-19
; Make the SPR of the SPR empty  to avoid spurious ambiguity with light verbs,


basic-v-end-lex := lexical_sign-affix &
             [SYNSEM synsem &
                     [LOCAL [CAT [HEAD v-end_head &
                                       [H-TENSE #tense,
                                        AUX #aux,
					ADJ #adj,
					FORMAL.SHON #shon],
				  VAL [SPR obl-1-arg &
					    [FIRST [LOCAL [CAT [HEAD verb_head & [AUX #aux,
										  ADJ #adj,
										  H-TENSE #tense,
										  FORMAL.SHON #shon],
							       VAL [SPR <>,
								    SUBJ #sbj,
								    COMPS #comps]],
							  ARG-S #arg-s,
							  BAR -]]],
				       SUBJ #sbj,
				       COMPS #comps]],
			     ARG-S #arg-s,
			     CONT verb-sem-type &
				 [HOOK [INDEX  event & 
					       [E [TENSE #tense]]]],
                             BAR -,
                             NUCL nucl_plus],
                      NON-LOCAL [QUE <! !>,
                              AFFIX <! !>]]].

v-end-lex := basic-v-end-lex &
 [ SYNSEM.LOCAL [ CAT.VAL.SPR < [ LOCAL.CONT.HOOK #hook ] >,
		  CONT.HOOK #hook ]].


; (MS 2002-1-9) This needs a subject: 雨が降りそうだ
; (MS 2003-10-08) Problems with Matrix 0.5?
; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-03) The PRED value should be copied into the relation for indexing.

; (FCB 2005-04-09) in order to allow a handle as ARG1
; change na-adj-sem-type-basic to pred-sem-type, relation type to arg1-relation

na-end-lex := lexical_sign-word &
              [J-NEEDS-AFFIX -,
	       SYNSEM synsem &
                      [LOCAL [CAT [HEAD na-adj_head & [MODUS indicative,
						       MOD null],
                                   VAL [SUBJ #sbj,
					COMPS #comps,
					 SPR obl-1-arg & 
					     [FIRST [LOCAL [CAT.VAL [SUBJ #sbj,
								    COMPS #comps],
							    CONT [HOOK [XARG #xarg,
									LTOP #adjhand]]],
						     LEX +]]]],
			      CONT pred-sem-type &
				  [HOOK [LTOP #hand,
					  INDEX #event,
					  XARG #xarg],
				   RELS <! #key !>,
				   HCONS <! qeq & [HARG #arghd, LARG #adjhand] !>]],
		       LKEYS.KEYREL #key & arg1-relation &
			     [ARG0 #event,
			      ARG1 handle & #arghd ,
			      LBL #hand],
		       NON-LOCAL [QUE <! !>,
                               AFFIX <! !>]],
	       INFLECTED +,
	       LMORPH-BIND-TYPE i-or-shortadj-morph].

; <type val="na-varg-end-lex">
; <name-ja>承用言連用形接尾辞形容動詞化
; <description>用言の連用形の後について、１つのna-adj-lexのような働きをする複合語を作る。様態を述べたり、
; 推定・予測の意を表す場合に使う。活用はしない。
; <ex>帰り そう だ
; <ex>高 そう だ
; <nex>高い そう だ
; <todo>(TK 07-05-07)このtypeの後に「に+なる」の形をつけると、その「なる」はintrans-c-stem-lexになってしまう
; (lkb::do-parse-tty "流れ そう に なる")
; </type>
na-varg-end-lex := na-end-lex &
			[SYNSEM.LOCAL [CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD verb_head & 
								       [VN -,
									FORMAL.AHON -]]].
; <type val="na-varg-negspr-end-lex">
; <name-ja>承ナイ形容詞接尾辞形容動詞化
; <description>na-varg-end-lexを参照。ただしこのtypeは、現状ではi-adj-neg-stem-lex「ない」の語幹「な」
; の後にのみつくことができる。
; <ex>力 が な さ そう だ
; <nex>
; <todo>(TK 07-05-07)i-adj-neg-stem-lexの「ない」以外でも「良い（よい）」「無い（ない）」とつく語の
; 語幹につくべき。(lkb::do-parse-tty "考え て い な さ そう だ")(lkb::do-parse-tty "人 が い な さ そう だ")
; (lkb::do-parse-tty "とめど な さ そう だ")(lkb::do-parse-tty "物足りな さ そう だ")
; (lkb::do-parse-tty "縁起 よ さ そう だ")
; (TK 07-05-07)このtypeの後に「に+なる」の形をつけると、その「なる」はintrans-c-stem-lexになってしまう
; (lkb::do-parse-tty "力 が な さ そう に なる")。
; </type>
na-varg-negspr-end-lex := na-varg-end-lex &
			  [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS negative].


; <type val="na-naarg-end-lex">
; <name-ja>承形容動詞語幹接尾形容動詞化
; <description>na-adj-lexの直後にあって、na-adj-lexと同じような働きをする複合語を作る。
; 様態を述べたり、推定・予測の意を表す場合に使う。活用はしない。
; <ex>お 元気 そう だ
; <ex>不安 そう に 眺める
; <nex>佐藤 さん は お 元気 だ そう です
; <todo>(TK 07-05-07)このtypeの後に「に+なる」の形をつけると、その「なる」はintrans-c-stem-lexになってしまう
; (lkb::do-parse-tty "元気 そう に なる")。
; </type>
na-naarg-end-lex :=  na-end-lex &
		     [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD na-adj_head].

; (MS 2003-12-19) Matrix 0.6
; (MS 2004-12-20) This is used for na-adjectives that can have ni-marking and then become adverbs,
; such as 元気になる

; <type val="naadj2adv-end-lex">
; <name-ja>承形容動詞語幹助詞副詞化
; <description>na-adj-lexの直後につく助詞の「に」。「na-adj-lex+に」の形で、１つの副詞として働く。
; (since 2005)v-soc-adv-stem-lexやv2a-c-stem-lexのように、adverbを格として取る動詞に対して使う。
; <ex>部屋 を きれい に する
; <ex>桜 が 有名 に なる
; <nex>部屋 を きれい に 掃除 する
; <nex>確か に 鐘 が なっ た
; <todo>(TK 07-04-11)「そうに+V」(lkb::do-parse-tty "寒 そう に 振る舞う")や「na-adj-lex+に+助詞」
; (lkb::do-parse-tty "簡単 に は 譲ら ない")の場合にもこのtypeを選ぶかどうかの選択肢が出てしまう。
; (TK 07-04-11)また、「na-adj-lex+に+助詞」の場合、このtypeを選ぶことは可能だが、格にはなれない
; (lkb::do-parse-tty "きれい に は し ない")。
; </type>
naadj2adv-end-lex := lexical_sign-word &
 [J-NEEDS-AFFIX -,
  SYNSEM synsem &
		[LOCAL [CAT [HEAD case-adv_head & [J-POSTHEAD left],
			     VAL obj-arg &
				  [COMPS #comps & [FIRST [OPT - ,
							  LOCAL [CAT [HEAD na-adj_head,
								      VAL.UNSAT +],
								 CONT [RELS <! #key & 
									     [ARG1 #xarg] !>,
								       HOOK [LTOP #tophand,
									     INDEX #ind]]]]]]],
			ARG-S #comps,
			CONT [HOOK [LTOP #tophand,
				    XARG #xarg,
				    INDEX #ind],
			      RELS <! !>,
			      HCONS <!  !>]],
		 LKEYS.KEYREL #key & [ LBL #tophand],
		 NON-LOCAL [QUE <! !>,
			    AFFIX <! !>]],
  INFLECTED +].




; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message 
; FIXME should be able to combine with v-op-end-lex in some way
; がる : (do-parse-tty "犬 が 欲し がる")
; <type val="naadj2v-end-lex">
; <name-ja>承用言接尾動詞化
; <description>type名にnaadj~とつくが、実際にはna-adj-lexやi-adj-lexの語幹
; の直後にあってそれを動詞化し、願望・意思・振りなどの意味を持たせる。
; 本来はラ行五段活用をすべきだが、終止形「がる」と連用形「がり」しか使えない。
; また現状では一段活用の動詞の後にもついてしまう問題がある（「言え がる」など）。
; 更に「欲しい」「羨ましい」など、「がる」がつくことによって「を」格を
; 取る場合もあるがそれも解析できない。
; <ex>痒 がる
; <ex>犬 が 欲し がる
; <ex>娘 が 犬 を 欲し がる
; <ex>残念 がる
; <nex>痒い がる
; <todo>(TK 07-03-26)一段動詞の後につくべきではない。(lkb::do-parse-tty "食べ がる")
; (TK 07-03-26)また、v1-stemのような働きを持たせる場合にも対応すべき。(lkb::do-parse-tty "娘 が 犬 を 欲し がる")
; </type>
naadj2v-end-lex := lexical_sign-word &
 [SYNSEM synsem &
	 [LOCAL [CAT [HEAD v-op-end_head & [MODUS indicative],
		      VAL [SUBJ #sbj,
			   COMPS #comps,
			   SPR obl-1-arg & 
				[FIRST [LOCAL [CAT.VAL [SUBJ #sbj,
							COMPS #comps],
					       CONT.HOOK [LTOP #adj-hand,
							  XARG #xarg]],
					LEX +]]]],
		 ARG-S < #sbj . #comps >,
			      BAR -,
		 CONT [HOOK [LTOP #top,
			     INDEX #event & [E.MOOD indicative],
			     XARG #xarg],
		       RELS <! #key !>,
		       HCONS <! qeq & [HARG #harg, LARG #adj-hand] !>]],
	  LKEYS.KEYREL #key & [PRED garu_v_seem_rel,
			       LBL #top,
			       ARG0 #event,
			       ARG1 #xarg,
			       ARG2 #harg],
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>],
	  MODIFIED.PERIPH bool],
  INFLECTED -,
  J-NEEDS-AFFIX +,
  LMORPH-BIND-TYPE shortadj-morph,
  STEMTYPE c-stem].


; (ERB 2001-10-24) For K2Y machinery, I'd like this to have special
; rel, viz neg_rel.

; (ERB 2001-11-28) Replace KEY.LBL with LTOP.

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.



v-neg-end-lex := v-noncaus-op-end-lex &
                 [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MODUS negative,
							    KEYS.KEY #negrel],
				      VAL.SPR.FIRST.LOCAL [CONT [HOOK [LTOP #v-hd,
								       INDEX #event]]]],
				 CONT [RELS <! neg-relation &  #keyrel & [ARG1 #neg-arg,
									  PRED #negrel,
									  LBL #top] !>,
				       HOOK [LTOP #top,
					     INDEX #event & [E.MOOD indicative]],
				       HCONS <! qeq & [LARG #v-hd,
							HARG #neg-arg] !>]],
			  LKEYS.KEYREL #keyrel]].

v-neg-polite-present-end-lex := v-neg-end-lex &
				[SYNSEM.LOCAL [CAT.HEAD [C-MOD null,
							 H-TENSE present,
							 FORMAL.AHON +],
					       CONT.HOOK.INDEX.E.MOOD indicative]].

v-neg-plain-present-end-lex := v-neg-end-lex &
				[SYNSEM.LOCAL.CAT.HEAD [C-MOD null,
							 H-TENSE present,
							 FORMAL.AHON -,
							 COP-ARG -,
							 FIN +]].


v-neg-polite-present-simple-end-lex := v-neg-polite-present-end-lex &
				       [J-NEEDS-AFFIX -,
					SYNSEM.LOCAL.CAT.HEAD [MOD null,
							       FIN +,
							       MARK null,
							       J-SPEC null]].
							       

; <type val="v-neg-polite-present-end-imorph-lex">
; <name-ja>承動詞連用形助動詞現在否定丁寧終止形
; <description>v-present-tense-end-lex「ます」の否定形。v-present-tense-end-lexを参照。
; <ex>食べ ませ ん
; <nex>食べ ませ ん でし た
; <todo>
; </type>
v-neg-polite-present-end-imorph-lex := v-neg-polite-present-simple-end-lex &
				       [LMORPH-BIND-TYPE i-morph].

; <type val="v-neg-polite-present-end-amorph-lex">
; <name-ja>承動詞未然形助動詞現在否定丁寧終止形
; <description>動詞未然形の直後につく助動詞（複合語？）。現在時制に使い、聞き手（読み手）への敬意
; を表す場合に使う。
; ただ、現状では英語でいう"can't help"や"must"、"should"に当たるものがこのtypeで登録されているが、
; 正しいかどうかは不明。
; <ex>言わ ざる を 得 ませ ん
; <nex>ざる を 得 ませ ん
; <todo>(TK 07-05-08)「ざる を 得 ない」「ざる を え ない」もこのtypeで登録されているが、これらは
; 少なくとも"AHON +"ではなく、何か適当なtypeが必要。
; </type>
v-neg-polite-present-end-amorph-lex := v-neg-polite-present-simple-end-lex &
				       [LMORPH-BIND-TYPE a-morph].

v-neg-polite-past-end-lex := v-neg-end-lex &
			     [J-NEEDS-AFFIX -,
			      SYNSEM.LOCAL [CAT.HEAD [MOD null,
						      C-MOD null,
						      H-TENSE past,
						      MARK null,
						      J-SPEC null,
						      FIN +,
						      FORMAL.AHON +]]].

; <type val="v-neg-polite-past-end-imorph-lex">
; <name-ja>承動詞連用形助動詞過去否定丁寧終止形
; <description>v-neg-polite-present-end-imorph-lexの過去形。v-neg-polite-present-end-imorph-lexを参照。
; 過去時制に使う。
; <ex>食べ ませ ん でし た
; <nex>
; <todo>
; </type>
v-neg-polite-past-end-imorph-lex := v-neg-polite-past-end-lex &
				       [LMORPH-BIND-TYPE i-morph].

v-neg-polite-past-end-taispec-lex := v-neg-polite-past-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.KEYS.KEY tai_v_want_rel,
  LMORPH-BIND-TYPE a-morph].

; <type val="v-neg-polite-past-end-adjspec-lex">
; <name-ja>承形容詞連用形助動詞過去否定丁寧
; <description>v-neg-polite-present-adjspr-end-lex「あり ませ ん」の否定形。
; <ex>良く あり ませ ん でし た
; <nex>紙 が あり ませ ん でし た
; <todo>
; </type>
v-neg-polite-past-end-adjspec-lex := v-neg-polite-past-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD i-adj-stem_head,
  LMORPH-BIND-TYPE a-morph].

v-neg-polite-present-spr-end-lex := v-neg-polite-present-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM.LOCAL.CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
					BAR +]] >,
			  MARK null,
			  FIN +,
			  J-POSTHEAD rels,
			  J-SPEC < [LOCAL.CAT.HEAD noun_head] >]],
  LMORPH-BIND-TYPE a-morph].

; <type val="v-neg-plain-present-spr-end-lex">
; <name-ja>否定助動詞ヌ終止形
; <description>否定助動詞「ず」のvariation。このtypeは終止形・連用形のみで活用をしない。
; 動詞の未然形につく。
; <ex>食べ ぬ
; <ex>思わ ぬ 事態
; <nex>
; <todo>(TK 07-04-02)このtypeには必ずV-END-RU-INFLE-RULEを適用するかどうかの選択が出るが、
; Dependenciesの上では差がないように見える。
; (TK 07-04-02)また、現状ではサ行変格活用動詞の「し」「じ」の直後につくようになっているが、
; 「せ」「ぜ」の直後でなければならない（「じ」はさほど悪くない気もする）。
; (lkb::do-parse-tty "感心 せ ぬ")(lkb::do-parse-tty "論ぜ ぬ")(lkb::do-parse-tty "論じ ぬ")
; </type>
v-neg-plain-present-spr-end-lex := v-neg-plain-present-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM.LOCAL.CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
					BAR +]] >,
			  MARK null,
			  FIN +,
			  J-POSTHEAD rels,
			  J-SPEC < [LOCAL.CAT.HEAD noun_head] >]],
  LMORPH-BIND-TYPE a-morph].

v-neg-polite-present-tai-end-lex := v-neg-polite-present-spr-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LKEYS.KEYREL tai-relation].


v-neg-polite-present-adjspr-end-lex := v-neg-polite-present-spr-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD i-adj-stem_head].


v-neg-polite-present-namark-end-lex := v-neg-polite-present-end-lex &
 [SYNSEM.LOCAL.CAT.HEAD [MOD null,
			 MARK.FIRST.LOCAL.CAT.HEAD na-adj_head,
			 J-SPEC null,
			 FIN -],
  LMORPH-BIND-TYPE a-morph,
  RMORPH-BIND-TYPE shortadj-morph].


; <type val="v-finite-present-plain-negative-end-lex">
; <name-ja>否定助動詞終止
; <description>動詞の未然形やi-adj-lexの連用形の後にあって否定の意を表す。このtype後には助詞・助動詞
; の類を接続できない。活用はi-adj-lexと同じパターンと思われるが、終止形と連体形しか出現しない。
; nai-noncaus-end-lexとは相反するtype。現状では用言とこのtypeの間に「は」などの助詞が挟まってしまうと
; 正しく解析できない（「痛く は ない」など）。
; <ex>騒が ない
; <ex>打て ない 打者
; <nex>打て なく て 負け た
; <nex>打て なかっ た
; <todo>（TK 07-03-30)(lkb::do-parse-tty "痛く は ない")も正しく解析できるようにすべき。
; </type>
v-finite-present-plain-negative-end-lex := v-neg-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM.LOCAL [CAT [HEAD [H-TENSE present,
			   MOD < [LOCAL [CAT.HEAD noun_head,
					 BAR +]] >,
			   MARK null,
			   C-MOD null,
			   J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
			   FIN +,
			   J-POSTHEAD rels,
			   FORMAL.AHON -]]],
  LMORPH-BIND-TYPE a-morph,
  STEMTYPE adj-stem,
  INFLECTED +].

v-neg-te-plain-end-lex := v-neg-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM [LOCAL [CAT [HEAD [FIN -,
			    H-TENSE te,
			    MOD null,
			    MARK null,
			    COP-ARG -,
			    C-MOD.FIRST.LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
					       BAR +],
			    J-POSTHEAD coord,
			    FORMAL.AHON -]]]],
  LMORPH-BIND-TYPE a-or-aa-morph].

; <type val="v-neg-te-plain-aamorph-end-lex">
; <name-ja>
; <description>
; <ex>
; <nex>
; <todo>(07-04-02)古風な表現の場合、(lkb::do-parse-tty "食べ ず")のようにこのtypeで終止することがあるが、
; その時にUTTERUNCE_RULE-DECL-INFINITEとUTTERUNCE_RULE-IMPの選択肢が出てしまうが、不要。
; </type>
v-neg-te-plain-aamorph-end-lex := v-neg-te-plain-end-lex &
				  [LMORPH-BIND-TYPE aa-morph].

v-neg-te-plain-amorph-end-lex := v-neg-te-plain-end-lex &
				  [LMORPH-BIND-TYPE a-morph].




; <type val="v-naide-end-lex">
; <name-ja>
; <description>動詞の未然形に後接して否定の意味を与え、
; 1.前後の節を等位接続する。
; 2.動詞とperspectiveを繋ぐ。
; 3.文末にあって否定と同時に禁止の意味(negative command)の意味を与える。
; <ex>
; <nex>
; <todo>
; </type>
v-naide-end-lex := v-neg-end-lex &
		   [J-NEEDS-AFFIX -,
		    SYNSEM [LOCAL [CAT [HEAD [FIN -,
					      H-TENSE tensed,
					      J-SPEC < [LOCAL [CAT.HEAD verb_head &
									[AUX aux_plus],
							       BAR +],
							LEX +] >,
					      MARK null,
					      COP-ARG -,
					      MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
							    BAR +]] >,
					      J-POSTHEAD coord,
					      FORMAL.AHON -],
					VAL.SPR.FIRST.LOCAL.CAT.VAL.UNSAT bool],
				   CONT.HOOK.INDEX.E.MOOD indicative]],
            LMORPH-BIND-TYPE a-morph].

; (ERB 2002-01-14) HCONS <! !> no longer true of all subtypes.  Move
; this to v-simple-end-lex.  Same for identifying LTOP of SPR with LTOP.
; Might as well move all the semantic stuff down.

; (ERB 2002-01-14) It looks like v-simple-end-lex-super and v-end-lex
; could actually be conflated.

; (MS 2003-05-13) This is what I actually did.

;v-simple-end-lex-super := v-end-lex &
;[SYNSEM [LOCAL [CAT.VAL [SPR.FIRST.LOCAL.CAT.VAL [SUBJ #sbj,
;						  COMPS #comps],
;			 SUBJ #sbj,
;			 COMPS #comps]]]].

; (ERB 2002-01-11) Most v-simple-end-lex subtypes are SMOD unmarked,
; the exception being the kudasai-vn-end-1 and its ilk.

; (MS 2002-01-16) There are more exceptions: NASAI!

; (ERB 2002-01-14) Making kudasai-vn-end more semantically contentful,
; so move semantic constraints here.

; (ERB 2002-01-15) Take MOD-IND and MOD-HAND from SPR, like LTOP and
; IND.  (immediate motivation is "VN+negai+masu" where "negai" is
; doing something special with MOD-IND and MOD-HAND.


v-simple-end-lex := v-end-lex &
[ SYNSEM [LOCAL [CAT [HEAD [SMOD smod,
			    KEYS.KEY #key],
                     VAL.SPR.FIRST [LOCAL [CONT [HOOK [LTOP #top,
						       INDEX #event]],
					   CAT.HEAD.KEYS.KEY #key]]],
		
                CONT [HOOK [INDEX #event,
			    LTOP #top],
                      HCONS <! !>]],
	  LKEYS.KEYREL [ARG0 #event,
			LBL #top]]].

; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

; (ERB 2002-01-02) Also moving the constraint VN = SPR.VN here.

; (ERB 2002-01-21) Make supertype for nasai that doesn't inherit
; SMOD umarked so that v-tense-end-lex can still have this constraint.
; (It's useful for constraining utterance-rule-2e and the nonprop
; conjunctions.)

v-tense-end-lex-super := v-simple-end-lex &
                   [SYNSEM [LOCAL [CAT [ HEAD.VN #vn,
                                        VAL.SPR.FIRST.LOCAL.CAT.HEAD.VN #vn & - ],
                                  CONT.RELS <! !>,
                                  CTXT.BACKGROUND <! !>],
			    MODIFIED.PERIPH -]].

; (ERB 2002-01-22) Keep v-tense-end-lex from undergoing adj 
; inflectional rules.

v-tense-end-lex := v-tense-end-lex-super &
                   [ SYNSEM.LOCAL.CAT.HEAD.SMOD unmarked,
                     STEMTYPE otherstem ].



; (MS 2002-12-02) Cleaning up the verbal endings: common features for tense endings
;(CH 2003-08-14)
; "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... & [MAIN-PRD +] ..>"
;    --> "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... ..>"
; 「Vて〜な様子」などがacceptされる
;

; (MS 2004-04-02) changed C-MOD verb_head to sentence-valid, to allow also excl's in the sentence coordination.
; (MS 2004-07-09) took AHON - out, to account for まして. Instead, co-indexed AHON of the C-MOD
; with AHON of the HEAD to allow S-mashite...masu and S-te...ta, but not S-mashite...ta.



;(CH 2005-03-10)
; ad hoc solution to parse 「太郎がボールを進んで打つ」「太郎がボールを続けて打つ」.
; I'm not sure if this is correct...
; I intended to make this somewhat parallel to intersective adverbs like 素早く.
; Ideally the subject of 打つ should control that of 進む or 続ける.
; But adjuncts like 進んで or 続けて cannot be gapped in JACY, and thus the subject of 進む
; or 続ける should be a zero pronoun. However, zpro_ref-ind and full_ref-ind (太郎) are incompatible.
; Therefore, the control relation would not be easy to develop unless we introduce an additional
; head-adjunct-rule-type.
; [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD utt-valid] prevents this from modifying utterance.
; [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD.COP -] prevents this from modifying copula verbs
; including those that are derived from NP via empty-cop-rule.
; (MS 2005-05-24) This adds massive ambiguity in all cases where there is a
; verb in te form (such as: 食べてもいい). 
; (FCB 2006-06-20)
; [SYNSEM.LOCAL.CAT.HEAD.MOD.FIRST.LOCAL.CAT.HEAD sentence-valid] prevents this from modifying utterances.'

te-adjunct-lex := basic-v-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM [LOCAL [CAT [ VAL.SPR < [ LOCAL.CONT.HOOK.LTOP #subord,
				   LEX + ] >,
		       HEAD [FIN -,
			    MARK null,
			    COP-ARG -,
			    C-MOD null,
			    MOD <[LOCAL scopal-mod &
					[CAT.HEAD sentence-valid & [COP -],
					 CONT.HOOK [ LTOP #main ]]]>,
			    J-POSTHEAD left]],
		 CONT [HOOK [INDEX [E.MOOD indicative],
			     LTOP #hand ],
		       RELS <! subord-relation &
			    [ PRED #pred,
			      LBL #hand,
			      L-HNDL #subord-hand,
			      R-HNDL #main-hand ] !>,
		       HCONS <! qeq & [ HARG #subord-hand, LARG #subord ],
			      qeq & [ HARG #main-hand, LARG #main ] !>]],
	  LKEYS.KEYREL [PRED #pred],
	  NON-LOCAL.QUE <! !>]].

; <type val="te-adjunct-lex-t">
; <name-ja>テ接続助詞従属
; <description>従属節の末尾につく助詞の「て」。動詞の連用形の直後につくが、音便を持つ語の場合は音便の直後につく。
; ガ行五段活用の動詞や音便が「ん」の場合はその後につくことはできない。活用はしない。
; <ex>ハサミ を 使っ て 切る
; <ex>太郎 が ボール を 続け て 打つ
; <nex>行っ て 帰る
; <nex>行っ て くる
; <todo>
; </type>
te-adjunct-lex-t := te-adjunct-lex &
		     [LMORPH-BIND-TYPE te-morph].

; <type val="te-adjunct-lex-d">
; <name-ja>デ接続助詞従属
; <description>従属節の末尾につく助詞の「で」。te-adjunct-lex-tを参照。このtypeは撥音便「ん」やガ行五段連用形
; イ音便の直後につく。
; <ex>進ん で 学ぶ
; <ex>泳い で 渡る
; <ex>太郎 が ボール を 進ん で 打つ
; <nex>泳い で 走る
; <nex>結ん で 開く
; <todo>
; </type>
te-adjunct-lex-d := te-adjunct-lex &
		     [LMORPH-BIND-TYPE nd-morph].


te-end-lex-basic := v-tense-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM.LOCAL [CAT [HEAD [FIN -,
			   MARK null,
			   COP-ARG -,
			   C-MOD < [LOCAL [CAT [HEAD sentence-valid & [FORMAL.AHON #ahon]],
					   BAR +]] >,
			   MOD null,
			   J-POSTHEAD coord,
			   FORMAL.AHON #ahon]],
		CONT.HOOK.INDEX.E.MOOD indicative]].

;;; change modified peripheral
v-te-end-lex := te-end-lex-basic &
 [SYNSEM.LOCAL.CAT [HEAD [J-SPEC < [LOCAL [CAT.HEAD verb_head & [AUX aux_plus],
					   BAR +],
				    LEX +,
				    MODIFIED.PERIPH bool] >,
			  MODUS #modus,
			  H-TENSE tensed],
		    VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS #modus]].

; <type val="v-te-end-tmorph-lex">
; <name-ja>テ接続助詞並列
; <description>２つの文を並列の関係で繋げる助詞。用言の連用形の直後につくが、音便を持つ語の場合は音便の直後につく。
; ガ行五段活用の動詞や音便が「ん」の場合はその後につくことはできない。
; <ex>投げ て 走る
; <ex>走っ て 歩く
; <nex>ナイフ で 切っ て 食べる
; <todo>
; </type>
v-te-end-tmorph-lex := v-te-end-lex &
 [LMORPH-BIND-TYPE te-morph].

; <type val="v-te-end-ndmorph-lex">
; <name-ja>デ接続助詞並列
; <description>v-te-end-tmorph-lexを参照。このtypeはガ行五段連用形イ音便や撥音便「ん」の直後につく。
; <ex>遊ん で 仕事 を する
; <nex>進ん で 勉強 する
; <todo>
; </type>
v-te-end-ndmorph-lex := v-te-end-lex &
 [LMORPH-BIND-TYPE nd-morph].

; <type val="v-te-end-ahon-lex">
; <name-ja>テ接続助詞並列尊敬
; <description>v-te-end-tmorph-lexを参照。このtypeは聞き手（読み手）への敬意を表す。動詞の連用形の直後につく。
; i-adj-lexの後にはつかない。
; <ex>木 が あり まして 犬 が 居 ます
; <nex>部屋 を 借り まして 住み ます
; <todo>(07-04-02)te-adjunct-lexに当たるtypeも必要(lkb::do-parse-tty "部屋 を 借り まして 住み ます")。
; </type>
v-te-end-ahon-lex := v-te-end-lex &
		     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +,
		      LMORPH-BIND-TYPE i-morph].



v-coord-end-lex := te-end-lex-basic &
		   [SYNSEM.LOCAL.CAT.HEAD [J-SPEC null,
					   FORMAL.AHON -,
					   MODUS indicative]].

; <type val="v-coord-end-tmorph-lex">
; <name-ja>タリ接続助詞並列
; <description>「〜たり+する」の形で用い、動詞を並立させたり、例示をしたりする場合に使う。
; 用言の連用形の直後につくが、音便を持つ語の場合は音便の直後につく。ガ行五段活用の動詞や音便が「ん」の場合は
; その後につくことはできない。
; <ex>煮 たり 焼い たり する
; <ex>喋っ たり する と 喉 が 痛い
; <ex>挨拶 し たり 片付け たり で 大変 だ
; <nex>数 が たり ない
; <todo>(TK 07-04-03)このtypeの場合、「する」という動詞が後につく場合が多いが、現状では「〜たり//する」は
; SENTENCE-TE-COORDINATION-RULEで接続されてしまっている。
; </type>
v-coord-end-tmorph-lex := v-coord-end-lex &
			  [LMORPH-BIND-TYPE t-morph].

; <type val="v-coord-end-ndmorph-lex">
; <name-ja>ダリ接続助詞並列
; <description>v-coord-end-tmorph-lexを参照。このtypeはガ行五段連用形イ音便や撥音便「ん」の直後につく。
; <ex>繋い だり 塞い だり する
; <ex>本 を 読ん だり する
; <nex>
; <todo>v-coord-end-tmorph-lexを参照。
; </type>
v-coord-end-ndmorph-lex := v-coord-end-lex &
			  [LMORPH-BIND-TYPE nd-morph].


comma-coord-end-lex := v-coord-end-lex &
		       [SYNSEM [LOCAL.CAT.HEAD.J-SPEC null,
				LKEYS.KEYREL adj-relation & 
						      [PRED "comma_c_rel"]],
			LMORPH-BIND-TYPE i-or-t-morph].
		

v-indicative-tense-end-lex :=   v-tense-end-lex &
             [J-NEEDS-AFFIX -,
              SYNSEM.LOCAL [CAT [HEAD [MOD <[LOCAL [CAT.HEAD noun_head,
                                                        BAR +]]>,
                                       C-MOD null,
                                       MARK null,
                                       FIN +,
                                       COP-ARG +,
                                       J-POSTHEAD rels,
                                       MODUS #modus],
                                 VAL.SPR.FIRST.LOCAL.CAT.HEAD.MODUS #modus],
                            CONT.HOOK.INDEX.E.MOOD indicative]]. 

;(MS 2005-11-10) getting rid of skip files.

; <type val="v-present-tense-end-lex">
; <name-ja>助動詞丁寧終止形
; <description>丁寧の意味を表す「ます」。日本語で一般的に助動詞として扱われている「ます」の終止形・連体形が
; このtypeにあたる（過去形などにはまた別のtypeがついている）。動詞の連用形の後について、聞き手（読み手）へ
; の敬意を表す。現在時制に使う。活用はしない。
; <ex>食べ ます
; <nex>食べ まし た
; <todo>(TK 07-05-07)「vn-ditrans-lex,vn-trans8-lex+lightverb」の第一目的格（「を」格にあたるもの）
; が現れている文章の後につくことができない
; (lkb::do-parse-tty "チェック よろしく お願い し ます")(lkb::do-parse-tty "家 を 売却 し ます")。
; </type>
v-present-tense-end-lex :=  v-indicative-tense-end-lex &
			    [SYNSEM.LOCAL.CAT.HEAD [H-TENSE present,
						    FORMAL.AHON +,
						    J-SPEC < [LOCAL.CAT.HEAD exceptional_noun_head] >],
			     LMORPH-BIND-TYPE i-morph].

v-past-tense-end-lex :=  v-indicative-tense-end-lex &
			    [SYNSEM.LOCAL.CAT.HEAD [H-TENSE past,
						    J-SPEC < [LOCAL.CAT.HEAD nom_head] >]].

; <type val="v-past-tense-end-ahon-lex">
; <name-ja>助動詞過去タ終止尊敬
; <description>v-past-tense-end-minusahon-tmorph-lexやv-past-tense-end-minusahon-ndmorph-lexの、
; 聞き手（読み手）への敬意を表す場合に使うためのtype。過去を表す「た」の前に丁寧を表す「ます」
; をつけて１つにしたものか。終止形・連体形のみで活用はしない。
; 動詞の連用形の直後にのみつく。
; <ex>勝ち まし た
; <nex>
; <todo>(TK 07-05-08)「で ある」の連用形「で あり」の後にもつけられるようにすべき
; (lkb::do-parse-tty "無事 で あり まし た")。
; </type>
v-past-tense-end-ahon-lex := v-past-tense-end-lex &
			     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +,
			      LMORPH-BIND-TYPE i-morph].
			     
v-past-tense-end-minusahon-lex := v-past-tense-end-lex &
			     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -,
			      INFLECTED +].

; <type val="v-past-tense-end-minusahon-tmorph-lex">
; <name-ja>助動詞過去タ終止非尊敬
; <description>用言や助動詞の連用形について、（一般に）過去の意味を表す「た」。「た」は日本語では一般的に
; 活用をする助動詞として扱われるが、このtypeはその終止形・連体形にあたり、活用はしない。
; また、読み手（聞き手）への敬意を表す場合には使えない。
; 音便を持つ語の場合は音便の直後につくが、ガ行五段活用の動詞や音便が「ん」の動詞の場合はその後につく
; ことはできない。
; <ex>勝っ た
; <ex>病気 だっ た 人
; <nex>
; <todo>
; </type>
v-past-tense-end-minusahon-tmorph-lex := v-past-tense-end-minusahon-lex &
 [LMORPH-BIND-TYPE ta-morph].

; <type val="v-past-tense-end-minusahon-ndmorph-lex">
; <name-ja>助動詞過去ダ終止非尊敬
; <description>v-past-tense-end-minusahon-tmorph-lexを参照。このtypeはガ行五段活用のイ音便や撥音便「ん」
; の直後につく「だ」。
; <ex>呼ん だ
; <ex>泳い だ 人
; <nex>犬 だ
; <todo>
; </type>
v-past-tense-end-minusahon-ndmorph-lex := v-past-tense-end-minusahon-lex &
					 [LMORPH-BIND-TYPE nd-morph].


v-consultative-tense-end-lex := v-tense-end-lex &
 [J-NEEDS-AFFIX -,
  SYNSEM.LOCAL [CONT.HOOK.INDEX.E.MOOD consultative,
		CAT.HEAD [MOD null,
			  C-MOD null,
			  H-TENSE present,
			  MARK null,
			  COP-ARG -,
			  J-SPEC null,
			  FIN +,
			  MODUS consultative]]].

v-consultative-tense-polite-end-lex := v-consultative-tense-end-lex &
 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

v-consultative-tense-plain-end-lex := v-consultative-tense-end-lex &
 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

v-consultative-tense-imorph-end-lex := v-consultative-tense-end-lex &
 [LMORPH-BIND-TYPE i-morph].

v-consultative-tense-omorph-end-lex := v-consultative-tense-end-lex &
 [LMORPH-BIND-TYPE o-morph].

; <type val="v-consultative-tense-polite-imorph-end-lex">
; <name-ja>承動詞未然助動詞相談丁寧
; <description>v-consultative-tense-plain-imorph-end-lexやv-consultative-tense-plain-omorph-end-lexの丁寧版。
; 聞き手（読み手）への敬意を表す場合に使う。動詞・助動詞の連用形につく。
; <ex>行き ましょ う
; <ex>投げ ましょ う
; <nex>
; <todo>
; </type>
v-consultative-tense-polite-imorph-end-lex := v-consultative-tense-polite-end-lex & v-consultative-tense-imorph-end-lex.

; <type val="v-consultative-tense-plain-imorph-end-lex">
; <name-ja>承一段動詞未然助動詞相談
; <description>一段活用・変格活用動詞の未然形の直後について、相談・勧誘・命令・推測などの意味を表すもの。活用はしない。
; <ex>投げ よう
; <ex>し よう
; <ex>来 よう
; <nex>球 の 投げ よう が 悪い
; <todo>
; </type>
v-consultative-tense-plain-imorph-end-lex := v-consultative-tense-plain-end-lex & v-consultative-tense-imorph-end-lex.

; <type val="v-consultative-tense-plain-omorph-end-lex">
; <name-ja>承動詞未然助動詞相談
; <description>v-consultative-tense-plain-imorph-end-lexを参照。このtypeは、「一段活用動詞・変格活用動詞の語幹+よ」
; あるいは五段動詞・助動詞の未然形につく。活用はしない。
; <ex>投げよ う
; <ex>買お う
; <ex>犬 だろ う
; <nex>う が 泳ぐ
; <todo>(TK 07-04-03)カ変活用動詞「来る」もこのtypeで解析できるようにしたほうが良いのかもしれない。(lkb::do-parse-tty "来よ う")
; The meaning is different in copular and adjectives 
; (TK 07-04-03)i-adj-lexの未然形の直後にもつくようにすべき。(lkb::do-parse-tty "寒かろ う")
; </type>
v-consultative-tense-plain-omorph-end-lex := v-consultative-tense-plain-end-lex & v-consultative-tense-omorph-end-lex.


; <type val="v-imperative-tense-end-lex">
; <name-ja>補助動詞命令ナサイ
; <description>補助動詞「なさる」の命令形が独立したもの。動詞の連用形につく。活用はしない。
; <ex>行き なさい
; <ex>観念 し なさい
; <nex>勉強 を なさい
; <todo>(TK 07-04-02)補助動詞「なさる」は、現代語としては命令形でのみ使われるが、古風な文章では命令形以外
; でも使うことがある。(lkb::do-parse-tty "行き なさっ た")(lkb::do-parse-tty "食べ なされ ば 治る")
; </type>
v-imperative-tense-end-lex := v-tense-end-lex-super &
                 [J-NEEDS-AFFIX -,
		  LMORPH-BIND-TYPE i-morph,
                  SYNSEM.LOCAL.CAT [HEAD [MODUS simple-imperative,
                                          MOD null,
                                          COP-ARG -,
                                          C-MOD null,
                                          H-TENSE present,
                                          MARK null, 
                                          J-SPEC null,
					  SMOD imp,
                                          FIN +]]].


; (ERB 2001-11-12) As an experiment, saying that the ARG1 of
; tai is always first or second person.  This is somewhat justified 
; on the grounds that if you're talking about someone else, you're
; supposed to say -tagaru.  It should help cut down on attachment
; ambiguity in sentences like "ginkou ga doko ni aru no ka shiritai"
; where we don't want ginkou showing up as the subject of shiritai.
; Also, I suspect that the target domain should have lower than 
; average uses of third-person tai (as opposed to novels or other
; cases with usual perspective-taking).

; (ERB 2001-11-19) Something in this type (or its supertypes) is causing
; a label problem.  I suspect it has to do with identifying the KEY 
; with the KEY of the SPR.  If we need to keep this for adjunct attachment
; purposes, then we will have to make tai-end-lex not inherit from
; lexical-sign_word and do something special in the k2y code to make
; sure it doesn't get lost.

; (ERB 2001-11-19) I'm not sure KEY identification is the way to go
; for the adjunct attachment problem anyway, as adjuncts should really
; be looking at LTOP and INDEX and not KEY. 

; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message 

tai-end-lex-basic := v-noncaus-op-end-lex &
               [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [KEYS.KEY #pred],
                                   VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #ohand,
								    XARG #sbjind]]]],
                              CONT [RELS <! tai-relation & #key & 
					  [ LBL #top,
					    PRED #pred,
					    ARG0 #event,
					    ARG1 #sbjind,
					    ARG2 #chand] !>,
                                    HOOK [INDEX #event,
					  LTOP #top],
                                    HCONS <! qeq & [HARG #chand, LARG #ohand] !>],
                              CTXT subj-honor-ctxt &
                                  [BACKGROUND <! subj-honor_rel &
                                               [HONORED #sbjind,
                                                BEARER #event,
						POLARITY -] !>]],
			LKEYS.KEYREL #key],
                LMORPH-BIND-TYPE i-morph].

; <type val="taku-end-lex">
; <name-ja>終助詞願望
; <description>願望を表す「たい」の連用形に当たるtype。用言の連用形の後につく。
; 終止形・連体形に当たるものはtai-minusshon-end-lexで、それら以外の活用形については
; tai-notyetend-adjstem-lexでカバーしている。
; ただし、現状では「たい」の連用形としての働きをしておらず、このtypeによって文が終止
; してしまう。
; むしろ「○○していただきたく思います」のような形のためのtypeか。
; <ex>帰り たく ない
; <ex>ここ は 帰っ て いただき たく
; <nex>帰り たい
; <todo>(TK 07-05-09)tai-notyetend-adjstem-lexを参照。現状では「○○たく」と「ない」が
; SENTENCE-TE-COORDINATION-RULEで接続されてしまう。
; </type>
taku-end-lex := tai-end-lex-basic &
           [J-NEEDS-AFFIX -,
            INFLECTED +,
            SYNSEM.LOCAL [CAT [HEAD [C-MOD < [LOCAL [CAT [HEAD verb_head & [MAIN-PRD +]],
                                                BAR +]] >, 
                                     H-TENSE te,
                                     J-POSTHEAD coord,
                                     MARK null,
                                     COP-ARG -,
                                    J-SPEC < [LOCAL [CAT.HEAD verb_head & [AUX aux_plus],
                                                 BAR +],
					      LEX +] >,
                                     FIN -,
                                     FORMAL [SHON -],
                                     MODUS voluntative]]]].

; <type val="tai-end-lex">
; <name-ja>終助詞連語願望
; <description>願望をあらわす「たい」に素振りを表す動詞接尾「がる」がついたもの。
; 基本的にこのtypeによって文を終止するが、後に更に名詞や終助詞などがつくこともある。
; 本来は五段活用だが、その終止形・連体形にあたるものがこのtype。連用形など、他の活用形
; のものはtai-notyetend-cstem-lexがカバーしている。
; <ex>行き たがる
; <nex>行き たがら ない
; <todo>(TK 07-05-09)"AHON +"である必要があるか。
; </type>
tai-end-lex := tai-end-lex-basic &
	       [SYNSEM.LOCAL [CAT.HEAD [MODUS voluntative,
				       MOD < [LOCAL [CAT.HEAD noun_head,
						  BAR +]] >,
				       H-TENSE present,
					C-MOD null,
				       J-POSTHEAD rels,
				       MARK null,
				       J-SPEC.FIRST.LOCAL.CAT.HEAD nom_head,
				       FIN +,
				       FORMAL.AHON +]],
		J-NEEDS-AFFIX -,
		INFLECTED +].

; <type val="tai-minusshon-end-lex">
; <name-ja>終助詞願望
; <description>願望を表す終助詞。基本的にこれによって文を終止するが後に助動詞「です」
; や終助詞や名詞などがつくこともある。動詞の連用形の直後につく。本来はi-adj-stem-lexと
; 同じ活用をするが、その終止形・連体形にあたるものがこのtypeである。連用形など、その他の
; 活用形についてはtai-notyetend-adjstem-lexがカバーする。
; また、このtypeは主語への敬意を表す場合には使えない。
; <ex>戻り たい
; <ex>行き たい です
; <nex>
; <todo>
; </type>
tai-minusshon-end-lex := tai-end-lex &
			 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON -].

tai-notyetend-lex :=  tai-end-lex-basic &
		      [J-NEEDS-AFFIX +,
		       INFLECTED -,
		       SYNSEM [LOCAL.CAT.HEAD [MOD null,
					       C-MOD null],
			       MODIFIED.PERIPH bool]].

; <type val="tai-notyetend-adjstem-lex">
; <name-ja>終助詞願望
; <description>tai-minusshon-end-lexを参照。このtypeによって文が終止することはない。
; i-adj-stem-lexと同じ活用をし、助動詞や助詞などに接続するが、現状では「たかっ」と「たけれ」、
; また「たく+て」の場合のみ「たく」もこのtypeで解析される。
; <ex>帰り たかっ た
; <ex>帰り たけれ ば 帰る
; <nex>帰り たい
; <todo>(TK 07-05-09)連用形「たく」はtaku-end-lexではなくこのtypeで解析できるようにしたほう
; が良いのではないか(lkb::do-parse-tty "帰り たく ない")。
; </type>
tai-notyetend-adjstem-lex := tai-notyetend-lex &
			     [STEMTYPE adj-stem].

; <type val="tai-notyetend-cstem-lex">
; <name-ja>終助詞連語願望五段
; <description>tai-end-lexを参照。このtypeは五段活用をし
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)、
; 助動詞や助詞などに接続する。ただし、終止形と連体形がない。
; <ex>行き たがっ た
; <nex>行き たがる
; <todo>
; </type>
tai-notyetend-cstem-lex := tai-notyetend-lex &
			     [STEMTYPE c-stem].


; (ERB 2001-09-06) Currently the MARG of the main prpstn in conditional sentences
; QEQs an unbound handle.  I'm hoping to fix this by exposing the handle of the
; if_then_rel.

;(CH 2003-08-14) MODIFIED VERSION
; 関係節中に条件節が生起できるようにした。
; "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... & [MAIN-PRD +] ..>"
;    --> "SYNSEM.LOCAL.CAT.HEAD.C-MOD < ... ..>"
;(CH 2003-08-22)
; "SYNSEM.LOCAL.CAT.HEAD.MOD null"
;    --> "SYNSEM.LOCAL.CAT.HEAD.MOD < [LOCAL [CAT.HEAD verb_head,
;					  BAR +],
;				   LEX bool] >,
; 
; (FCB 2005-06-27) Added ARG0 to message 
; (FCB 2005-06-27) SYNSEM.LOCAL.CAT.HEAD.MOD null again
; this caused spurious ambiguity in 座れば寝る

; だら ば
; <type val="v-cond-end-lex">
; <name-ja>接続助詞条件
; <description>用言や助動詞の連用形の後につき、条件などを表す節を作るtype。
; 完了を表す「た」の濁音化した「だ」の仮定形「だら」に条件などを表す接続助詞「ば」のついた形か。
; 本来は撥音便「ん」やガ行五段連用形イ音便の直後につく。
; <ex>泳い だら ば 寒かっ た
; <nex>書い だら ば 寒かっ た
; <todo>(TK 07-04-20)"だら ば" should be nd-morph
; (TK 07-04-20)v-cond-end-pastspr-polite-tmorph-lex「たら ば」とはt-morphかnd-morphか以外に
; 違いがないと思われるのに、type hierarchy上の位置が全く違っている。
; </type>
v-cond-end-lex  :=  v-noncaus-op-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD v-cond-end_head & 
			   [C-MOD < [LOCAL [CAT [HEAD verb_head],
					    BAR +,
					    CONT.HOOK [LTOP #main,
						       INDEX #maini]]] >,
			    MOD null,
			    MARK null,
			    J-SPEC null,
			    J-POSTHEAD left,
			    COP-ARG -,
			    MODUS conditional,
			    MAIN-PRD -,
			    FIN -],
		      VAL.SPR.FIRST.LOCAL [CAT.HEAD.MAIN-PRD -,
					   CONT.HOOK [LTOP #subord,
						       INDEX #subordi]]],
		 CONT [HOOK [INDEX #ind,
			     LTOP #tophand],					       
		       RELS <! conjunction-relation & #key &
			     [ARG0 #ind,
			      LBL #tophand,
			      L-HNDL #subord,
			      L-INDEX #subordi,
			      R-HNDL #main,
			      R-INDEX #maini ] !>,
		       HCONS <!  !>]],
	  LKEYS.KEYREL #key],
  J-NEEDS-AFFIX -].

v-cond-end-pastspr-lex := v-cond-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE past].

v-cond-end-presentspr-lex := v-cond-end-lex &
 [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CONT.HOOK.INDEX.E.TENSE present].

v-cond-end-polite-lex := v-cond-end-lex &
 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

v-cond-end-plain-lex := v-cond-end-lex &
 [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].

v-cond-end-ind-lex := v-cond-end-lex &
 [SYNSEM.LOCAL.CONT.HOOK.INDEX.E.MOOD indicative].

v-cond-end-imorph-lex := v-cond-end-lex &
 [LMORPH-BIND-TYPE i-morph].

v-cond-end-tmorph-lex := v-cond-end-lex &
 [LMORPH-BIND-TYPE t-morph].

v-cond-end-ndmorph-lex := v-cond-end-lex &
 [LMORPH-BIND-TYPE nd-morph].

; <type val="v-cond-end-condmorph-lex">
; <name-ja>承仮定形接続助詞条件
; <description>用言や助動詞の仮定形の後につき、条件などを表す節を作る接続助詞。
; <ex>行け ば 分かる
; <nex>
; <todo>
; </type>
v-cond-end-condmorph-lex := v-cond-end-lex &
 [LMORPH-BIND-TYPE cond-morph].


v-cond-end-pastspr-polite-lex := v-cond-end-pastspr-lex & v-cond-end-polite-lex.
 
v-cond-end-pastspr-polite-imorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-imorph-lex. 

; まし たら, まし たら ば
; <type val="v-cond-end-pastspr-polite-ind-imorph-lex">
; <name-ja>承連用形接続助詞条件尊敬直接法
; <description>動詞や助動詞の連用形の後につき、条件などを表す節を作る。
; また、尊敬（丁寧？）を表す「ます」に完了の助動詞「た」の仮定形「たら」がついたと思われるこのtypeは
; 聞き手（読み手）への敬意を表す場合に使う。
; <ex>走り まし たら 疲れ まし た
; <nex>
; <todo>(TK 07-04-20)過去を表すとは限らない(lkb::do-parse-tty "いらっしゃい まし たら ご 連絡 ください")。
; ただし「〜ましたら〜ください」がなぜかうまく解析できない。
; (TK 07-04-20)仮定法でも使うかもしれない(lkb::do-parse-tty "お 金 が あり まし たら 買う の です が")。
; </type>
v-cond-end-pastspr-polite-ind-imorph-lex :=  v-cond-end-pastspr-polite-imorph-lex & v-cond-end-ind-lex.

v-cond-end-pastspr-plain-lex := v-cond-end-pastspr-lex & v-cond-end-plain-lex.

;たら, た ら
v-cond-end-pastspr-plain-tmorph-lex := v-cond-end-pastspr-plain-lex & v-cond-end-tmorph-lex.
; だら
v-cond-end-pastspr-plain-ndmorph-lex := v-cond-end-pastspr-plain-lex & v-cond-end-ndmorph-lex.

; <type val="v-cond-end-pastspr-polite-tmorph-lex">
; <name-ja>接続助詞条件
; <description>用言や助動詞の連用形の後につき、条件などを表す節を作るtype。
; 完了を表す「た」の仮定形「たら」に条件などを表す接続助詞「ば」のついた形か。
; 動詞の連用形の直後につくが、音便を持つ語の場合は音便の直後につく。ガ行五段活用の動詞や音便が
; 「ん」の場合はその後につくことはできない。
; <ex>先生 の お宅 に 寄っ たら ば ご 不在 でし た
; <nex>
; <todo>(TK 07-04-20)「たら ば」はAHON +とは限らない
; (lkb::do-parse-tty "先生 の お宅 に 寄っ たら ば ご 不在 だっ た")。
; (TK 07-04-20)また、上記の例のように「たら ば」は過去を表すとは限らない。
; (lkb::do-parse-tty "準備 が 出来 たら ば 教え なさい")
; </type>
v-cond-end-pastspr-polite-tmorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-tmorph-lex.

v-cond-end-pastspr-polite-ndmorph-lex := v-cond-end-pastspr-polite-lex & v-cond-end-ndmorph-lex.

; <type val="v-cond-end-presentspr-imorph-lex">
; <name-ja>接続助詞条件
; <description>用言や助動詞の連用形の後につき、条件などを表す節を作るtype？
; <ex>
; <nex>
; <todo>
; </type>
v-cond-end-presentspr-imorph-lex := v-cond-end-presentspr-lex & v-cond-end-imorph-lex.

; (MS 2001-11-22) RARERU needs an ARG1, if it shall be able to combine with TAI.

; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27) Added ARG0 to message 
rareru-end-lex :=  v-noncaus-op-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD v-op-end_head & 
			   [MARK < [MODIFIED.PERIPH -] >,
			    MODUS potential],
		      VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #ohand,
						       XARG #arg1 ]]]],
		 CONT [RELS <! rareru-relation &  
			     [ LBL #top,
			       ARG0 #event,
			       ARG1 #arg1,
			       ARG2 #rhand] !>,
		       HOOK [ LTOP #top,
			      INDEX #event ],
		       HCONS <! qeq & [HARG #rhand, LARG #ohand] !>]],
			MODIFIED.PERIPH bool],
  INFLECTED -]. 

; られる
; <type val="rareru-end-imorph-lex">
; <name-ja>承一段動詞可能接尾
; <description>一段活用の動詞の語幹の直後について、その行為が可能である意を添える接尾辞。
; このtype自身も一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>フォーク が 投げ られる
; <ex>フォーク を 投げ られる
; <nex>弟子 が 師匠 に 投げ られる
; <todo>(TK 07-04-09)可能表現の「に」格が主格、「が」格が目的格となる構文ができない
; (lkb::do-parse-tty "私 に 荷物 が 届け られる か")。
; Dependenciesを見ると「rareru_v_can[ARG2 proposition]」となっていて、常にARG1の項がブランク
; になっているが、何が入るのか。
; </type>
rareru-end-imorph-lex := rareru-end-lex &
 [LMORPH-BIND-TYPE i-morph,
  STEMTYPE v-stem].
; る
rareru-end-condmorph-lex := rareru-end-lex &
 [LMORPH-BIND-TYPE cond-morph].
; れる
; <type val="rareru-end-condexcmorph-lex">
; <name-ja>承語段動詞可能接尾
; <description>五段活用の動詞未然形について、その行為が可能である意を添える接尾辞。
; このtype自身も一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; （可能表現としては「行ける」のように「語幹+e+る」のほうがより多く使われる）
; また現状ではrareru-end-imorph-lexと同じように一段活用動詞の語幹の直後につくことも可能になっている。
; <ex>会議 に 行か れ ない
; <nex>皿 が 人 に 洗わ れる
; <todo>(TK 07-04-09)rareru-end-imorph-lexを参照。(lkb::do-parse-tty "子供 に 犬 が 飼わ れる か")
; </type>
rareru-end-condexcmorph-lex := rareru-end-lex &
 [LMORPH-BIND-TYPE cond-exceptional-morph].



; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

v-op-end-lex := lexical_sign-word &
 [SYNSEM synsem &
	 [LOCAL [CAT [HEAD verbend_head-unmarked &
			   [H-TENSE #tense,
			    VN #vn,
			    AUX #aux],
		      VAL [SPR obl-1-arg &
			       [FIRST.LOCAL [CAT [HEAD verb_head & [AUX #aux,
								    VN #vn & - ]],
					     BAR -]]]],
		 CONT verb-sem-type &
		     [HOOK [INDEX event &
				  [E [TENSE #tense]]]],
		 BAR -,
		 NUCL nucl_plus],
	  LEX +,
	  NON-LOCAL [QUE <! !>,
		     AFFIX <! !>]]].

v-noncaus-op-end-lex := v-op-end-lex &
 [SYNSEM.LOCAL [CAT.VAL [SUBJ #sbjval,
			 COMPS #compsval,
			 SPR.FIRST.LOCAL [CAT.VAL [SUBJ #sbjval,
						   COMPS #compsval],
					  CONT.HOOK.XARG #xarg,
					  ARG-S #args]],
		CONT.HOOK.XARG #xarg,
		ARG-S #args]].

naru-noncaus-end-lex := v-noncaus-op-end-lex &
 [INFLECTED -,
  LMORPH-BIND-TYPE a-morph,
  STEMTYPE c-stem,
  SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MODUS indicative],
		      VAL.SPR.FIRST.LOCAL.CONT [HOOK [LTOP #arg-h,
						      INDEX #event-v]]],
		 CONT [HOOK [INDEX #event,
			     LTOP #hd],
		       RELS <! #key & [ARG0 #event-v]!>,
		       HCONS <! !>]],
	  LKEYS.KEYREL #key & adv-relation &
		[LBL #hd,
		 ARG1 #arg-h,
		 ARG0 #event],
	  MODIFIED.PERIPH bool]].


; <type val="nai-noncaus-end-lex">
; <name-ja>否定助動詞非終止
; <description>動詞の未然形やi-adj-lexの連用形の後にあって否定の意を表す。このtypeによって文が終止すること
; はなく、後には助詞・助動詞の類を接続する。活用はi-adj-lexと同じパターンと思われるが、終止形と連体形は
; 出現しない。v-finite-present-plain-negative-end-lexとは相反するtype。現状では用言とこのtypeの間に「は」
; などの助詞が挟まってしまうと正しく解析できない（「痛く は なかっ た」など）。
; <ex>打て なかっ た
; <ex>打て なく て 負け た
; <nex>騒が ない
; <nex>打て ない 打者
; <todo>（TK 07-03-30)(lkb::do-parse-tty "痛く は なかっ た")も正しく解析できるようにすべき。
; （TK 07-05-07)(lkb::do-parse-tty "食べ なく なる")のような場合、「『食べる』の名詞化+i-adj-noncause-neg-
; stem-lex+なる」となってしまう。
; </type>
; vn-play MODIFIED.PERIPH -
; FIXME reify with nai-end
nai-noncaus-end-lex := v-noncaus-op-end-lex &
 [J-NEEDS-AFFIX +,
  INFLECTED -,
  LMORPH-BIND-TYPE a-morph,
  STEMTYPE adj-stem,
  SYNSEM [LOCAL [CAT [HEAD v-op-end_head & [MARK.FIRST [MODIFIED.PERIPH bool,
							LOCAL.CAT.HEAD verbend_head],
					    J-SPEC null,
					    COP-ARG -],
		      VAL.SPR.FIRST.LOCAL [CONT [HOOK [LTOP #v-hd,
						       INDEX #event]]]],
		 CONT [RELS <! #key & [ARG0 #event,
				       ARG1 #neg-arg,
				       LBL #top] !>,
		       HOOK [LTOP #top,
			     INDEX #event & [E.MOOD indicative]],
		       HCONS <! qeq & [LARG #v-hd,
				       HARG #neg-arg] !>]],
	  LKEYS.KEYREL #key & neg-relation,
	  MODIFIED.PERIPH bool]].




; (TT 2003-09-03) lex type を *-obj-* と *-obj2-* に
;                 v2-stem-lex を接続可能にするため

; (MS 2003-12-19) Matrix 0.6

; (MS 2004-11-22) The cause-relation should not include the wo-complement.
; (FCB 2008-02-17) reified the various causitive lex-types, removed message
;
; This sets up the POS etc
; defines the basic relation and adds a new subject: the causer and
; the handle of the specifier as the caused handle
; and the subject of the specifier as the person made to do something 
; - this has to be available for passivization
; FIXME - can reify more from the intransitives
; vn-play
v-cause-op-end-lex := v-op-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD caus-end_head & 
			   [MOD < [LOCAL [CAT.HEAD noun_head,
					  BAR +]] >,
			    C-MOD null,
			    J-POSTHEAD rels,
			    J-SPEC < [LOCAL.CAT.HEAD noun_head] >],
		      VAL [SPR obl-1-arg &
				[FIRST.LOCAL [CONT.HOOK [LTOP #hand,
							 XARG #causee],
					      CAT [HEAD verb-stem_head]]],
			   SUBJ [FIRST [OPT + ,
					LOCAL [CAT.HEAD overt-case-p_head & 
							[CASE ga],
					       CONT.HOOK.INDEX #causer]]]]],
		 CONT [HOOK [INDEX #event,
			     LTOP #top,
			     XARG #causer],
		       RELS <! #key !>,
		       HCONS <! qeq & [HARG #caused-hd, LARG #hand ] !> ]],
	  LKEYS.KEYREL  #key & arg123-relation &
		[LBL #top,
		 PRED "_saseru_v_cause_rel",
		 ARG0 #event,
		 ARG1 #causer,
		 ARG2 #causee,
		 ARG3 #caused-hd ],
	  MODIFIED.PERIPH bool],
  STEMTYPE v-stem,
  INFLECTED -].

;;; this adds a ni-case, which becomes the subject of the embedded verb
caus-trans-obj-end-lex := v-cause-op-end-lex &
 [SYNSEM.LOCAL [ CAT.VAL [SPR 
			      [FIRST.LOCAL [ CONT.HOOK.XARG #causee,
					     CAT [VAL sbj-obj-arg &
						      [UNSAT +,
						       COMPS 1-list & 
							     [FIRST #obj-val]]]]],
			  COMPS < #obj-val,
				  [LOCAL [CAT.HEAD overt-case-p_head & [CASE ni],
					  CONT.HOOK.INDEX #causee]] >]]].

caus-trans-obj-passcmorph-end-lex := caus-trans-obj-end-lex &
				     [LMORPH-BIND-TYPE pass-c-stem-morph].

caus-trans-obj-passvmorph-end-lex := caus-trans-obj-end-lex &
				     [LMORPH-BIND-TYPE pass-v-stem-morph].


; (MS 2005-09-28) A second reading of the causative ending propagates the verb stem INDEX,
; such that this can be accessed by adverbs (to account for ambiguity in expressions like "花子が紀子に学校で走らせた")

caus-trans-obj-scope-end-lex := v-cause-op-end-lex &
 [SYNSEM [MODIFIED.PERIPH bool,
	  LOCAL [CAT [VAL [SPR obl-1-arg &
			       [FIRST [LOCAL [CONT [HOOK [INDEX #v-event,
							  XARG #causee]],
					      CAT [VAL sbj-obj-arg &
						       [UNSAT +,
							COMPS 1-list & [FIRST #obj-val]]]]]],
			   COMPS < #obj-val,
				   [LOCAL [CAT.HEAD overt-case-p_head & [CASE ni],
					   CONT.HOOK.INDEX #causee]] >]],
		 CONT.HOOK.INDEX #v-event]]].
;;;
;;; FCB don't use these currently (2009-06-04)
;;; we don't want the ambiguity yet
;(TK 09-06-05 commented out)
;
;caus-trans-obj-scope-passcmorph-end-lex := caus-trans-obj-scope-end-lex &
;				     [LMORPH-BIND-TYPE pass-c-stem-morph].
;
;caus-trans-obj-scope-passvmorph-end-lex := caus-trans-obj-scope-end-lex &
;				     [LMORPH-BIND-TYPE pass-v-stem-morph].

; (MS 2005-09-21) linked the SPR-SUBJ to the complement.

caus-intrans-end-lex := v-cause-op-end-lex &
 [SYNSEM [LOCAL [CAT [VAL [COMPS 1-list & < [OPT + ,
					     LOCAL [CAT.HEAD overt-case-p_head & [CASE wo-or-ni],
						    CONT.HOOK.INDEX #causee]] >,
			   SPR obl-1-arg &
				      [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
							       INDEX #caused,
							       XARG #causee],
						    CAT [HEAD verb-stem_head,
							 VAL [UNSAT +,
							      SUBJ.FIRST.LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
										CONT.HOOK.INDEX #causee],
							      COMPS null]]]]]],
		 CONT [HOOK.INDEX  #caused,
		       RELS <!  [ARG2 #causee] !>,
		       HCONS <! qeq & [ LARG #hand] !> ]]]].

caus-intrans-passcmorph-end-lex := caus-intrans-end-lex &
				   [ LMORPH-BIND-TYPE pass-c-stem-morph ].

caus-intrans-passvmorph-end-lex := caus-intrans-end-lex &
				   [ LMORPH-BIND-TYPE pass-v-stem-morph ].


; (MS 2005-09-21) A second reading of the causative ending propagates the verb stem LTOP and INDEX,
; such that this can be accessed by adverbs (to account for ambiguity in expressions like "花子が紀子に学校で走らせた")

caus-intrans-scope-end-lex := v-cause-op-end-lex &
 [ SYNSEM [LOCAL [CAT [VAL [COMPS 1-list & 
				  < [OPT + ,
				     LOCAL [CAT.HEAD overt-case-p_head & 
						     [CASE wo-or-ni],
					    CONT.HOOK.INDEX #causee]] >,
			    SPR obl-1-arg &
				  [FIRST.LOCAL [CONT.HOOK [LTOP #hand,
							   INDEX #caused,
							   XARG #causee],
						CAT [HEAD verb-stem_head,
						     VAL [UNSAT +,
							  SUBJ.FIRST.LOCAL [CAT.HEAD overt-case-p_head & [CASE ga],
									    CONT.HOOK.INDEX #causee],
							  COMPS null]]]]]],
		  CONT [HOOK [INDEX #caused],
			RELS <! [ARG2 #causee] !>,
			HCONS <! qeq & [ LARG #hand] !> ]]]].

;;;
;;; FCB don't use these currently (2009-06-04)
;;; we don't want the ambiguity yet
;(TK 09-06-05 commented out)
;caus-intrans-scope-passvmorph-end-lex := caus-intrans-scope-end-lex &
;					 [LMORPH-BIND-TYPE pass-v-stem-morph].
;
;caus-intrans-scope-passcmorph-end-lex := caus-intrans-scope-end-lex &
;					 [LMORPH-BIND-TYPE pass-c-stem-morph].





;; vn-play
pass-end-lex :=  v-op-end-lex &
                 [SYNSEM [LOCAL [CAT [HEAD pass-end_head,
                                     VAL.SPR obl-1-arg],
                                CONT [HOOK [LTOP #top]]],
			  LKEYS.KEYREL.LBL #top,
			  MODIFIED.PERIPH bool]].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?
; (MS 2004-11-15) UNSAT + on the SPR to prevent spurious ambiguity in the case of
; ditransitive passives (置かれた)
; (MS 2004-11-18) Added PASS + to the event Index, such that this appears in the MRS. 
; Access ARG-S instead of RELS.LIST.FIRST.
; (MS 2004-11-30) It is too strict to say that the valence of the SPR should be sbj-obj-arg. 
; There could be a SPR (in case of causative-passive).
; (MS 2004-12-14) The SPR must be [LIGHT -], because we have a new rule for light passives.

; <type val="simple-pass-end-lex">
; <name-ja>承ヲ他動詞直接受身
; <description>v1-stem-lexの未然形の直後について、直接受身の意味を表す。
; <ex>
; <ex>
; <nex>
; <nex>
; <todo>
; </type>
simple-pass-end-lex :=   pass-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD simple-pass-end_head,
		      VAL [SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #surfsbjind]],
			   COMPS 1-list & < [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
						    CONT.HOOK.INDEX #surfobjind]] >,
			   SPR.FIRST [LOCAL [CONT [HOOK [INDEX #event,
							 LTOP #hand,
							 XARG #surfobjind]],
					     ARG-S < [LOCAL.CONT.HOOK.INDEX #surfobjind],
						     [LOCAL.CONT.HOOK.INDEX #surfsbjind] >,
					     CAT [VAL [UNSAT +,
						       SUBJ opt-1-arg,
						       COMPS 1-list &
							     < [LOCAL [CAT.HEAD case-p_head & 
										[CASE wo]]] > 
							     ],
;;; FCB try this
						  HEAD.LIGHT bool]]]],
		      HEAD.KEYS.KEY pass_v_rel],
		 CONT [RELS <! !>,
		       HOOK.INDEX #event & [E.PASS +],
		       HCONS <! !>],
		 CTXT.EMPATHY.EMPEE #surfsbjind],
	  LKEYS.KEYREL pass-relation &  [LBL #hand]],
  LMORPH-BIND-TYPE pass-morph,
  INFLECTED -,
  STEMTYPE v-stem].


;;; られる
; <type val="simple-pass-v-morph-end-lex">
; <name-ja>承一段ヲ他動詞直接受身
; <description>v1-v-stem-lexの未然形の直後について、直接受身の意味を表す。このtype自身も一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>ボール が 投げ られる
; <nex>ボール を 投げ られる
; <todo>(TK 08-03-06)v1-kurusuru-stem-lexの未然形「せ（ぜ）」にもつくべき。(lkb::do-parse-tty "言葉 が 発せ られる")
; </type>
simple-pass-v-morph-end-lex := simple-pass-end-lex &
 [LMORPH-BIND-TYPE pass-v-stem-morph].

;; れる
; <type val="simple-pass-c-morph-end-lex">
; <name-ja>承五段ヲ他動詞直接受身
; <description>v1-c-stem-lexの未然形の直後について、直接受身の意味を表す。このtype自身も一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>フォーク が 打た れる
; <nex>フォーク を 打た れる
; <todo>
; </type>
simple-pass-c-morph-end-lex := simple-pass-end-lex &
 [LMORPH-BIND-TYPE pass-c-stem-morph].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?
; (MS 2004-11-12) This seems to have mixed ARG2 and ARG3 in the arg123-relation.
; I have corrected that.
; (MS 2004-11-15) UNSAT + to prevent spurious ambiguity. 
; (MS 2004-11-20) Access ARG-S instead of RELS.LIST.FIRST!
; (MS 2004-11-22) Restricted to SPRs with sbj-obj-obj2-arg, namely ditransitives.

ditrans-pass-end-ganini-lex :=   pass-end-lex &
 [SYNSEM [LOCAL [CAT [VAL [UNSAT +,
			   SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #surfsbjind]],
			   COMPS < #objval & [LOCAL.CONT.HOOK.INDEX #surfobjind],
				   [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
					   CONT.HOOK.INDEX #surfobj2ind]] >,
			   SPR.FIRST [ LOCAL [CONT [HOOK [INDEX #event,
							  XARG #surfobj2ind,
							  LTOP #hand]],
					      CAT.VAL sbj-obj-obj2-arg & [UNSAT +],
					      ARG-S < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
							      CONT.HOOK.INDEX #surfobj2ind]],
						      [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE wo],
							      CONT.HOOK.INDEX #surfsbjind]],
						      #objval & [LOCAL [CAT.HEAD case-p_head & [CASE ni],
									CONT.HOOK.INDEX #surfobjind]] >]]],
		      HEAD.KEYS.KEY pass_v_rel],
		 
		   CONT [RELS <! !>,
			 HOOK.INDEX #event & [E.PASS +],
			 HCONS <! !>],
		 CTXT.EMPATHY.EMPEE #surfsbjind],
	  LKEYS.KEYREL pass-relation & [LBL #hand]],
  LMORPH-BIND-TYPE pass-morph,
  INFLECTED -,
  STEMTYPE v-stem].

; <type val="ditrans-pass-end-ganini-passcmorph-lex">
; <name-ja>承五段二重目的語動詞直接受身
; <description>五段活用のditransitiveの後にあって直接受身表現を作る。
; <ex>警察 によって ドライバー に 罰金 が 科さ れ た
; <nex>この 本 は その 人 によって 書か れ た
; <todo>
; </type>
ditrans-pass-end-ganini-passcmorph-lex := ditrans-pass-end-ganini-lex &
 [LMORPH-BIND-TYPE pass-c-stem-morph].

; <type val="ditrans-pass-end-ganini-passvmorph-lex">
; <name-ja>承一段二重目的語動詞直接受身
; <description>一段活用のditransitiveの後にあって直接受身表現を作る。
; <ex>斉藤 によって 松井 に ボール が 当て られ た
; <nex>斉藤 によって ボール が 投げ られ た
; <todo>
; </type>
ditrans-pass-end-ganini-passvmorph-lex := ditrans-pass-end-ganini-lex &
 [LMORPH-BIND-TYPE pass-v-stem-morph].



; (MS 2004-11-25) There is a second type of ditransitive passives:
; 田中がフランシスによってボールを当てられた
; These keep the wo-argument.


ditrans-pass-end-ganiwo-lex :=   pass-end-lex &
 [SYNSEM [LOCAL [CAT [VAL [UNSAT +,
			   SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #surfsbjind]],
			   COMPS < #objval & [LOCAL.CONT.HOOK.INDEX #surfobjind],
				   [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
					   CONT.HOOK.INDEX #surfobj2ind]] >,
			   SPR.FIRST [ LOCAL [CONT [HOOK [INDEX #event,
							  XARG #surfobj2ind,
							  LTOP #hand]],
					      CAT.VAL sbj-obj-obj2-arg & [UNSAT +],
					      ARG-S < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
							      CONT.HOOK.INDEX #surfobj2ind]],
						      #objval & [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE wo],
									CONT.HOOK.INDEX #surfobjind]],
						      [LOCAL [CAT.HEAD case-p_head & [CASE ni],
							      CONT.HOOK.INDEX #surfsbjind]] >]]],
		      HEAD.KEYS.KEY pass_v_rel],
		 CONT [RELS <! !>,
		       HOOK.INDEX #event & [E.PASS +],
		       HCONS <! !>],
		 CTXT.EMPATHY.EMPEE #surfsbjind],
	  LKEYS.KEYREL pass-relation & [LBL #hand]],
  LMORPH-BIND-TYPE pass-morph,
  INFLECTED -].

; <type val="ditrans-pass-end-ganiwo-passcmorph-lex">
; <name-ja>承五段二重目的語動詞間接受身
; <description>五段活用のditransitiveの後にあって間接受身表現を作る。
; <ex>警察 から ドライバー が 罰金 を 科さ れ た
; <nex>その 人 に 暴露 本 を 書か れ た
; <todo>
; </type>
ditrans-pass-end-ganiwo-passcmorph-lex := ditrans-pass-end-ganiwo-lex &
 [LMORPH-BIND-TYPE pass-c-stem-morph].

; <type val="ditrans-pass-end-ganiwo-passvmorph-lex">
; <name-ja>承一段二重目的語動詞間接受身
; <description>一段活用のditransitiveの後にあって間接受身表現を作る。
; <ex>松井 が 斉藤 から ボール を 当て られ た
; <nex>斉藤 から ボール が 投げ られ た
; <todo>
; </type>
ditrans-pass-end-ganiwo-passvmorph-lex := ditrans-pass-end-ganiwo-lex &
 [LMORPH-BIND-TYPE pass-v-stem-morph].



;(MS-2001-11-06) Emily wants the adversative passive not to add any semantics to the RELS. That's why I take the KEY out of the RELS and make the HCONS empty. But I am not sure if this is right: watashi ga otouto ni keeki wo taberareta.???

; (MS 2003-12-19) Matrix 0.6

;  (MS 2004-11-12) I had to bind the ARG2 of the adversative relation. It seems to me that the ARG2 should be the event, rather than
; the ARG1 of the verb. Then, we have only one adversative relation, with ARG1 (the surface subject) and ARG2 (the event).

adversative-pass-end-lex := pass-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD simple-pass-end_head,
		      VAL [SUBJ 1-list & < [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
						   CONT.HOOK.INDEX #surfsbjind]] >,
			   SPR 1-list & <  [LOCAL [CAT.VAL.UNSAT +,
						   CONT.HOOK.LTOP #sprhd]] >],
		      HEAD.KEYS.KEY pass_v_rel],
		 CONT [RELS <! #key !>,
		       HOOK [XARG #surfsbjind,
			     INDEX #event],
		       HCONS <!  !>]],
	  LKEYS.KEYREL #key & adversative-relation & [ARG1 #surfsbjind,
						      ARG2 #sprhd,
						      ARG0 #event]],
  LMORPH-BIND-TYPE pass-morph].
						     



adversative-intrans-pass-end-lex := adversative-pass-end-lex &
                [SYNSEM [LOCAL [CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
							 BAR +]] >,
					   J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					   FIN +,
					   J-POSTHEAD rels,
					   C-MOD null,
					   FORMAL.AHON -],
				     VAL [COMPS opt-1-arg & < [LOCAL [CAT.HEAD case-p_head & [CASE ni],
								      CONT.HOOK.INDEX #surfobjind]]>,
					 SPR < [LOCAL [CAT.VAL sbj-arg,
						       CONT.HOOK [XARG #surfobjind]]] >]],
			       CTXT.EMPATHY.EMPEE #surfobjind]],
		 STEMTYPE v-stem].

; <type val="adversative-intrans-pass-passvmorph-end-lex">
; <name-ja>承一段自動詞間接受身
; <description>一段活用の自動詞の後にあって間接受身表現を作る
; <ex>獲物 に 逃げ られる
; <nex>国 に 要求 が 認め られ た
; <todo>
; </type>
adversative-intrans-pass-passvmorph-end-lex := adversative-intrans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-v-stem-morph].

; <type val="adversative-intrans-pass-passcmorph-end-lex">
; <name-ja>承五段自動詞間接受身
; <description>五段活用の自動詞の後にあって間接受身を作る
; <ex>雨 に 降ら れ た
; <nex>雨 に 打た れ た
; <todo>
; </type>
adversative-intrans-pass-passcmorph-end-lex := adversative-intrans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-c-stem-morph].


; (MS 2003-12-19) Matrix 0.6, but is it right to grab RELS.LIST.FIRST?

adversative-trans-pass-end-lex := adversative-pass-end-lex &
                [SYNSEM [LOCAL [CAT [VAL [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #surfsbjind,
					 COMPS opt-2-args & < #obj & [LOCAL [CAT.HEAD case-p_head & [CASE wo]]] ,
								[LOCAL [CAT.HEAD case-p_head & [CASE ni],
									CONT.HOOK.INDEX #surfobjind2]] >,
					  SPR < [LOCAL [CAT.VAL sbj-obj-arg & [COMPS.FIRST #obj],
							CONT [HOOK [XARG #surfobjind2]]]] >]],
			       
			       CTXT.EMPATHY.EMPEE #surfsbjind]],
		 INFLECTED -,
		 STEMTYPE v-stem].

; <type val="adversative-trans-pass-passvmorph-end-lex">
; <name-ja>承一段他動詞間接受身
; <description>一段活用の他動詞の後にあって間接受身表現を作る。
; <ex>妹 に 私 の バナナ を 食べ られ た
; <nex>木の実 が 鳥 に 食べ られ た
; <todo>
; </type>
adversative-trans-pass-passvmorph-end-lex := adversative-trans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-v-stem-morph].

; <type val="adversative-trans-pass-passcmorph-end-lex">
; <name-ja>承五段他動詞間接受身
; <description>五段活用の他動詞の後にあって間接受身表現を作る。
; <ex>泥棒 に 財布 を 盗ま れる
; <nex>ボール が 投げ られる
; <todo>
; </type>
adversative-trans-pass-passcmorph-end-lex := adversative-trans-pass-end-lex &
					       [LMORPH-BIND-TYPE pass-c-stem-morph].



; (MS 2004-11-20) Passive ending for light verbs. This one is tricky, because we need to access
; the argument structure of the specifier of the specifier (namely, the VN). ARG-S is the right place
; to access these!



; <type val="lightverb-pass-end-lex">
; <name-ja>承サ変動詞受身
; <description>lightverbの直後にあって表現をつくる。現状ではvn-trans1-lexの直接受身しかカバーできていない。
; <ex>家 が 売却 さ れる
; <nex>財宝 が 奪わ れる
; <todo>(TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうため、
; (lkb::do-parse-tty "盗み さ れる")のようなおかしな文章も解析されてしまう。
; </type>
lightverb-pass-end-lex :=   pass-end-lex &
 [SYNSEM [LOCAL [CAT [VAL [SUBJ.FIRST [LOCAL [CAT.HEAD ga-or-wo-case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #surfsbjind]],
			   COMPS 1-list & < [LOCAL [CAT.HEAD case-p_head & [CASE ni-or-kara],
						    CONT.HOOK.INDEX #surfobjind]] >,
			   SPR.FIRST [LOCAL [CONT [HOOK [INDEX #event,
							 LTOP #hand,
							 XARG #surfobjind]],
					     CAT.VAL light_transitive & [UNSAT +,
									 SPR.FIRST.LOCAL.CAT.VAL sbj-obj-arg],
					     ARG-S < [LOCAL.CONT.HOOK.INDEX #surfobjind],
						     [LOCAL.CONT.HOOK.INDEX #surfsbjind] >]]],
		      HEAD.KEYS.KEY pass_v_rel],
		 CONT [RELS <! !>,
		       HOOK [INDEX #event & [E.PASS +],
			     LTOP #hand,
			     XARG #surfsbjind],
		       HCONS <! !>],
		 CTXT.EMPATHY.EMPEE #surfobjind],
	  LKEYS.KEYREL pass-relation &  [LBL #hand]],
  LMORPH-BIND-TYPE pass-c-stem-morph,
  INFLECTED -,
  STEMTYPE v-stem].

; (ERB 2002-01-02) Adding a vn-vend-rule (parallel to vstem-vend-rule)
; for VN + ください.  To keep that rule from massively overgenerating
; VN + vend combinations, most vends will require [VN -] SPRs.

; (ERB 2002-01-02) Also moving the constraint VN = SPR.VN here.

; (MS 2002-11-19) The coindexation of the subject must be moved to the semantics.

;v-honorific-end-lex := v-simple-end-lex &
;[SYNSEM.LOCAL [CAT [HEAD [ VN #vn,
;                           FORMAL.SHON + ],
;                    VAL.SPR.FIRST.LOCAL.CAT [ VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;								    CONT.HOOK.INDEX #2],
;                                               HEAD.VN #vn & - ]],
;               CONT [HOOK.INDEX #3,
;                     RELS <! !>],
;               CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
;                                                   [HONORED #2,
;                                                    BEARER #3,
;                                                    POLARITY +] !>]]].

; (MS 2003-12-19) Matrix 0.6

; <type val="v-honorific-end-lex">
; <name-ja>承和語動詞接尾辞尊敬
; <description>和語動詞の未然形の直後について、主語に対する尊敬の意を表す。現状では通常はv-stem-lex、
; GA-NO-CONVERSION-RULEを選択した場合にはc-stem-lexとv-stem-lexとkurusuru-stem-lexの直後につく。
; このtypeが必要とされることは実際のコーパス上では少ない。
; <ex>先生 が 戸 を 開け られる
; <ex>国王 の 書か れ た 親書
; <nex>球 が 投げ られる
; <todo>(TK 07-03-26)v-stem-lexとkurusuru-stem-lexの後につく「られる」とc-stem-lexの後につく「れる」でtypeを分けるべき。
;(TK 07-03-26)通常時でもc-stem-lexやkurusuru-stem-lexの後にもつくことができるようにすべき。(lkb::do-parse-tty "国王 が 書か れる")
; また、lightverbやauxの後につくtypeも作るべき。(lkb::do-parse-tty "国王 が 観戦 さ れる")(lkb::do-parse-tty "先生 が 戸 を 開け て いか れる")
; ただし、このtypeを選択すべき場合は稀なので、実際に直してしまうと曖昧性だけが増える結果になるかもしれない。
; </type>
v-honorific-end-lex := v-simple-end-lex &
[SYNSEM [LOCAL [CAT [HEAD [ VN #vn,
			    FORMAL [SHON +,
				    AHON -],
			    MOD < [LOCAL [CAT.HEAD noun_head,
					  BAR +]] >,
			    J-POSTHEAD rels,
			    J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
			    FIN +,
			    C-MOD null,
			    MODUS indicative],
                    VAL.SPR.FIRST [LOCAL [CAT.HEAD.VN #vn & -,
					  CONT.HOOK.XARG #2]]],
               CONT [HOOK.INDEX #3,
                     RELS <! !>],
               CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                   [HONORED #2,
                                                    BEARER #3,
                                                    POLARITY +] !>]],
	 MODIFIED.PERIPH bool],
 INFLECTED -,
 LMORPH-BIND-TYPE pass-v-stem-morph,
 STEMTYPE v-stem].

; (ERB 2001-11-14) This doesn't get "gohan wo tabechatta" because it requires
; tabe to pick up its arguments before combining, and tabe can't combine with
; the head-subj rule (it still needs an affix).

; (ERB 2001-11-14) Also changing the semantics to match the current version
; of shimau.  Should be changed when shimau gets changed to aspect only.

; (ERB 2001-11-19) Difficult merge here.  I'm going to start with Melanie's version
; and see if there are any changes left to work in.

; (ERB 2001-11-19) Adding back 11-14 changes... (the ending raises all of the 
; arguments; arg4only semantics).


; (ERB 2001-11-19) This version gets られちゃった but not
; non-subj arguments.


; (ERB 2001-11-19) This version gets arguments (ご飯をたべちゃった) but doesn't
; combine with passive.

; (ERB 2001-12-05) I think Melanie fixed it so it does combine with passive.
; There is some spurious ambiguity because the vend-vend rule can combine
; either られ and ちゃっ first or ちゃっ and た  first.

; (ERB 2001-12-05) Changing the semantics to be like "pure" aspect auxes
; now that I've changed shimau.  (Should bring teru in line with teiru, too!)


v-contracted-aux-end-lex := v-op-end-lex &
[SYNSEM [LOCAL [CAT [HEAD contracted-aux_head & 
			  [AUX aux_minus,
			   MODUS #modus],
		     VAL [SUBJ  #subjval,
                          COMPS #compsval,
			  SPR obl-1-arg &
				[FIRST [LOCAL [CONT.HOOK #hook,
					       CAT [HEAD [AUX aux_minus,
							  MODUS #modus],
						    VAL [SUBJ #subjval,
							 COMPS #compsval]]]]]]],
		CONT [RELS <! !>,
		      HOOK #hook,
		      HCONS <!  !>]],
	 MODIFIED.PERIPH bool],
 INFLECTED bool].


; <type val="v-contracted-aux-prog-end-super-lex">
; <name-ja>補助動詞縮約
; <description>動詞の連用形の直後につく「て（で）+aspect」の縮約形。
; <ex>
; <nex>
; <todo>
; </type>
v-contracted-aux-prog-end-super-lex := v-contracted-aux-end-lex &
 [J-NEEDS-AFFIX +,
  SYNSEM.LOCAL [CONT.HOOK.INDEX.E [ ASPECT progressive,
				    MOOD #modus],
		CAT.HEAD.MODUS #modus]].


v-contracted-aux-prog-end-lex := v-contracted-aux-prog-end-super-lex &
  [STEMTYPE v-stem].

;;; FIXME VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
;;; why does this block zeros (lkb::do-parse-tty "書い とる")
v-contracted-aux-prog-xshon-end-lex := v-contracted-aux-prog-end-super-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
		    VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #2],
	       CONT.HOOK.INDEX #3,
	       CTXT  subj-honor-ctxt & 
		   [BACKGROUND <! subj-honor_rel &
				[HONORED #2,
                                     BEARER #3,
                                     POLARITY -]!>]],
 STEMTYPE c-stem].

; [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -],
; ;                     VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
; ;                                            CONT.HOOK.INDEX #2]],
; ;                CONT.HOOK.INDEX #3,
;  CTXT  subj-honor-ctxt & 
; 	      [BACKGROUND <! subj-honor_rel !>],
; ;                                  [HONORED #2,
; ;                                     BEARER #3,
; ;                                     POLARITY -] !>]],
; ; 

v-contracted-aux-prog-xshon-end-toru-lex := v-contracted-aux-prog-xshon-end-lex &
[ LMORPH-BIND-TYPE t-morph].

v-contracted-aux-prog-xshon-end-doru-lex := v-contracted-aux-prog-xshon-end-lex &
[ LMORPH-BIND-TYPE nd-morph].



; <type val="v-contracted-aux-prog-end-teru-lex">
; <name-ja>補助動詞進行縮約テル
; <description>動詞の連用形の直後につく「て+いる(aspect)」の縮約形「てる」。動詞の連用形の直後につくが、音便を
; 持つ語の場合は音便の直後につく。音便が「ん」ガ行五段連用形の「い」の場合はその後につくことはできない。
; <ex>書い てる
; <nex>読ん てる
; <todo>
; </type>
v-contracted-aux-prog-end-teru-lex := v-contracted-aux-prog-end-lex &
[ LMORPH-BIND-TYPE t-morph].

; <type val="v-contracted-aux-prog-end-deru-lex">
; <name-ja>補助動詞進行縮約デル
; <description>動詞の連用形の直後につく「で+いる(aspect)」の縮約形「でる」。
; 撥音便「ん」やガ行五段連用形イ音便の直後につく。
; <ex>読ん でる
; <ex>嗅い でる
; <nex>書い でる
; <todo>
; </type>
v-contracted-aux-prog-end-deru-lex := v-contracted-aux-prog-end-lex &
 [LMORPH-BIND-TYPE nd-morph].


v-contracted-aux-inceptive-end-super-lex := v-contracted-aux-end-lex &
 [J-NEEDS-AFFIX +,
  SYNSEM.LOCAL [CONT.HOOK.INDEX.E [ ASPECT inceptive,
				    MOOD #modus],
		CAT.HEAD.MODUS #modus]].

v-contracted-aux-inceptive-end-lex := v-contracted-aux-inceptive-end-super-lex &
  [STEMTYPE c2-stem].

; <type val="v-contracted-aux-inceptive-end-teku-lex">
; <name-ja>補助動詞起動??縮約テル
; <description>動詞の連用形の直後につく「て+いく(aspect)」の縮約形「てく」。動詞の連用形の直後につくが、音便を
; 持つ語の場合は音便の直後につく。音便が「ん」ガ行五段連用形の「い」の場合はその後につくことはできない。
; <ex>書い てく
; <nex>読ん てく
; <todo>
; </type>
v-contracted-aux-inceptive-end-teku-lex := v-contracted-aux-inceptive-end-lex &
[ LMORPH-BIND-TYPE t-morph].

; <type val="v-contracted-aux-inceptive-end-deku-lex">
; <name-ja>補助動詞進行縮約デル
; <description>動詞の連用形の直後につく「で+いく(aspect)」の縮約形「でく」。
; 撥音便「ん」やガ行五段連用形イ音便の直後につく。
; <ex>読ん でく
; <ex>嗅い でく
; <nex>書い でく
; <todo>
; </type>
v-contracted-aux-inceptive-end-deku-lex := v-contracted-aux-inceptive-end-lex &
[LMORPH-BIND-TYPE nd-morph].

v-contracted-aux-terminative-end-lex := v-contracted-aux-end-lex &
 [J-NEEDS-AFFIX -,
  INFLECTED -,
  SYNSEM.LOCAL [CAT.HEAD.COP-ARG -,
		CONT [HOOK.INDEX.E [MOOD indicative,
				    ASPECT terminative]]],
  STEMTYPE c-stem].

; <type val="v-contracted-aux-terminative-tmorph-end-lex">
; <name-ja>補助動詞終止縮約チャウ
; <description>動詞の連用形の直後につく「て+しまう(aspect)」の縮約形。動詞の連用形の直後につくが、音便を
; 持つ語の場合は音便の直後につく。音便が「ん」やガ行五段活用の「い」の場合はその後につくことはできない。
; <ex>書い ちゃう
; <nex>読ん ちゃう
; <todo>
; </type>
v-contracted-aux-terminative-tmorph-end-lex := v-contracted-aux-terminative-end-lex &
 [LMORPH-BIND-TYPE t-morph].

; <type val="v-contracted-aux-terminative-ndmorph-end-lex">
; <name-ja>補助動詞終止縮約ジャウ
; <description>v-contracted-aux-terminative-tmorph-end-lexを参照。このtypeは撥音便「ん」や
; ガ行五段連用形イ音便の直後につく
; <ex>読ん じゃう
; <nex>書い じゃう
; <todo>
; </type>
v-contracted-aux-terminative-ndmorph-end-lex := v-contracted-aux-terminative-end-lex &
 [LMORPH-BIND-TYPE nd-morph].


v-contracted-aux-prospective-end-lex := v-contracted-aux-end-lex &
 [J-NEEDS-AFFIX -,
  INFLECTED -,
  SYNSEM.LOCAL [CAT.HEAD.COP-ARG -,
		CONT [HOOK.INDEX.E [MOOD indicative,
				    ASPECT prospective]]],
  STEMTYPE c-stem].

; <type val="v-contracted-aux-prospective-tmorph-end-lex">
; <name-ja>補助動詞前望?縮約トク
; <description>動詞の連用形の直後につく「て+おく(aspect)」の縮約形「とく」。動詞の連用形の直後につくが、音便を
; 持つ語の場合は音便の直後につく。音便が「ん」やガ行五段連用形の「い」の場合はその後につくことはできない。
; <ex>書い とく
; <nex>読ん とく
; <todo>
; </type>
v-contracted-aux-prospective-tmorph-end-lex := v-contracted-aux-prospective-end-lex &
 [LMORPH-BIND-TYPE t-morph].

; <type val="v-contracted-aux-prospective-ndmorph-end-lex">
; <name-ja>補助動詞前望?縮約ドク
; <description>動詞の連用形の直後につく「で+おく(aspect)」の縮約形「どく」。
; 撥音便「ん」やガ行五段連用形イ音便の直後につく。
; <ex>読ん どく
; <ex>嗅い どく
; <nex>書い どく
; <todo>
; </type>
v-contracted-aux-prospective-ndmorph-end-lex := v-contracted-aux-prospective-end-lex &
 [LMORPH-BIND-TYPE nd-morph].




;(MS 01-09-19) If the top-handle should be the handle of the subord_relg, we have problems with the restriction that LTOP = KEY.LBL.
; (MS 02-11-19) Shift the restriction on the subject to the semantics.
; (MS 2004-11-08) AUX aux_minus on the SPR seems to be too strict: 帰って来やすい

; (MS 2003-12-19) Matrix 0.6


v2adj-end-lex := v-op-end-lex &
[SYNSEM [LKEYS.KEYREL #key,
	 LOCAL [CAT [HEAD.MODUS indicative,
		     VAL [SPR.FIRST [OPT - ,
				     LOCAL [CAT [HEAD  verb-stem_head & [MAIN-PRD -,
									 COP -,
									 VN -,
									 AUX aux],
						 VAL [SUBJ #verbsbj & null,
						      COMPS #verbcomps]],
					    CONT.HOOK [LTOP #verbhd]]],
			  SUBJ #verbsbj,
			  COMPS #verbcomps]],
		CONT [HOOK [LTOP #adjhd,
			    INDEX #ind],
		      RELS <! #key & arg12-relation &  
			    [LBL #adjhd,
			     ARG0 #ind,
			     ARG2 #prpstn-hd] !>,
		      HCONS <! qeq & [HARG #prpstn-hd, LARG #verbhd] !>]]]].

v2adj-nmod-end-lex := v2adj-end-lex &
		      [SYNSEM [LOCAL.CAT.HEAD [H-TENSE present,
					       MODUS indicative,
					       MOD < [LOCAL [CAT [HEAD noun_head,
								  VAL.SPR 1-list],
							     BAR +]] >,
					       J-POSTHEAD rels,
					       MARK null,
					       VN -,
					       C-MOD null,
					       J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
					       FIN +,
					       FORMAL.AHON -]],
		       J-NEEDS-AFFIX -,
		       INFLECTED -,
		       LMORPH-BIND-TYPE i-morph].

v2adj-nmod-maybeend-lex := v2adj-end-lex &
		      [SYNSEM [LOCAL.CAT.HEAD [H-TENSE present,
						  MODUS indicative,
						  MOD < [LOCAL [CAT [HEAD noun_head,
								     VAL.SPR 1-list],
								BAR +]] >,
						  J-POSTHEAD rels,
						  MARK null,
						  VN -,
						  C-MOD null,
						  J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
						  FIN +,
						  FORMAL.AHON -],
			       MODIFIED.PERIPH bool],
			  J-NEEDS-AFFIX bool,
			  INFLECTED bool,
			  LMORPH-BIND-TYPE i-morph].

v2adj-nmod-maybeend-lex-v1 := v2adj-nmod-maybeend-lex &
			      [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & [FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
													     CONT.HOOK.INDEX #verbobj]]]]],
				       LKEYS.KEYREL.ARG1 #verbobj]].

v2adj-nmod-maybeend-lex-v2 := v2adj-nmod-maybeend-lex &
			      [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST #verbobj,
									CAT.VAL.COMPS null]]],
				       LKEYS.KEYREL.ARG1 #verbobj]].




v2adj-end-lex-v1 := v2adj-end-lex &
[SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & 
							[FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
								      CONT.HOOK.INDEX #verbobj]]]]],
	 LKEYS.KEYREL.ARG1 #verbobj]].

v2adj-notyetend-lex-v1 := v2adj-end-lex-v1 &
			  [J-NEEDS-AFFIX +,
			   LMORPH-BIND-TYPE i-morph].

v2adj-notyetend-lex-v2 := v2adj-end-lex-v2 &
			  [J-NEEDS-AFFIX +,
			   LMORPH-BIND-TYPE i-morph,
			   SYNSEM.MODIFIED.PERIPH bool].




v2adj-end-v1-nmod-lex := v2adj-nmod-end-lex &
			 [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CAT.VAL.COMPS 1-list & 
										 [FIRST.LOCAL [CAT.HEAD.CASE wo-or-ni,
											       CONT.HOOK.INDEX #verbobj]]]]],
				  LKEYS.KEYREL.ARG1 #verbobj]].
			 

v2adj-end-lex-v2 := v2adj-end-lex &
[SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST.ARG2 #verbobj,
					  CAT.VAL.COMPS null]]],
	 LKEYS.KEYREL.ARG1 #verbobj]].


v2adj-end-v2-nmod-lex := v2adj-nmod-end-lex &
			 [SYNSEM [LOCAL.CAT [VAL [SPR.FIRST.LOCAL [CONT.RELS.LIST.FIRST.ARG2 #verbobj,
							     CAT.VAL.COMPS null]]],
				  LKEYS.KEYREL.ARG1 #verbobj]].


; <type val="v2na-end-lex">
; <name-ja>承動詞連用形接尾辞形容動詞化
; <description>verbの連用形の後について、１つのna-adj-lexのような働きをするものを作る。活用はしない。
; <ex>疲れ 気味 だ
; <ex>卑下 し 気味 だ
; <nex>良い 気味 だ
; <todo>(TK 07-05-07)このtypeの語の後に「に+なる」をつけると、その「なる」はintrans-c-stem-lexになってしまい、
; 「○○の状態に変化する」という意味にならない(lkb::do-parse-tty "疲れ 気味 に なる")。
; </type>
v2na-end-lex := v-op-end-lex &
[J-NEEDS-AFFIX -,
 LMORPH-BIND-TYPE i-morph,
 SYNSEM [LKEYS.KEYREL #key & [ARG0 #event,
                                 LBL #top,
				 ARG4 #h2],
	 LOCAL [CAT [HEAD na-adj-end_head & [MAIN-PRD -],
		     VAL [SUBJ #sbjval,
			  COMPS #compsval,
			  SPR.FIRST [OPT - ,
				     LOCAL [CONT.HOOK.LTOP #h1,
					    CAT [VAL [COMPS #compsval,
						     SUBJ #sbjval],
						 HEAD.MAIN-PRD -]]]]],
               CONT [HOOK [INDEX #event,
			   LTOP #top],
                     RELS <! #key !>,
                     HCONS <! qeq & [HARG #h2,LARG #h1] !>]]]].

;"出来るだけ", "食べられるだけ"

; (MS 2003-12-17) Changing the semantics of adverbs (Matrix)

                                                 
v2adv-end-lex := lexical_sign-word &
 [SYNSEM  synsem & [LOCAL [CAT [HEAD adv_head-avm & 
				     [MOD < [LOCAL scopal-mod & 
						   [CONT.HOOK [LTOP #handel,
							       INDEX #ind],
						    CAT.HEAD.MODUS voluntative]] >,
				      COP-ARG +,
				      J-POSTHEAD left],
				VAL obj-arg &
				     [COMPS.FIRST [OPT - ,
						   LOCAL [CAT [HEAD verb_head &
								    [FIN +,
								     ADJ -,
								     FORMAL.AHON -,
								     MAIN-PRD -],
							       VAL saturated],
							  NUCL nucl_plus]]]],
			   CONT scopal-adv-sem-type &
			       [HOOK.INDEX #ind, 
				RELS <! #key !>,
				HCONS <! !>]],
		    LKEYS.KEYREL #key & adv-relation & [LBL #handel],
		    NON-LOCAL [QUE <! !>,
			       AFFIX <! !>]],
  INFLECTED +,
  LMORPH-BIND-TYPE mai-morph].     

;(CH 2005-04-09) added [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.BAR -].
; <type val="v2n-end-lex">
; <name-ja>承動詞連用形接尾辞名詞化
; <description>動詞の連用形の直後について、１つの名詞のような働きをするものを作る。活用はしない。現状ではlightverb
; の直後につくことはできない。「方」のみ、v2n-vstem-kata-infl-ruleあるいはv2n-cstem-kata-infl-ruleというruleが適用され
; るので、「打ち 方」だけでなく「打ち方」のようにスペースを空けていない場合でも解析できる。
; <ex>打ち 方 が 悪い
; <ex>打ち方 が 悪い
; <ex>食べ っぷり が 良い
; <nex>男 っぷり が 良い
; <todo>(TK 07-03-20)lightverbの後にもつくことができるようになったほうが良いかもしれない。(lkb::do-parse-tty "進行 し 方")
; </type>
v2n-end-lex :=  nom-lex &
 [SYNSEM [ LOCAL [CAT.VAL nom_sc & 
			 [SPR.FIRST.LOCAL [CAT [HEAD verb_head &
						     [MODUS infinitive,
						      ADJ -,
						      FORMAL.AHON -,
						      VN -,
						      MAIN-PRD -],
						VAL saturated],
					   BAR -,
					   CONT.HOOK.LTOP #v-hd,
					   NUCL nucl_plus]],
		 CONT nom-pred-sem-type &
			 [RELS <! #key &
				[ LBL  #kata-hd,
				  ARG0 #kata-index,
				  ARG1 #v-hd],
				quant-relation & 
				[PRED def_q_rel,
				 ARG0 #kata-index,
				 RSTR #def-restr] !>,
			  HOOK.INDEX #i,
			  HCONS <!qeq & [HARG #def-restr, LARG #kata-hd] !>]],
	   LKEYS.KEYREL #key & [ARG0 #i]]].
						    


; (MS 2003-12-19) Matrix 0.6
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

; <type val="mai-end-lex">
; <name-ja>否定推量助動詞マイ
; <description>verb・copula・v-end-lexの後ろについて、否定推量など種々の意味を付与する助動詞の「まい」。
; c-stem-lexやkurusuru-stem-lexのカ変活用の場合は終止形、v-stem-lexの場合は終止形と活用形（未然形？連用形？）、
; kurusuru-stem-lexのサ変活用の場合は終止形「する」「す」の直後につく。
; copulaの直後につく場合は「ではあるまい」の形のみ。
; 現状ではkurusuru-stem「来（こ）」「す」の直後にしか付くことができない。
; 活用はしない。ほとんどの場合は「まい」で文が終止するが、名詞が後続する場合もある。しかし一般的な用法と言えるかは不明。
; <ex>彼 が 失敗 を す まい
; <nex>
; <todo>(TK 08-06-19)助動詞の直後につけられるようにすべき。(lkb::do-parse-tty "失敗 は し ます まい")
; また、v-stem-lexの活用形、kurusuru-stem-終止形「する」につく場合は必ず文中に主語or目的語が必要。
; 以下、個人的メモとしてinflection(morph)-typeやvalencd-typeによる分類を載せる。
;「投げる」 v1-v-stem-lex終止形「が」TAI-OBJ-CHANGEの曖昧性が出る 「を」問題なし
;「栄える」 intrans-v-stem-lex 問題なし
;「投げ」 v-stem-lex活用形 「が」TAI-OBJ-CHANGEが出て× 「を」parsing自体×
;「栄え」 intrans-v-stem-lex活用形 parsing自体×
;「応じる」 v2-v-stem-lex 「が」TAI-OBJ-CHANGEの曖昧性が出る 「に」「に」自体がcaseかvmodかの曖昧性がでる（問題なし）
;「応じ」 v2-v-stem-lex活用形 「が」TAI-OBJ-CHANGEが出て× 「に」parsing自体×
;「呼ぶ」 v1-c-stem-lex 「が」TAI-OBJ-CHANGEの曖昧性が出る 「を」問題なし
;「降る」 intrans-c-stem-lex 問題なし
;「する」「来る」 kurusuru-stem-lex 「が」「を」parsing自体×
;「す」　　kurusuru-stem-lex短縮 「が」TAI-OBJ-CHANGEの曖昧性が出る 「を」問題なし
; </type>
mai-end-lex := v-noncaus-op-end-lex &
 [SYNSEM [LKEYS.KEYREL #key & neg-relation & 
		       [LBL #top, 
			PRED "neg_v_rel",
			ARG1 #h3],
	  LOCAL [CAT [HEAD v-op-end_head &
			   [MODUS indicative,
			    MOD null,
			    C-MOD null,
			    H-TENSE present,
			    MARK null,
			    J-SPEC null,
			    FIN +],
		      VAL.SPR.FIRST [LOCAL.CONT [HOOK [LTOP #h1,
						       XARG #x1]]]],
		 CONT [HOOK [INDEX #event,
			     LTOP #top],
		       RELS <! #key,
			     want2-relation & 
			     [LBL #h3,
			      ARG0 #event,
			      ARG1 #x1,
			      ARG2 #h6] !>,
		       HCONS <! qeq & [HARG #h6, LARG #h1] !>]]],
  J-NEEDS-AFFIX -,
  LMORPH-BIND-TYPE mai-morph].

;;; maybe I should make the specifier no_tense?

; <type val="beki-end-lex">
; <name-ja>
; <description>verbの終止形（「する」で終止するものは「す」形でも可）の直後につく「べき」。このtypeは活用しない。
; また、このtypeの語で文が終止する場合と、copulaあるいは名詞が後続する場合がある。
; <ex>彼 が 行く べき
; <ex>彼 が 行く べき だ
; <ex>行く べき 人
; <ex>宿題 を す べき
; <nex>
; <todo>(TK 08-06-18)現状ではこのtypeに名詞が後続できない。「行く べき 人」を参照。
; (TK 08-06-18)また、「verb+べき」にかかる主語or目的語がないと解析できない。(lkb::do-parse-tty "行く べき")
; (TK 08-06-18)「verb+aux_verb+べき」の場合は曖昧性が出る。
; (TK 08-06-18)便宜上「べし」もこのtypeに登録されているが、実際は振る舞いが違う。少なくともcopulaは後続しない。
; (TK 08-06-18)v1-stem-lex,v4-stem-lexの直後につき、「が」格が「verb+べき」にかかる場合、TAI-OBJ-CHANGE-RULE
; のつくtreeを排除できない。(lkb::do-parse-tty "彼 が 呼ぶ べき")
; </type>
beki-end-lex:= v-noncaus-op-end-lex &
 [SYNSEM [LOCAL [CAT [HEAD v-op-end_head &
			   [MODUS indicative,
			    MOD null,
			    C-MOD null,
			    H-TENSE present,
			    MARK null,
			    J-SPEC null,
			    FIN +],
		      VAL.SPR.FIRST.LOCAL.CONT.HOOK.LTOP #h1],
		 CONT [HOOK [INDEX #ind],
		       RELS <! #key & scopal-adv-relation &
			     [
			      ARG0 #ind,
			      ARG1 #h3] !>,
		       HCONS <! qeq & [HARG #h3, LARG #h1] !>]],
	  LKEYS.KEYREL #key ],
  J-NEEDS-AFFIX -,
  LMORPH-BIND-TYPE beki-morph].



; (ERB 2002-01-07) Need to add SMOD value to keep this from being
; the right conjunct of an s-conj-lex (as opposed to s-conj-nonprop-lex).

; (ERB 2002-01-11) Make sure this doesn't inherit SMOD unmarked.

; (ERB 2002-01-14) For nonprop conjunctions, make this more like
; kudasai-hiragana-sap, i.e., it contributes the imp_rel and does
; the right thing with the handle.  Should therefore also be SMOD decl.
; (Previously RELS & HCONS <! !> and SMOD imp.)

; (ERB 2002-01-14) These constraints are getting far to complicated
; to leave on the lexical entries themselves.  Making supertype here.

; (MS 2002-01-16) Added restrictions on subcategorization. 
; (MS 2003-12-17) Adapting to Matrix 0.6

;;; FIXME: when is this used?
kudasai-vn-end := v-end-lex &
[J-NEEDS-AFFIX -,
 SYNSEM [LOCAL [CAT [HEAD [MODUS polite-imperative,
                          MOD null,
                          COP-ARG -,
                          C-MOD null,
                          H-TENSE present,
                          MARK null, 
                          J-SPEC null,
                          FIN +,
                          VN -],
		    VAL [SPR.FIRST [LOCAL [CAT [HEAD.VN +],
					   CONT [HOOK [LTOP #sprh,
						       INDEX #ind]]]]]],
	       CONT [HOOK [LTOP #top,
			   INDEX #ind],
                     RELS <! !>,
                     HCONS <! qeq & [LARG #sprh,
                                      HARG #top] !> ]]]].


                   
;;;;;;;;;;;;;;VERBAL STEMS;;;;;;;;;;;;;;;

; (MS 2004-01-13) Experimenting with BAR bool instead of BAR -.
; (MS 2004-11-05) But that introduces spurious ambiguity with the
; unary-vstem-vend-rule.

verb-stem-lex-base  := v-lex & 
              [SYNSEM [LOCAL [CAT.HEAD verb-stem_head,
                              BAR bool]],
               J-NEEDS-AFFIX +,
               INFLECTED -].

verb-stem-lex-super := verb-stem-lex-base.

verb-stem-lex := verb-stem-lex-super &
              [SYNSEM [LKEYS.KEYREL [ ARG0 #ind,
				      LBL #top,
				      PRED #pred],
		       LOCAL [CAT.HEAD.KEYS.KEY #pred,
			      CONT simple-verb-sem-type &
				      [HOOK [INDEX #ind,
					     LTOP #top]]]]].

v-stem-lex := verb-stem-lex & lexical_sign-word &
[SYNSEM [LKEYS.KEYREL #key,
	 LOCAL [CAT.HEAD v-stem_head,
		CONT [RELS.LIST.FIRST #key]]]].

v-nonop-stem-lex := v-stem-lex &
                    [SYNSEM [LOCAL.CONT verb-sem-type &
                                             [HOOK.INDEX event,
                                              RELS <! #key !>,
                                              HCONS <! !>],
			     LKEYS.KEYREL #key]].

v-sbj-comps-stem-lex := v-nonop-stem-lex &
		   [SYNSEM.LOCAL [CAT.VAL [SUBJ.FIRST #sbj,
					   COMPS #comps],
				  ARG-S < #sbj . #comps >]].




intrans-stem-lex := v-nonop-stem-lex &
 [SYNSEM [LKEYS.KEYREL [ARG1 #sbjind],
	  LOCAL [CAT [HEAD [COP -],
		      VAL intransitive &
			   [SUBJ #sbj & 
				 [FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]]],
		 CONT  [HOOK.XARG #sbjind],
		 ARG-S #sbj ]]].

intrans-nohon-stem-lex := intrans-stem-lex & 
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

intrans-shon-stem-lex  := intrans-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]],
                             NON-LOCAL.QUE <! !>]].

intrans-minusshon-stem-lex  := intrans-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                     [HONORED #2,
                                                      BEARER #3,
                                                      POLARITY -] !>]],
                             NON-LOCAL.QUE <! !>]].

; <type val="intrans-c2-stem-lex">
; <name-ja>五段普通自動詞
; <description>intrans-c-stem-lexを参照。このtypeは五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>手続き に 行く
; <nex>手続き を 行く
; <todo>
; </type>
intrans-c2-stem-lex := intrans-nohon-stem-lex & [STEMTYPE c2-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-c2-stem-minusbar-lex := intrans-c2-stem-lex &
		       [SYNSEM.LOCAL.BAR -].

; <type val="intrans-c-stem-lex">
; <name-ja>五段普通自動詞
; <description>日本で一般的に自動詞と呼ばれるもの。五段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。格は主格のみ取れる。
; <ex>雨 が 降る
; <nex>雨 を 降る
; <todo>
; </type>
intrans-c-stem-lex := intrans-nohon-stem-lex & [STEMTYPE c-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-c-stem-nomorph-lex := intrans-c-stem-lex &
			       [RMORPH-BIND-TYPE nomorphbind].



; <type val="intrans-c-stem-wh-lex">
; <name-ja>自動詞疑問五段
; <description>内容や状態を尋ねる「どう」に変化を表す動詞「なる」がついたもの。あるもの・ことが
; どのような内容や状態に変化するかを表す。「どう」が「なる」の目的語になっていると考えるべきか。
; 主格（「が」格）のみをargumentに取り、五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>結果 が どう なる か
; <nex>この 木 に 実 が どう なる か を 調べる
; <todo>
; </type>
intrans-c-stem-wh-lex  := intrans-nohon-stem-lex & [STEMTYPE c-stem,
                                                    SYNSEM [LOCAL.CONT.HOOK.LTOP #top,
                                                            NON-LOCAL.QUE <! #top !>]].
; <type val="intrans-v-stem-lex">
; <name-ja>一段普通自動詞
; <description>intrans-c-stem-lexを参照。こちらは一段活用(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>人 が 老いる
; <nex>人 を 老いる
; <todo>
; </type>
intrans-v-stem-lex := intrans-nohon-stem-lex & [STEMTYPE v-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].
intrans-v-stem-nomorph-lex := intrans-v-stem-lex &
			       [RMORPH-BIND-TYPE nomorphbind].

intrans-v-stem-bar-lex := intrans-v-stem-lex &
			  [SYNSEM.LOCAL.BAR +].

intrans-v-stem-nomorph-bar-lex := intrans-v-stem-nomorph-lex & intrans-v-stem-bar-lex.

intrans-kurusuru-stem-lex := intrans-nohon-stem-lex & [STEMTYPE kurusuru-stem,
                                                SYNSEM.NON-LOCAL.QUE <! !>].

intrans-shon-c2-stem-lex := intrans-shon-stem-lex & [STEMTYPE c2-stem].
intrans-shon-c-stem-lex := intrans-shon-stem-lex & [STEMTYPE c-stem].
intrans-shon-v-stem-lex := intrans-shon-stem-lex & [STEMTYPE v-stem].
intrans-shon-kurusuru-stem-lex := intrans-shon-stem-lex & [STEMTYPE kurusuru-stem].

intrans-minusshon-c2-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE c2-stem].
intrans-minusshon-c-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE c-stem].
intrans-minusshon-v-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE v-stem].
intrans-minusshon-kurusuru-stem-lex := intrans-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-10-18) I need these verbs to have a special KEY type
; so that the k2y machinery can recognize them.  Currently, they
; are getting arg3_rel-super by type inference, and this isn't specific
; enough.
;
; (MS 2003-07-10) Due to adapations to the matrix, ARG2 is changed to ARG1.

;intransarg3-stem-lex := v-nonop-stem-lex &
;                    [SYNSEM.LOCAL [CAT [HEAD [COP -],
;                                        SUBCAT intransitive &
;                                             [VAL.SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
;                                        KEYS  [KEY [ARG2 #sbjind]]]].

;intransarg2-stem-lex := v-nonop-stem-lex &
;                    [SYNSEM [LOCAL [CAT [HEAD [COP -],
;                                        VAL intransitive &
;                                             [SUBJ.FIRST #sbj & [LOCAL.CONT [HOOK.INDEX #sbjind]]]],
;                                        CONT  [HOOK.XARG #sbjind],
;				    ARG-S < #sbj > ],
;			      LKEYS.KEYREL arg1-relation &
;                                                   [ARG1 #sbjind],
;                             NON-LOCAL.QUE <! !>]].
;
;intransarg2-nohon-stem-lex := intransarg2-stem-lex & 
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;intransarg2-shon-stem-lex  := intransarg2-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY +] !>]]].
;
;intransarg2-minusshon-stem-lex  := intransarg2-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
;                                                     [HONORED #2,
;                                                      BEARER #3,
;                                                      POLARITY -] !>]]].
;
;intransarg2-c2-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-c-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE c-stem].
;intransarg2-v-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE v-stem].
;intransarg2-kurusuru-stem-lex := intransarg2-nohon-stem-lex & [STEMTYPE kurusuru-stem].
;
;intransarg2-shon-c2-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-shon-c-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE c-stem].
;intransarg2-shon-v-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE v-stem].
;intransarg2-shon-kurusuru-stem-lex := intransarg2-shon-stem-lex & [STEMTYPE kurusuru-stem].
;
;intransarg2-minusshon-c2-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE c2-stem].
;intransarg2-minusshon-c-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE c-stem].
;intransarg2-minusshon-v-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE v-stem].
;intransarg2-minusshon-kurusuru-stem-lex := intransarg2-minusshon-stem-lex & [STEMTYPE kurusuru-stem].
;

v1-stem-lex := v-sbj-comps-stem-lex &
                  [SYNSEM [LKEYS.KEYREL [ARG1 #sbjind,
					    ARG2 #objind],
			   LOCAL [CAT [HEAD [COP -,
                                            MODUS mood],
                                      VAL ga-wo_transitive &
                                             [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
					      COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
                                 CONT [HOOK.XARG #sbjind]]]].

v1-nohon-stem-lex := v1-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v1-shon-stem-lex  := v1-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
						       POLARITY +] !>]],                              
			      NON-LOCAL.QUE <! !>]].

v1-minusshon-stem-lex  := v1-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                     [HONORED #2,
                                                      BEARER #3,
                                                      POLARITY -] !>]],
                              NON-LOCAL.QUE <! !>]].

; <type val="v1-c2-stem-lex">
; <name-ja>ヲ他動詞五段変則
; <description>v1-c-stem-lexを参照。このtypeは五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>弟子 に 問う た
; <ex>弟子 に 問い ます
; <nex>
; <todo>
; </type>
v1-c2-stem-lex := v1-nohon-stem-lex & [STEMTYPE c2-stem,
                                       SYNSEM.NON-LOCAL.QUE <! !>].
; <type val="v1-c-stem-lex">
; <name-ja>ヲ他動詞五段
; <description>主格（「が」格）と目的格（「を」格）を取る和語動詞。日本語で一般的に他動詞と呼ばれるもの。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>試験 を 行う
; <nex>
; <todo>
; </type>
v1-c-stem-lex := v1-nohon-stem-lex & [STEMTYPE c-stem,
                                      SYNSEM.NON-LOCAL.QUE <! !>].
v1-c-stem-nomorph-lex := v1-c-stem-lex &
			  [RMORPH-BIND-TYPE nomorphbind].

; <type val="v1-v-stem-lex">
; <name-ja>ヲ他動詞一段
; <description>主格（「が」格）と目的格（「を」格）を取る和語動詞。日本語で一般的に他動詞と呼ばれるもの。
; 一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>ゴミ を 捨てる
; <nex>
; <todo>
; </type>
v1-v-stem-lex := v1-nohon-stem-lex & [STEMTYPE v-stem,
                                      SYNSEM.NON-LOCAL.QUE <! !>].

v1-v-stem-nomorph-lex := v1-v-stem-lex &
			  [RMORPH-BIND-TYPE nomorphbind].

v1-v-stem-bar-lex := v1-v-stem-lex &
		     [SYNSEM.LOCAL.BAR +].

v1-v-stem-nomorph-bar-lex := v1-v-stem-nomorph-lex & v1-v-stem-bar-lex.

; (MS 2002-05-19) ageru sets the empathy to its agent.

v1-v-stem-arg1emp-lex := v1-v-stem-lex &
			 [SYNSEM [LKEYS.KEYREL.ARG1 #arg1,
				  LOCAL.CTXT.EMPATHY.EMPEE #arg1]].

; <type val="v1-kurusuru-stem-lex">
; <name-ja>ヲ他動詞変格
; <description>主格（「が」格）と目的格（「を」格）を取る和語動詞。日本語で一般的に他動詞と呼ばれるもの。サ行変格
; 活用をし、終止形の末尾は「する」または「ずる」(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; またこのtypeは、単独で疑問文も作れる。
; <ex>客 が キノコ を 食する
; <nex>
; <todo>(TK 07-03-20)v1-kurusuru-stem-lexとv1-kurusuru-nonquest-stem-lexはどちらか一方でよいのではないか。
; </type>
v1-kurusuru-stem-lex := v1-nohon-stem-lex & [STEMTYPE kurusuru-stem].

; <type val="v1-kurusuru-nonquest-stem-lex">
; <name-ja>ヲ他動詞変格非疑問
; <description>v1-kurusuru-stem-lexを参照。ただしこのtypeは、単独では疑問文を作れない。
; <ex>金持ち が 権力 を 愛する
; <nex>
; <todo>(TK 07-03-20)v1-kurusuru-stem-lexを参照。
; </type>
v1-kurusuru-nonquest-stem-lex := v1-kurusuru-stem-lex &
				 [SYNSEM.NON-LOCAL.QUE <! !>].

; <type val="v1-kurusuru-quest-stem-lex">
; <name-ja>ヲ他動詞変格疑問
; <description>v1-kurusuru-stem-lexを参照。ただしこのtypeは、疑問文のみに用いる。
; 手段や様態の疑問を表す「どう」と変化などを表す「する」の連語か。
; サ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>代金 を どう する
; <nex>
; <todo>(TK 07-03-20)疑問文以外も作れるようにすべき。(lkb::do-parse-tty "どう する か 決める")
; </type>

v1-kurusuru-quest-stem-lex := v1-kurusuru-stem-lex &
				 [SYNSEM [NON-LOCAL.QUE <!#top !>,
					  LOCAL.CONT.HOOK.LTOP #top]].

v1-kurusuru-overtargs-stem-lex := v1-kurusuru-stem-lex &
				  [SYNSEM.LOCAL.CAT.VAL [SUBJ.FIRST.LOCAL.CAT.HEAD.PTYPE overt,
							 COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE overt]].

v1-kurusuru-nonquest-overtargs-stem-lex := v1-kurusuru-overtargs-stem-lex & v1-kurusuru-nonquest-stem-lex.

; <type val="v1-c2-shon-stem-lex">
; <name-ja>ヲ他動詞五段変則尊敬
; <description>v1-c2-stem-lexを参照。このtypeは主語への敬意を表す場合に使う。
; <ex>先生 が 食事 を なさっ た
; <ex>先生 が 食事 を なさい ます
; <nex>犬 が 食事 を なさる
; <todo>
; </type>
v1-c2-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE c2-stem].
v1-c-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE c-stem].
; <type val="v1-v-shon-stem-lex">
; <name-ja>ヲ他動詞五段尊敬
; <description>v1-v-stem-lexを参照。このtypeは主語への尊敬を表す。現状では「くれる」のみがこのtypeで
; 登録されているが、 本来「くれる」に尊敬の意味は特にないように思われる。
; <ex>祖父 が おもちゃ を くれる
; <nex>
; <todo>(TK 07-03-20)「息子 が 花 を くれる」の場合、特に敬意などは関係がないと思われる。
; </type>
v1-v-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE v-stem].
v1-kurusuru-shon-stem-lex := v1-shon-stem-lex & [STEMTYPE kurusuru-stem].


v1-c2-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE c2-stem].
; <type val="v1-c-minusshon-stem-lex">
; <name-ja>ヲ他動詞五段非尊敬
; <description>v1-c-stem-lexを参照。このtypeは主語への尊敬を表す場合には使えない。
; <ex>私 が 先生 から 本 を 頂く
; <nex>先生 が 私 から 本 を 頂く
; <todo>
; </type>
v1-c-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE c-stem].
; <type val="v1-v-minusshon-stem-lex">
; <name-ja>ヲ他動詞一段非尊敬
; <description>v1-v-stem-lexを参照。このtypeは主語への尊敬を表す場合には使えない。
; <ex>私 が プレゼント を 差し上げる
; <nex>国王 が 勲章 を 差し上げる
; <todo>
; </type>
v1-v-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE v-stem].
v1-kurusuru-minusshon-stem-lex := v1-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2004-07-06) v1a with obligatory wo-comp is not used any more.

v2-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-ni_transitive &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                              CONT [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                        NON-LOCAL.QUE <! !>]].

v2-nohon-stem-lex := v2-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2-shon-stem-lex  := v2-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
							       CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2-minusshon-stem-lex  := v2-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


v2-c2-stem-lex := v2-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v2-c-stem-lex">
; <name-ja>ニ他動詞五段
; <description>主格（「が」格）と目的格（「に」格）を取る和語動詞。日本語ではこれも一般的に自動詞と呼ばれている。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>人 が 車 に 乗る
; <nex>
; <todo>
; </type>
v2-c-stem-lex := v2-nohon-stem-lex & [STEMTYPE c-stem].
; <type val="v2-v-stem-lex">
; <name-ja>ニ他動詞一段
; <description>v2-c-stem-lexを参照。このtypeは一段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>息子 が 商社 に 勤める
; <nex>
; <todo>
; </type>
v2-v-stem-lex := v2-nohon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-stem-lex := v2-nohon-stem-lex & [STEMTYPE infinitive-stem].

; (SF 2003-08-28) 
; <type val="v2-kurusuru-stem-lex">
; <name-ja>ニ他動詞変格
; <description>v2-c-stem-lexを参照。このtypeはサ行変格活用をし、終止形が「する」「ずる」であるもの
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>行動 が 道徳 に 反する
; <nex>
; <todo>
; </type>
v2-kurusuru-stem-lex := v2-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v2-c2-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE c2-stem].
v2-c-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE c-stem].
v2-v-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-shon-stem-lex := v2-shon-stem-lex & [STEMTYPE infinitive-stem].


v2-c2-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE c2-stem].
v2-c-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE c-stem].
v2-v-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE v-stem].
v2-infinitive-minusshon-stem-lex := v2-minusshon-stem-lex & [STEMTYPE infinitive-stem].

; (ERB 2002-02-14) This had the subject's index linked to ARG2, not
; ARG1.  Changing it to ARG1.  Nothing was explicitly saying arg123-relation,
; so now it's just arg12-relation.

; (MS 2004-12-20) Just identify the COMPS...LTOP with the KEYREL...LBL, not go via COMPS..MOD..LTOP.
; 元気になる
; (FCB and CH 2005-03-12) super type for subject-complement verbs v2a and v2b
; (and Dan and all) added a proposition, cleaned up the MRS
v-sc-stem-lex := v-stem-lex &
 [SYNSEM [LOCAL [CAT [HEAD.COP -,
		      VAL.SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		 CONT [HOOK [XARG #sbjind,
			     INDEX event],
		       RELS.LIST < #key, ... >,
		       HCONS  <! qeq & [HARG #phand] !> ]],
	  LKEYS.KEYREL arg1-relation & #key &
		[ARG1 #phand],
	  NON-LOCAL.QUE <! !>]].

; (MS 2005-05-24) Try to make the complement obligatory, to avoid ambiguity.
; as in 病気になる
; (MS 2005-10-20) But this way, V-ばならない doesn't work any more!

v-sc-n-stem-lex := v-sc-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL ga-to-ni_transitive2 &
			  [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			   COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #compind]],
		 CONT [RELS <! relation, 
			     [PRED "cop_id_rel",
			      ARG0 event,
			      ARG1 #sbjind,
			      ARG2 #compind,
			      LBL #chand & handle] !>,
		       HCONS  <! [LARG #chand] !> ]]]].

;;; FIXME why isn't the subject coindexed for 犬 が 美しく 吠える?
;;; FIXME should block real adverbs (make ARG1 x)?
v-sc-a-stem-lex := v-sc-stem-lex &
 [SYNSEM.LOCAL [CAT [VAL naru_adv_transitive &
			 [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			  COMPS.FIRST.LOCAL [ CONT.HOOK [LTOP #chand, 
							  XARG #sbjind]]]],
		CONT [RELS <! relation !>,
		      HCONS  <! [LARG #chand] !> ]]].


v2a-nohon-stem-lex := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2a-shon-stem-lex  := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2a-minusshon-stem-lex  := v-sc-a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


v2a-c2-stem-lex := v2a-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v2a-c-stem-lex">
; <name-ja>ニト必須他動詞五段
; <description>主格（「が」格）と目的格（「に」格or「と」格）を取る和語動詞。これも日本語では一般的に自動詞と呼ばれる。
; このtypeは目的格が必須で、それがないと文を解析できない。目的格は「na-adj-lex+に(naadj2adv-end-lex)orと(comp-prpstn-lex-quot)」
; の形か、i-adj-stem-lexをRULEによって副詞化したもの。
; MRSの上ではadjectiveのARG1に主格（「が」格）が入り、v2a-c-stem-lexのARG1にそのはadjectiveが入る形になる。
; つまり、「食事 が 豪華 に なる」の場合、「『食事が豪華だ』という状態になる」という解析になる。
; 現状ではadverbも目的語に取れてしまうので「どう なる」も解析可能になっている。五段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>食事 が 豪華 に なる
; <ex>食事 が 豪華 と なる
; <nex>静か に 鐘 が なる
; <todo>(TK 07-03-20)「どう なる」の場合以外、adverbを目的語にすべきでないと思われる。
; (TK 07-04-06)助詞の「と」がcomp-prpstn-lex-quotにしかならないのはそれで良いのか。
; (TK 07-04-16)副詞化したi-adj-stem-lexが目的語の場合、MRSの上でそのi-adj-stem-lexがargumentを取ることができず、
; frgamentedになってしまう。(lkb::do-parse-tty "鼻 が 低く なる")
; (TK 07-05-24)主格が「の」であると解析できない(lkb::do-parse-tty "味 の 淡泊 に なる 原因")(lkb::do-parse-tty "雨 の 多く なる 時期")。
; v2b-c-stem-lexも同様。
; </type>
v2a-c-stem-lex := v2a-nohon-stem-lex & [STEMTYPE c-stem].
v2a-v-stem-lex := v2a-nohon-stem-lex & [STEMTYPE v-stem].

v2a-c2-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE c2-stem].
v2a-c-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE c-stem].
v2a-v-shon-stem-lex := v2a-shon-stem-lex & [STEMTYPE v-stem].

v2a-c2-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE c2-stem].
v2a-c-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE c-stem].
v2a-v-minusshon-stem-lex := v2a-minusshon-stem-lex & [STEMTYPE v-stem].

; (MS 2004-03-22) added to parse 男になる with a copula semantics embedded.

v2b-nohon-stem-lex := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v2b-shon-stem-lex  := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v2b-minusshon-stem-lex  := v-sc-n-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

; (FCB and CH 2005-03-12) This can only be 成る (c-stem)

; <type val="v2b-c-stem-lex">
; <name-ja>ニト必須他動詞五段
; <description>v2a-c-stem-lexを参照。このtypeの目的格は「名詞+に(case-p-lex-np-ni)orと(おそらくcase-p-lex-np-to)」。
; <ex>犬 が 猫 に なる
; <ex>犬 が 猫 と なる
; <nex>木 に 実 が なる
; <todo>(TK 07-05-24)主格が「の」であると解析できない(lkb::do-parse-tty "犬 の 猫 に なる 日")。
; v2a-c-stem-lexも同様。
; </type>
v2b-c-stem-lex := v2b-nohon-stem-lex & [STEMTYPE c-stem].

v2b-c-shon-stem-lex := v2b-shon-stem-lex & [STEMTYPE c-stem].


; (FCB and CH 2005-03-12) for complement suru 
; (do-parse-tty "彼 が 鉛 を 銀 に し た") "he made lead into silver"
; (FCB 2005-03-22) added in proposition (like v-sc-stem-lex)
; FIXME: could still reify a bit with v-sc-stem-lex
; FIXME: should maybe not be PRED 'cop_id_rel, but something similar
; (FCB 2005-06-15) Added ARG0 to messages

v-soc-stem-lex := v-stem-lex &
 [SYNSEM [LOCAL [CAT [HEAD.COP -,
		      VAL.SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind],
		 CONT [HOOK [XARG #sbjind,
			     INDEX event ],
		       RELS.LIST <  #key, ...  >,
		       HCONS  <! qeq & [HARG #phand] !> ]],
	  LKEYS.KEYREL arg12-relation & #key &
		[ARG1 #sbjind,
		 ARG2 #phand],
	  NON-LOCAL.QUE <! !>]].

v-soc-adv-stem-lex := v-soc-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL suru_adv_ditransitive &
			[COMPS < [LOCAL.CONT.HOOK.INDEX #objind],
				 [LOCAL.CONT.HOOK [XARG  #objind,
						   LTOP  #chand]] >] ,
		CONT [RELS <! relation !>,
		      HCONS  <! [LARG #chand] !> ]]].

v-soc-noun-stem-lex := v-soc-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL suru_noun_ditransitive &
			[COMPS < [LOCAL.CONT.HOOK.INDEX #objind],
				 [LOCAL.CONT.HOOK.INDEX #compind] >],
		CONT [RELS <! relation,
			    [PRED "cop_id_rel",
			     ARG0 event,
			     ARG1 #objind,
			     ARG2 #compind,
			     LBL #chand] !>,
		      HCONS  <! [LARG #chand] !>]]].

;; plus honorification SCO-noun
v-soc-noun-nohon-stem-lex := v-soc-noun-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v-soc-noun-shon-stem-lex  := v-soc-noun-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].
;; plus honorification SCO-adv
v-soc-adv-nohon-stem-lex := v-soc-adv-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v-soc-adv-shon-stem-lex  := v-soc-adv-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].
; (FCB and CH 2005-03-12) This can be する なさる (c-stem)

;する
; <type val="v-soc-noun-kurusuru-stem-lex">
; <name-ja>ニト必須二重目的他動詞変格
; <description>主格（「が」格）と２つの目的格（「を」格と「に」or「と」格）を取る和語動詞。
; v4-stem-lexも同じように主格と２つの目的格を取るが、このtypeは「に」or「と」格のない文には現れ
; ない。また、２つの目的語の間に何らかの関係があり、それらをcopulaで結ぶというMRS構造を作っている。
; 例えば、「犬 を 猫 に する」という文の場合、「犬」がcopulaのARG1、「猫」がARG2に入り、
; そのcopulaが「する」のARG2に入る形になっている。
; サ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>魔女 が 犬 を 猫 に する
; <nex>母 が 掃除 を ２ 時 に する
; <todo>
; </type>
v-soc-noun-kurusuru-stem-lex := v-soc-noun-nohon-stem-lex & [STEMTYPE kurusuru-stem].
; <type val="v-soc-adv-kurusuru-stem-lex">
; <name-ja>ニト必須二重目的他動詞変格
; <description>主格（「が」格）と２つの目的格（「を」格と「に」or「と」格）を取る和語動詞。
; このtypeは間接目的格としてi-adj-stem-lexをADJ2ADVルールで副詞化したものや「na-adj-lex+
; に(naadj2adv-end-lex)orと(comp-prpstn-lex-quot)」を取る。
; また、２つの目的語の間に何らかの関係があり、それらをcopulaで結ぶというMRS構造を作っている。
; 例えば、「部屋 を きれい に する」という文の場合、「部屋」がcopulaのARG1、「きれい」がARG2に入り、
; そのcopulaが「する」のARG2に入る形になっている。
; サ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>子供 が 部屋 を きれい に する
; <ex>学者 が 考え を 確か と する
; <ex>カルシウム が 骨 を 太く する
; <nex>兄 が チェス を 良く する
; <todo>(TK 07-04-16)ルールなどによって副詞化されたものだけでなく、純粋なadverbまでargumentに取って
; しまうのは、正しくないと思われる。v2a-c-stem-lexも参照。
; (TK 07-04-16)「na-adj-lex+と」の形の「と」がcomp-prpstn-lex-quotにしかならないのはそれで良いのか。
; v2a-c-stem-lexも参照。
; (TK 07-04-16)また、i-adj-stem-lexを副詞化したものを格として取ろうとした場合、MRSがfragmentedになってしまう。
; v2a-c-stem-lexも参照。
; </type>
v-soc-adv-kurusuru-stem-lex := v-soc-adv-nohon-stem-lex & [STEMTYPE kurusuru-stem].

;なさる
; <type val="v-soc-noun-c2-shon-stem-lex">
; <name-ja>ニト必須二重目的他動詞変格尊敬
; <description>v-soc-noun-kurusuru-stem-lexを参照。ただしこのtypeは主格への敬意を表す場合に使う。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>先生 が 木 を 筆 に なさる
; <nex>先生 が 掃除 を ２ 時 に なさる
; <todo>
; </type>
v-soc-noun-c2-shon-stem-lex := v-soc-noun-shon-stem-lex & [STEMTYPE c2-stem].
; <type val="v-soc-adv-c2-shon-stem-lex">
; <name-ja>ニト必須二重目的他動詞変格尊敬
; <description>v-soc-adv-kurusuru-stem-lexを参照。ただしこのtypeは主格への敬意を表す場合に使う。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>先生 が 部屋 を きれい に なさる
; <nex>先生 が チェス を 良く なさる
; <todo>(TK 07-04-16)v-soc-adv-kurusuru-stem-lexを参照。
; </type>
v-soc-adv-c2-shon-stem-lex := v-soc-adv-shon-stem-lex & [STEMTYPE c2-stem].
            

v5-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-to_transitive2 &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.LTOP #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                           CONT verb-sem-type &
                                         [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                        NON-LOCAL.QUE <! !>]].


v5-nohon-stem-lex := v5-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v5-shon-stem-lex  := v5-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v5-minusshon-stem-lex  := v5-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v5-c2-stem-lex := v5-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v5-c-stem-lex">
; <name-ja>ト他動詞五段
; <description>主格（「が」格）と目的格（「と」格）を取る和語動詞。日本語ではこれも一般的に自動詞
; と呼ばれている。五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>雨 が 降る と 見込ん で 傘 を 持つ
; <nex>
; <todo>(TK 07-04-05)同時に「を」格も取る場合を解析できるようにすべき。
; (lkb::do-parse-tty "彼 を 男 と 見込む")
; </type>
v5-c-stem-lex := v5-nohon-stem-lex & [STEMTYPE c-stem].
; <type val="v5-v-stem-lex">
; <name-ja>ト他動詞一段
; <description>v5-c-stem-lexを参照。このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>彼 は 余談 だ が と 付け加え た
; <nex>
; <todo>(TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "「これ は ペン です 」 と 訳 を 付け加え た")
; </type>
v5-v-stem-lex := v5-nohon-stem-lex & [STEMTYPE v-stem].

; <type val="v5-c2-shon-stem-lex">
; <name-ja>ト他動詞五段変則尊敬
; <description>v5-c-stem-lexを参照。このtypeは主語への敬意を表す場合に使う。五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>先生 が 良い と おっしゃる
; <nex>
; <todo>(TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "苗字 を 川崎 さん と おっしゃる 紳士")
; </type>
v5-c2-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE c2-stem].
v5-c-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE c-stem].
v5-v-shon-stem-lex := v5-shon-stem-lex & [STEMTYPE v-stem].


v5-c2-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE c2-stem].
; <type val="v5-c-minusshon-stem-lex">
; <name-ja>ト他動詞五段非尊敬
; <description>v5-c-stem-lexを参照。ただしこのtypeは主語への敬意を表す場合には使えない。
; <ex>私 は 栗林 と 申し ます
; <nex>王 が 大臣 に 不服 だ と 申す
; <todo>(TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "名 を 寅次郎 と 申し ます")
; (TK 07-07-04)We don't have any entries now.
; </type>
v5-c-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE c-stem].
v5-v-minusshon-stem-lex := v5-minusshon-stem-lex & [STEMTYPE v-stem].

; (ERB 2001-11-14) QUE values inside of embedded questions
; should be able to be bound off at the embedded clause.  For
; now I'm assuming that they are necessarily bound off.  Short
; run solution is a non-branching rule that binds it off. To
; force the rule to apply, these verbs must select for QUE <! !>
; empty complements.
; (MS 2005-12-08) As QUE is rather a storage (which isn't emptied), this does not work out.
; see: "誰が行っているか教えて下さい。"


v5-kurusuru-stem-lex := v5-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v5a-stem-lex := v-sbj-comps-stem-lex  &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-to_transitive1 &
                                      [COMPS.FIRST [ LOCAL.CONT [HOOK.LTOP #objind]],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			       CONT verb-sem-type &
				   [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
				      ARG2 #objind],
			NON-LOCAL.QUE <! !> ]].


v5a-nohon-stem-lex := v5a-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v5a-shon-stem-lex  := v5a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v5a-minusshon-stem-lex  := v5a-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v5a-c2-stem-lex := v5a-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v5a-c-stem-lex">
; <name-ja>ト必須他動詞五段
; <description>主格（「が」格）と目的格（「と」格）を取る和語動詞。日本語ではこれも一般的に自動詞
; と呼ばれている。このtypeは目的格が必須で、それがないと文を解析できない。
; 目的格として文を取るが、名詞も取れてしまう。その際「花子 が 犬 と 聞く」と「花子 が 犬 と 言う」
; (v3-c-stem-lex)が同じ解析になってしまっている。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>花子 が 良い と 聞く
; <nex>
; <todo>(TK 07-04-05)v3-stem-lexとv5a-stem-lexの違いがはっきりしていない。
; (TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "ポスト の 色 を 赤 と 知る")
; </type>
v5a-c-stem-lex := v5a-nohon-stem-lex & [STEMTYPE c-stem].
; <type val="v5a-v-stem-lex">
; <name-ja>ト必須他動詞一段
; <description>v5a-c-stem-lexを参照。このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>あれ が 犬 だ と 教える
; <nex>
; <todo>(TK 07-04-05)v5a-c-stem-lexを参照。
; (TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "ポスト の 色 を 赤 と 教える")
; </type>
v5a-v-stem-lex := v5a-nohon-stem-lex & [STEMTYPE v-stem].
; <type val="v5a-kurusuru-stem-lex">
; <name-ja>ト必須他動詞変格
; <description>v5a-c-stem-lexを参照。このtypeはサ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>彼 が 犯人 だ と し て 捜査 する
; <nex>彼 を 犯人 だ と し て 捜査 する
; <todo>(TK 07-04-05)v5a-c-stem-lexを参照。
; </type>
v5a-kurusuru-stem-lex := v5a-nohon-stem-lex & 
			 [STEMTYPE kurusuru-stem,
			  SYNSEM [LOCAL.CAT.VAL [SUBJ.FIRST.LOCAL.CAT.HEAD.PTYPE overt,
						 COMPS.FIRST.LOCAL.CAT.HEAD.PTYPE overt],
				  NON-LOCAL.QUE <! !>]].

v5a-c2-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE c2-stem].
v5a-c-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE c-stem].
v5a-v-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE v-stem].
v5a-kurusuru-shon-stem-lex := v5a-shon-stem-lex & [STEMTYPE kurusuru-stem].


v5a-c2-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE c2-stem].
v5a-c-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE c-stem].
v5a-v-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE v-stem].
v5a-kurusuru-minusshon-stem-lex := v5a-minusshon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2004-06-01) V7 seems not to be in use any more.
; (MS 2005-10-26) We need that for daisuru (題する - entitle).

v7-stem-lex  := v-sbj-comps-stem-lex &
               [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                   VAL ga-wo-toni-ditransitive &
                                      [COMPS < [LOCAL.CONT [HOOK.INDEX #objind]],
					       [LOCAL.CONT [HOOK.INDEX #obj2ind]] >,
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
                           CONT verb-sem-type &
                                         [HOOK.XARG #sbjind]],
			LKEYS.KEYREL [ARG1 #sbjind,
                                               ARG2 #objind,
                                               ARG3 #obj2ind],
                        NON-LOCAL.QUE <! !>]].

v7-nohon-stem-lex := v7-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v7-shon-stem-lex  := v7-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v7-minusshon-stem-lex  := v7-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2 ]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

v7-c2-stem-lex := v7-nohon-stem-lex & [STEMTYPE c2-stem].
v7-c-stem-lex := v7-nohon-stem-lex & [STEMTYPE c-stem].
v7-v-stem-lex := v7-nohon-stem-lex & [STEMTYPE v-stem].
; <type val="v7-kurusuru-stem-lex">
; <name-ja>ヲニト二重目的他動詞変格
; <description>主格（「が」格）と２つの目的格（「を」格と「に」or「と」格）を取る和語動詞。Jacy Valenceのga-wo-toni-ditransitive
; を参照(http://wiki.delph-in.net/moin/JacyValence)。このtypeはサ行変格活用をし、終止形の末尾は「する」または「ずる」
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。日本語では一般的に他動詞と呼ばれる。
; <ex>作者 が 新作 を 大雪 と 題する
; <ex>作者 が 新作 を 大雪 に 題する
; <ex>新作 が 大雪 に 題する
; <nex>新作 が 大雪 を 題する
; <todo>
; </type>
v7-kurusuru-stem-lex := v7-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v7-c2-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE c2-stem].
v7-c-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE c-stem].
v7-v-shon-stem-lex := v7-shon-stem-lex & [STEMTYPE v-stem].

v7-c2-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE c2-stem].
v7-c-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE c-stem].
v7-v-minusshon-stem-lex := v7-minusshon-stem-lex & [STEMTYPE v-stem].

;(MS 2004-06-01) I don't think we need this any more.

;aru-stem-lex := intrans-stem-lex &
;               [SYNSEM.NON-LOCAL.QUE <! !>].
;
;
;aru-nohon-stem-lex := aru-stem-lex &
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;
;aru-c2-stem-lex := aru-nohon-stem-lex & [STEMTYPE c2-stem].
;aru-c-stem-lex := aru-nohon-stem-lex & [STEMTYPE c-stem].
;aru-v-stem-lex := aru-nohon-stem-lex & [STEMTYPE v-stem].

;aru-c2-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE c2-stem].
;aru-c-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE c-stem].
;aru-v-shon-stem-lex := aru-shon-stem-lex & [STEMTYPE v-stem].

;aru-c2-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE c2-stem].
;aru-c-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE c-stem].
;aru-v-minusshon-stem-lex := aru-minusshon-stem-lex & [STEMTYPE v-stem].

; (MS 2004-08-24) ARG2 is now linked to LTOP, not the INDEX.


v3-stem-lex := v-sbj-comps-stem-lex &
              [SYNSEM [LOCAL [CAT [HEAD.COP -,
                                  VAL ga-to_transitive1 &
                                      [COMPS.FIRST.LOCAL.CONT [HOOK.LTOP #objind],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			      CONT [HOOK.XARG #sbjind]],
		       LKEYS.KEYREL [ARG1 #sbjind,
					 ARG2 #objind],
                       NON-LOCAL.QUE <! !>]].

v3-nohon-stem-lex := v3-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v3-shon-stem-lex  := v3-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v3-minusshon-stem-lex  := v3-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

; <type val="v3-c-stem-lex">
; <name-ja>ト必須他動詞五段
; <description>主格（「が」格）と目的格（「と」格）を取る和語動詞。日本語ではこれも一般的に自動詞
; と呼ばれている。このtypeは目的格が必須で、それがないと文を解析できない。
; 目的格として文は取れないはずだが、(lkb::do-parse-tty "花子 が 良い と 言う")が解析できてしまい、
; v5a-c-stem-lexの(lkb::do-parse-tty "花子 が 良い と 思う")と同じMRSになってしまっている。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>花子 が 良い と 言う
; <nex>
; <todo>(TK 07-04-05)v3-stem-lexとv5a-stem-lexの違いがはっきりしていない。
; (TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "恐かっ た と 体験 を 語る")
; </type>
v3-c-stem-lex := v3-nohon-stem-lex & [STEMTYPE c-stem].
v3-c2-stem-lex := v3-nohon-stem-lex & [STEMTYPE c2-stem].
v3-v-stem-lex := v3-nohon-stem-lex & [STEMTYPE v-stem].

; (TK 08-01-23)
; <type val="v3-kurusuru-stem-lex">
; <name-ja>ト必須他動詞変格
; <description>v3-c-stem-lexを参照。このtypeはサ行変格活用をし、終止形が「する」「ずる」であるもの
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>違反 で は ない と 解する
; <nex>
; <todo>
; </type>
v3-kurusuru-stem-lex := v3-nohon-stem-lex & [STEMTYPE kurusuru-stem].

v3-c-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE c-stem].
; <type val="v3-c2-shon-stem-lex">
; <name-ja>ト必須他動詞五段変則主格尊敬
; <description>v3-c-stem-lexを参照。このtypeは主格に対する尊敬を表す場合に使い、
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>犬 だ と おっしゃる
; <nex>冗談 を おっしゃる
; <todo>
; </type>
v3-c2-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE c2-stem].
v3-v-shon-stem-lex := v3-shon-stem-lex & [STEMTYPE v-stem].

; <type val="v3-c-minusshon-stem-lex">
; <name-ja>ト必須他動詞五段非尊敬
; <description>v3-v-minusshon-stem-lexを参照。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>買っ て ください と 頼む
; <nex>
; <todo>(TK 07-07-03)v3-c-stem-lexを参照。
; (TK 07-07-04)v5-c-stem-lexを参照。(lkb::do-parse-tty "名 を 寅次郎 と 申し ます") 
; </type>
v3-c-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE c-stem].
v3-c2-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE c2-stem].
; <type val="v3-v-minusshon-stem-lex">
; <name-ja>ト必須他動詞一段非尊敬
; <description>v3-c-stem-lexを参照。このtypeは、主語に対する尊敬を表す場合には使えない。
; 一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>犬 と 存じ ます
; <nex>
; <todo>(TK 07-04-05)v3-c-stem-lexを参照。
; (TK 07-04-05)v5-c-stem-lexを参照。(lkb::do-parse-tty "プラチナ を 高価 だ と 存じ ます")
; </type>
v3-v-minusshon-stem-lex := v3-minusshon-stem-lex & [STEMTYPE v-stem].

v4-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL ditransitive &
                         [COMPS < [LOCAL.CONT [HOOK.INDEX #objind]],
				  [LOCAL.CONT [HOOK.INDEX #obj2ind]] >,
			  SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
	 LKEYS.KEYREL [ARG1 #sbjind,
			   ARG2 #objind,
			   ARG3 #obj2ind],
         NON-LOCAL.QUE <! !>]].

v4-nohon-stem-lex := v4-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v4-shon-stem-lex  := v4-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v4-minusshon-stem-lex  := v4-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

; <type val="v4-c-stem-lex">
; <name-ja>二重目的他動詞五段
; <description>主格（「が」格）と２つの目的格（「を」格と「に」格）を取る和語動詞。Jacy Valenceの表のditransitive
; を参照(http://wiki.delph-in.net/moin/JacyValence)。これも日本語では一般的に他動詞と呼ばれる。
; v-soc-noun-stem-lexも２つの目的格を取るが、このtypeは２つの目的語の間に特に関係がない場合に使われる。
; このtypeは五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>子供 が 本 を 机 に 置く
; <nex>
; <todo>(TK 07-03-22)「を」とこのtypeの間にある「に」が、必ずcaseになってしまうのは改善すべき
; (lkb::do-parse-tty "書類 を ３ 時 に 手渡す")。
; </type>
v4-c-stem-lex := v4-nohon-stem-lex & [STEMTYPE c-stem].
; <type val="v4-c2-stem-lex">
; <name-ja>二重目的他動詞五段変則
; <description>v4-c-stem-lexを参照。このtypeは五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>罪人 が 神 に 許し を 乞う
; <ex>罪人 が 神 に 許し を 乞う た
; <ex>罪人 が 神 に 許し を 乞い ます
; <nex>
; <todo>v4-c-stem-lexを参照。
; </type>
v4-c2-stem-lex := v4-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v4-v-stem-lex">
; <name-ja>二重目的他動詞一段
; <description>v4-c-stem-lexを参照。このtypeは一段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>ライオン が 子供 に ミルク を 与える
; <nex>
; <todo>v4-c-stem-lexを参照。
; </type>
v4-v-stem-lex := v4-nohon-stem-lex & [STEMTYPE v-stem].

v4-c-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE c-stem].
v4-c2-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE c2-stem].
v4-v-shon-stem-lex := v4-shon-stem-lex & [STEMTYPE v-stem].

; <type val="v4-c-minusshon-stem-lex">
; <name-ja>二重目的他動詞五段非尊敬
; <description>v4-c-stem-lexを参照。ただしこのtypeは主語への尊敬を表す場合には使えない。
; <ex>母親 が 息子 に 買物 を 頼む
; <nex>大臣 が 王 に 節約 を 頼む
; <todo>v4-c-stem-lexを参照。
; </type>
v4-c-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE c-stem].
v4-c2-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE c2-stem].
v4-v-minusshon-stem-lex := v4-minusshon-stem-lex & [STEMTYPE v-stem].

; <type val="v4-kurusuru-stem-lex">
; <name-ja>二重目的他動詞変格
; <description>v4-c-stem-lexを参照。このtypeは変格活用をする。
; <ex>
; <nex>
; <todo>v4-c-stem-lexを参照。
; </type>
v4-kurusuru-stem-lex := v4-nohon-stem-lex & [STEMTYPE kurusuru-stem].


v6-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL ga-to-ni_transitive1 &
                         [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
			  SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
	 LKEYS.KEYREL [ARG1 #sbjind,
			   ARG2 #objind],
         NON-LOCAL.QUE <! !>]].


v6-nohon-stem-lex := v6-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v6-shon-stem-lex  := v6-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

v6-minusshon-stem-lex  := v6-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].

; <type val="v6-c-stem-lex">
; <name-ja>ニト他動詞五段
; <description>主格（「が」格）と目的格（「に」格or「と」格）を取る和語動詞。Jacy Valenceの表のga-to-ni_transitive1
; を参照(http://wiki.delph-in.net/moin/JacyValence)。これも日本語では一般的に自動詞と呼ばれている。
; このtypeは五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>兄 が 弟 に 会う
; <ex>兄 が 弟 と 会う
; <nex>
; <todo>(TK 07-04-06)vn-lexにはv6-stem-lexにあたるtypeがない。(lkb::do-parse-tty "敵 に/と 遭遇 する")
; </type>
v6-c-stem-lex := v6-nohon-stem-lex & [STEMTYPE c-stem].
v6-c2-stem-lex := v6-nohon-stem-lex & [STEMTYPE c2-stem].
; <type val="v6-v-stem-lex">
; <name-ja>ニト他動詞一段
; <description>v6-c-stem-lexを参照。このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>顔 が 父親 に 似る
; <ex>顔 が 父親 と 似る
; <nex>
; <todo>(TK 07-04-06)v6-c-stem-lexを参照。(lkb::do-parse-tty "基準 に/と 適合 する")
; </type>
v6-v-stem-lex := v6-nohon-stem-lex & [STEMTYPE v-stem].

; <type val="v6-kurusuru-stem-lex">
; <name-ja>ニト他動詞変格
; <description>v6-c-stem-lexを参照。このtypeは変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>実態 に 即する
; <ex>実態 と 即する
; <nex>
; <todo>
; </type>
v6-kurusuru-stem-lex := v6-nohon-stem-lex & [STEMTYPE kurusuru-stem].



v6-c-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE c-stem].
v6-c2-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE c2-stem].
v6-v-shon-stem-lex := v6-shon-stem-lex & [STEMTYPE v-stem].

v6-c-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE c-stem].
v6-c2-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE c2-stem].
v6-v-minusshon-stem-lex := v6-minusshon-stem-lex & [STEMTYPE v-stem].


;v8: sbj-narg_transitive

v8-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LKEYS.KEYREL [ARG1 #sbjind,
                           ARG2 #objind],
	 LOCAL [CAT [HEAD.COP -,
                     VAL sbj-narg_transitive &
                              [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
			       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
		CONT [HOOK.XARG #sbjind]],
         NON-LOCAL [ROBUST +]]].


v8-nohon-stem-lex := v8-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

v8-shon-stem-lex  := v8-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON +,
                                          VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                 CONT.HOOK.INDEX #2]],
                                     CONT.HOOK.INDEX #3,
                                     CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                                         [HONORED #2,
                                                                          BEARER #3,
                                                                          POLARITY +] !>]],
                              NON-LOCAL.QUE <! !>]].

v8-minusshon-stem-lex  := v8-stem-lex &
                     [SYNSEM [LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]],
                              NON-LOCAL.QUE <! !>]].

; <type val="v8-c-stem-lex">
; <name-ja>特殊ヲ他動詞五段
; <description>v1-stemのように、本来は主格（「が」格）と目的格（「を」格）を取る和語動詞。ただしv8-stemは名詞のみで
; 目的格補語を作る。Jacy Valenceのsbj-narg_transitiveを参照(http://wiki.delph-in.net/moin/JacyValence)。
; speechや特殊な場合以外はあまり使われるべきでない。このtypeは五段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>首相 が 手紙 書き送る
; <nex>首相 が 手紙 を 書き送る
; <todo>(TK 07-03-22)このtypeの直前にあるのがdate-nounなどであっても必ず補語として取られてしまう。
; (lkb::do-parse-tty "首相 が 今日 書き送る")
; </type>
v8-c-stem-lex := v8-nohon-stem-lex & [STEMTYPE c-stem,SYNSEM.NON-LOCAL.QUE <! !>].
; <type val="v8-c2-stem-lex">
; <name-ja>特殊ヲ他動詞五段変則
; <description>v8-c-stem-lexを参照。このtypeは五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>献金 ありがとう ござい ます
; <nex>献金 を ありがとう ござい ます
; <todo>v8-c-stem-lexを参照。
; </type>
v8-c2-stem-lex := v8-nohon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
; <type val="v8-v-stem-lex">
; <name-ja>特殊ヲ他動詞一段
; <description>v8-c-stem-lexを参照。このtypeは一段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>生徒 が 宿題 忘れる
; <nex>生徒 が 宿題 を 忘れる
; <todo>v8-c-stem-lexを参照。
; </type>
v8-v-stem-lex := v8-nohon-stem-lex & [STEMTYPE v-stem,SYNSEM.NON-LOCAL.QUE <! !>].

v8-c-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE c-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-c2-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-v-shon-stem-lex := v8-shon-stem-lex & [STEMTYPE v-stem].

;(MS 2005-11-11) getting rid of skip files.

; <type val="v8-c-minusshon-stem-lex">
; <name-ja>特殊ヲ他動詞五段非尊敬
; <description>v8-c-stem-lexを参照。このtypeは主語への敬意を表す場合には使えない。
; <ex>王 が 幸福 願う
; <nex>王 が 幸福 を 願う
; <todo>v8-c-stem-lexを参照。
; </type>
v8-c-minusshon-stem-lex := v8-minusshon-stem-lex & 
			   [STEMTYPE c-stem,
			    SYNSEM [NON-LOCAL.QUE <! !>,
				    LOCAL.CAT.VAL.COMPS.FIRST.LOCAL.CAT.HEAD.VN -]].

v8-c2-minusshon-stem-lex := v8-minusshon-stem-lex & [STEMTYPE c2-stem,SYNSEM.NON-LOCAL.QUE <! !>].
v8-v-minusshon-stem-lex := v8-minusshon-stem-lex & [STEMTYPE v-stem,SYNSEM.NON-LOCAL.QUE <! !>].

; <type val="v8-c-stem-wh-lex">
; <name-ja>特殊ヲ他動詞五段疑問
; <description>v8-c-stem-lexを参照。v1-kurusuru-quest-stem-lexのように疑問文に用いる。
; <ex>代金 どう なる
; <nex>
; <todo>v8-c-stem-lexを参照。
; (TK 07-05-07)このtypeはいつ使えばよいか（「を」格に当たるものを取り得るのか）。
; </type>
v8-c-stem-wh-lex  := v8-nohon-stem-lex & [STEMTYPE c-stem,
                                          SYNSEM [LOCAL.CONT.HOOK.LTOP #top,
                                                  NON-LOCAL.QUE <! #top !>]].

; (SF 2003) introduces v9-stem-lex
; (MS 2003-11-19) but this seems not to be in use. 

;v9-stem-lex := v-sbj-comps-stem-lex &
;               [SYNSEM [LOCAL [CAT [HEAD.COP -,
;				    VAL ni-ga_transitive &
;                                      [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
;				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
;			       KEYS.KEY [ARG1 #sbjind,
;					 ARG2 #objind],
;                              CONT [HOOK.XARG #sbjind]],
;                        NON-LOCAL.QUE <! !>]].
;
;v9-nohon-stem-lex := v9-stem-lex &
;                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].
;
;v9-shon-stem-lex  := v9-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
;							       CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor-rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY +] !>]]].
;
;v9-minusshon-stem-lex  := v9-stem-lex &
;                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
;                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
;                                                                CONT.HOOK.INDEX #2]],
;                                    CONT.HOOK.INDEX #3,
;                                    CTXT subj-honor-ctxt &  [BACKGROUND <! subj-honor-rel &
;                                                      [HONORED #2,
;                                                       BEARER #3,
;                                                       POLARITY -] !>]]].
;
;
;v9-c2-stem-lex := v9-nohon-stem-lex & [STEMTYPE c2-stem].
;v9-c-stem-lex := v9-nohon-stem-lex & [STEMTYPE c-stem].
;v9-v-stem-lex := v9-nohon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-stem-lex := v9-nohon-stem-lex & [STEMTYPE infinitive-stem].
;
;v9-c2-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE c2-stem].
;v9-c-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE c-stem].
;v9-v-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-shon-stem-lex := v9-shon-stem-lex & [STEMTYPE infinitive-stem].
;
;v9-c2-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE c2-stem].
;v9-c-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE c-stem].
;v9-v-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE v-stem].
;v9-infinitive-minusshon-stem-lex := v9-minusshon-stem-lex & [STEMTYPE infinitive-stem].




; <type val="mental-stem-lex">
; <name-ja>精神動詞
; <description>verbのうち、「が」格と「に」格が主格に、「が」格も「を」格も目的格になれるもの。
; Jacy Valence(http://wiki.delph-in.net/moin/JacyValence)を参照。人間の心の 動きを示すものが多い。
; <ex>
; <nex>
; <todo>
; </type>
mental-stem-lex := v-sbj-comps-stem-lex &
               [SYNSEM [ LKEYS.KEYREL [ARG1 #sbjind,
					  ARG2 #objind],
			 LOCAL [CAT [HEAD.COP -,
                                   VAL mental_state_transitive &
                                        [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
					 SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]]],
			       CONT [HOOK.XARG #sbjind]],
                        NON-LOCAL.QUE <! !>]].

mental-nohon-stem-lex := mental-stem-lex &
                     [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

mental-shon-stem-lex  := mental-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                                                CONT.HOOK.INDEX #2 ]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY +] !>]]].

mental-minusshon-stem-lex  := mental-stem-lex &
                     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                         VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                CONT.HOOK.INDEX #2]],
                                    CONT.HOOK.INDEX #3,
                                    CTXT subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                                      [HONORED #2,
                                                       BEARER #3,
                                                       POLARITY -] !>]]].


; <type val="mental-c-stem-lex">
; <name-ja>精神動詞五段
; <description>mental-stem-lexを参照。五段活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; 「信じる」のようにga-wo_transitiveと思われるようなものもこのtypeになっているのは問題。
; <ex>私 が 地図 が 分かる
; <ex>私 に 地図 が 分かる
; <ex>私 が 地図 を 分かる
; <nex>私 に 地図 を 分かる
; <todo>(TK 07-03-15)「私 に 地図 を 分かる」が「私 が 地図 が 分かる」と同じ解析になってしまうのは良くない。
; </type>
mental-c-stem-lex := mental-nohon-stem-lex & [STEMTYPE c-stem].
mental-c2-stem-lex := mental-nohon-stem-lex  & [STEMTYPE c2-stem].

; <type val="mental-v-stem-lex">
; <name-ja>精神動詞一段
; <description>mental-stem-lexを参照。一段活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>私 が 卓球 が できる
; <ex>私 に 卓球 が できる
; <ex>私 が 卓球 を できる
; <nex>私 に 卓球 を できる
; <todo>(TK 07-03-15)mental-c-stem-lexを参照。
; </type>
mental-v-stem-lex := mental-nohon-stem-lex & [STEMTYPE v-stem].

mental-c-shon-stem-lex := mental-shon-stem-lex & [STEMTYPE c-stem].
mental-c2-shon-stem-lex := mental-shon-stem-lex  & [STEMTYPE c2-stem].
; <type val="mental-v-shon-stem-lex">
; <name-ja>精神動詞一段尊敬
; <description>mental-stem-lexを参照。主格に対する尊敬を表す場合に使う。
; 一段活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>将軍 が 切腹 を 申し付ける
; <nex>将軍 に 切腹 が 申し付ける
; <nex>将軍 に 切腹 を 申し付ける
; <todo>(TK 07-03-15)mental-c-minusshon-stem-lexを参照。
; </type>
mental-v-shon-stem-lex := mental-shon-stem-lex & [STEMTYPE v-stem].

; <type val="mental-c-minusshon-stem-lex">
; <name-ja>精神動詞五段非丁寧
; <description>mental-stem-lexを参照。主格に対する尊敬を表す場合には使えない。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; <ex>私 が 成功 を 願う
; <nex>私 に 成功 が 願う
; <nex>私 に 成功 を 願う
; <todo>(TK 07-03-15)「私 に 成功 が 願う」「私 に 成功 を 願う」は「私 が 成功 を 願う」と同じ解析になって
; いるが、解析できないほうがよい。
; </type>
mental-c-minusshon-stem-lex := mental-minusshon-stem-lex & [STEMTYPE c-stem].

; <type val="mental-c2-minusshon-stem-lex">
; <name-ja>精神動詞五段変則非丁寧
; <description>mental-c-minusshon-stem-lexを参照。五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphology)。
; おそらく「ありがとう ござい ます」「ありがとう ござい まし た」の形でしか使わない。
; また、おそらく「が」格や「に」格が現れない形でしか使わない。
; <ex>贈り物 を ありがとう ござい ます
; <nex>私 が ありがとう ござる
; <todo>(TK 07-05-08)mental-c-minusshon-stem-lexを参照。
; (TK 07-05-08)「ありがとう ござる」がこのtypeである必要があるかどうか。
; </type>
mental-c2-minusshon-stem-lex := mental-minusshon-stem-lex  & [STEMTYPE c2-stem].

mental-v-minusshon-stem-lex := mental-minusshon-stem-lex & [STEMTYPE v-stem].

to_intrans-stem-lex := v-nonop-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.COP -,
                    VAL to_intransitive-opt &
                         [COMPS.FIRST #comp & [LOCAL.CONT.HOOK [LTOP #arghndl,
								XARG #xarg]]]],
               CONT [HOOK.XARG #xarg],
               CTXT.BACKGROUND <! !>,
		ARG-S < #comp >],
	 LKEYS.KEYREL.ARG1 #arghndl,
         NON-LOCAL.QUE <! !>]].




; <type val="to_intrans-c-stem-lex">
; <name-ja>非動作性イウ
; <description>「言う」の発信動作的な意味のなくなったもの。「と(case-p-lex or comp-prpstn-lex)」格
; のみを取り、五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>たこ焼き と 言え ば 大阪 だ
; <ex>秋田犬 と 言う 犬
; <nex>子供 が 眠い と 言う
; <todo>
; </type>
to_intrans-c-stem-lex := to_intrans-stem-lex & [STEMTYPE c-stem].
to_intrans-c2-stem-lex := to_intrans-stem-lex & [STEMTYPE c2-stem].
to_intrans-v-stem-lex := to_intrans-stem-lex & [STEMTYPE v-stem].

; <type val="to_intrans-c-stem-nomorp-lex">
; <name-ja>非動作性イウ
; <description>to_intrans-c-stem-lexを参照。
; <ex>たこ焼き と いえ ば 大阪 だ
; <ex>秋田犬 と いう 犬
; <ex>東京 や 大阪 と いっ た 都市
; <nex>子供 が 眠い と いう
; <todo>(TK 07-03-30)nounmod-p-lexの「という」「といった」との使い分けは？
; </type>
to_intrans-c-stem-nomorph-lex := to_intrans-c-stem-lex  &
			  [RMORPH-BIND-TYPE nomorphbind].


cop-id-stem-lex := v-sbj-comps-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD cop-id-stem_head &
			  [H-TENSE #tense],
                    VAL cop-id_transitive &
                         [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind,
			  SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind]],
		CONT verb-sem-type &
                   [HOOK [LTOP #hand,
			  INDEX  #ind &
			       [E [TENSE #tense]],
			  XARG #sbjind],
                    RELS.LIST.FIRST [LBL  #hand]],
		CTXT.BACKGROUND <! !>],
	 LKEYS.KEYREL equal-relation &
		    [PRED "cop_id_rel",
                            LBL #hand,
                            ARG1 #sbjind,
                            ARG2 #objind,
                            ARG0 #ind]]].

cop-id-noquest-stem-lex := cop-id-stem-lex &
			    [ SYNSEM.NON-LOCAL.QUE <! !>].

; <type val="cop-id-noquest-c2stem-lex">
; <name-ja>承名詞普通助動詞五段変則
; <description>cop-id-ordinary-dastem-lex「だ」の変形。名詞について断定などの意を表す。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>これ が ペン で ある
; <nex>海 が 静か で ある
; <todo>(TK 07-05-09)「で ござる」もこのtypeで登録されているが、これは"AHON +"では？
; </type>
cop-id-noquest-c2stem-lex := cop-id-noquest-stem-lex &
			     [STEMTYPE c2-stem].

cop-id-ordinary-stem-lex := cop-id-noquest-stem-lex &
			    [ SYNSEM.LOCAL.CAT.HEAD.MOD null].

; <type val="cop-id-ordinary-dastem-lex">
; <name-ja>承名詞普通助動詞
; <description>名詞について断定などの意を表す。活用は未然形「だろ」、連用形「だっ」「で」、
; 終止形「だ」。
; <ex>これ が ペン だ
; <nex>海 が 静か だ
; <todo>
; </type>
cop-id-ordinary-dastem-lex := cop-id-ordinary-stem-lex &
			      [STEMTYPE da-stem].

cop-id-ordinary-desustem-lex := cop-id-ordinary-stem-lex &
			      [STEMTYPE desu-stem].


; <type val="cop-id-conditional-stem-lex">
; <name-ja>承名詞助動詞条件
; <description>「名詞+ならorながら」の形で従属節を作る。そのためこのtypeによって文が終止することはない。
; <ex>彼 なら 心配 は いら ない
; <ex>あの 子 は 小学生 ながら 賢い
; <nex>彼 が 来る なら 帰る
; <todo>
; </type>
cop-id-conditional-stem-lex := cop-id-ordinary-stem-lex &
 [ SYNSEM.LOCAL.CAT.HEAD.MODUS conditional,
   STEMTYPE da-stem].

; <type val="cop-id-ordinary-daiquest-stem-lex">
; <name-ja>承名詞助動詞疑問ダイ
; <description>wh-wordについてwh疑問文を作る。このtypeによって文は終止する。wh-wordのない文には出現しない。
; 「何がしたいんだい」
; もこれで解析されるべきかは不明。
; <ex>君 は 誰 だい
; <nex>これ が ペン だい
; <todo>
; </type>
cop-id-ordinary-daiquest-stem-lex := cop-id-ordinary-desustem-lex &
				     [SYNSEM.LOCAL [CAT [HEAD [MOD null,
							       J-SPEC null,
							       MARK null,
							       FORMAL.AHON -],
							 VAL.COMPS.FIRST [NON-LOCAL.QUE <! handle !>]]]].

; (MS 2005-12-13) if we want to parse phrases like 誰かい, the complement's head must be noun_head and
; the copula must not add QUE information.

; <type val="cop-id-quest-stem-lex">
; <name-ja>承名詞助動詞疑問
; <description>名詞の後について、疑問の意を表す助動詞。活用はしない。
; <ex>あれ が ペン かい
; <nex>大丈夫 かい
; <todo>(TK 07-05-07)UTTERANCE_RULE-DECL-FINITEとUTTERANCE_RULE-WH-WITHOUT-KAの選択肢が出るが、
; まず、必ず疑問文になるので前者は不要で、更にWH疑問文ではない（「誰かい」という表現はしない）
; ので後者も正しくない。
; </type>
cop-id-quest-stem-lex := cop-id-stem-lex &
			 [SYNSEM [LOCAL [CAT [HEAD [MODUS indicative,
						    MOD null,
						   J-SPEC null,
						   SMOD quest,
						   MARK null,
						   FORMAL.AHON -],
					      VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head]]],
			  STEMTYPE desu-stem].

cop-id-quest-stem-noquestincomp-lex := cop-id-quest-stem-lex &
				 [SYNSEM.LOCAL.CAT.VAL.COMPS.FIRST.NON-LOCAL.QUE <! !>].

; <type val="cop-id-quest-stem-masc-lex">
; <name-ja>承名詞助動詞疑問男性語
; <description>cop-id-quest-stem-lexを参照。ただしこのtypeは男性が使う言葉である。
; 現状では「か なあ」しか登録されていないが、これは女性でも使う場合がある。
; <ex>あれ が ペン か なあ
; <nex>大丈夫 か なあ
; <todo>(TK 07-05-07)cop-id-quest-stem-lexを参照。
; </type>
cop-id-quest-stem-masc-lex := cop-id-quest-stem-lex &
			      [SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN masc].

; <type val="cop-id-quest-stem-fem-lex">
; <name-ja>承名詞助動詞疑問女性語
; <description>cop-id-quest-stem-lexを参照。ただしこのtypeは女性が使う言葉である。
; <ex>あれ が ペン かしら
; <nex>大丈夫 かしら
; <todo>(TK 07-05-07)cop-id-quest-stem-lexを参照。
; </type>
cop-id-quest-stem-fem-lex := cop-id-quest-stem-lex &
			      [SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN fem].

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

; <type val="cop-id-neg-stem-lex">
; <name-ja>承名詞助動詞否定
; <description>名詞の直後につき、否定の意を表す助動詞。i-adj-stem-lexと同じ活用をする。
; <ex>それ は 石 で は ない
; <ex>それ は 石 で ない
; <nex>
; <todo>
; </type>
cop-id-neg-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
			  [MODUS negative],
                    VAL cop-id_transitive & [COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #objind],
					     SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind]]],
		CONT [HOOK [LTOP #neg-hand,
			   XARG #sbjind],
                     RELS <! neg-relation & #key & 
			   [LBL #neg-hand, 
			    PRED "neg_v_rel",
			    ARG1 #arg],
			   equal-relation & 
			   [PRED "cop_id_rel",
			    LBL #cop-hand,
			    ARG1 #sbjind,
			    ARG2 #objind]!>,
		      HCONS <! qeq & [HARG #arg, LARG #cop-hand] !>],
		CTXT.BACKGROUND <! !>,
		ARG-S < #sbj . #comps >],
	 LKEYS.KEYREL #key,
	 NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].


; (ERB 2002-01-28) To reduce ambiguity, disallow conjoined Ss as
; complement of copula, by requiring NUCL not_fin_conj.

cop-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
                          COP +,
                          H-TENSE #tense,
                          VN -,
                          AUX aux_minus,
                          LIGHT -,
                          ADJ -],
                    VAL cop-stem_transitive & [COMPS #comps & [FIRST [LOCAL [CONT.HOOK #hook,
									    CAT.HEAD.H-TENSE #tense,
									    NUCL not_fin_conj]]]]],
		CONT [HOOK #hook & [LTOP #hand],
		      RELS <! !>,
		      HCONS <! !>],
		CTXT.BACKGROUND <! !>,
		ARG-S #comps],
	 LKEYS.KEYREL.LBL #hand,
	 NON-LOCAL.QUE <! !>]].

; (ERB 2001-11-07) Types added strictly for ranking purposes.
; I want to be able to prefer the N/NO + cop entries, without having
; to list them all in japanese.set.  n-cop-stem-lex is the type for these
; guys.  reg-cop-stem-lex is the type for the other entries of the copula
; that (a) are not inflecting and (b) make no semantic contribution.

n-cop-stem-lex := cop-stem-lex.

; <type val="reg-cop-stem-lex">
; <name-ja>承形容動詞助動詞五段変則
; <description>na-adj-lexを受ける助動詞。五段変則活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyのc2-stemを参照)。
; <ex>綺麗 で ござる
; <nex>犬 で ござる
; <todo>(TK 07-05-24)「で ござる」しか登録されていないが、これは"AHON +"と思われる。
; </type>
reg-cop-stem-lex := cop-stem-lex & [SYNSEM.LKEYS.KEYREL arg1-ev-relation].

reg-cop-stem-desustem-lex := reg-cop-stem-lex &
			     [STEMTYPE desu-stem].

reg-cop-stem-dastem-lex := reg-cop-stem-lex &
			     [STEMTYPE da-stem].

reg-cop-stem-c2stem-lex := reg-cop-stem-lex &
			     [STEMTYPE c2-stem].

 
reg-cop-stem-indicative-lex := reg-cop-stem-lex &
			       [SYNSEM.LOCAL.CAT.HEAD.MODUS indicative].

reg-cop-stem-nomod-lex := reg-cop-stem-lex & 
			  [SYNSEM.LOCAL.CAT.HEAD.MOD null].

; <type val="reg-cop-stem-indicative-desustem-lex">
; <name-ja>承形容動詞助動詞
; <description>reg-cop-stem-indicative-c2stem-lexを参照。ただし活用は終止形「です」未然形「でしょ」
; 連用形「でし」のみ。文の終止を表す「です」と接続助詞的に使う「で」が
; 同一エントリ(desu-v-cop-stem)で扱われているのはどうか（正確には「で 、」の形でないと解析不可能）。
; <ex>綺麗 です
; <ex>綺麗 で 、 新しい
; <nex>犬 です
; <todo>
; </type>
reg-cop-stem-indicative-desustem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-desustem-lex.

reg-cop-stem-indicative-dastem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-dastem-lex.

; <type val="reg-cop-stem-indicative-c2stem-lex">
; <name-ja>承形容動詞助動詞五段変則
; <description>na-adj-lexを受ける助動詞。特に丁寧や尊敬の意味を表さない場合に用いる。
; ラ行五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>綺麗 で ある
; <nex>犬 で ある
; <todo>
; </type>
reg-cop-stem-indicative-c2stem-lex := reg-cop-stem-indicative-lex & reg-cop-stem-c2stem-lex.

; <type val="reg-cop-stem-indicative-dastem-nomod-lex">
; <name-ja>承形容動詞助動詞終止
; <description>na-adj-lexなどを受けて名詞を修飾する形容動詞を作る。このtypeは何かを修飾することはないので
; そのまま終止形や過去形で文を終止するが、「な」など終助詞が後につくことがある。
; <ex>綺麗 だ
; <ex>綺麗 だ ね
; <nex>犬 だ
; <todo>
; </type>
reg-cop-stem-indicative-dastem-nomod-lex := reg-cop-stem-indicative-dastem-lex & reg-cop-stem-nomod-lex.


; <type val="reg-cop-stem-indicative-dastem-nmod-lex">
; <name-ja>承形容動詞助動詞名詞修飾
; <description>na-adj-lexなどを受けて名詞を修飾する形容動詞を作る。活用はしない。
; <ex>綺麗 な 犬
; <nex>綺麗 だ な
; <todo>
; </type>
; (FCB 2008-06-25) made FIN - so that it doesn't head sentences
reg-cop-stem-indicative-dastem-nmod-lex := reg-cop-stem-indicative-dastem-lex & 
 [SYNSEM [LOCAL.CAT.HEAD.MOD < [LOCAL [CAT [HEAD noun_head & [FIN -]],
				       CONT.HOOK.INDEX #ind,
				       BAR + ]] >,
	  LKEYS.KEYREL.ARG1 #ind]].


reg-cop-stem-fem-lex := reg-cop-stem-lex &
			[SYNSEM.LOCAL.CTXT.C-INDICES.SPEAKER.PNG.GEN fem,
			 STEMTYPE desu-stem].


; <type val="reg-cop-stem-nomod-fem-lex">
; <name-ja>承形容動詞助動詞終止女性語
; <description>reg-cop-stem-nomod-desustem-lexを参照。更に女性が使う言葉である意味を付加する。疑問文でも平叙文でも
; 使うが、Dependenciesには疑問の意味は現れていないように見える。
; <ex>大丈夫 かしら
; <nex>犬 かしら
; <todo>(TK 07-05-07)「かしら」は疑問で、「かなあ」は疑問あるいは願望の意味で使われる。現状ではそのいずれの意味
; にもならない。
; </type>
reg-cop-stem-nomod-fem-lex := reg-cop-stem-nomod-lex & reg-cop-stem-fem-lex.

; <type val="reg-cop-stem-nomod-desustem-lex">
; <name-ja>承形容動詞助動詞終止
; <description>reg-cop-stem-indicative-dastem-nomod-lexを参照。終止形のみ。後に終助詞がつくこともある。
; <ex>綺麗 なん です
; <nex>なん です か
; <todo>
; </type>
reg-cop-stem-nomod-desustem-lex := reg-cop-stem-nomod-lex & reg-cop-stem-desustem-lex.

; (ERB 2001-10-25) Using type neg_rel instead of PRED 'neg_rel.
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

; <type val="cop-neg-stem-lex">
; <name-ja>承形容動詞助動詞否定
; <description>na-adj-lexの後につく助動詞で、否定の意を表す。i-adj-stem-lexと同じ活用をする。
; <ex>静か で は ない
; <nex>犬 で は ない
; <todo>
; </type>
cop-neg-stem-lex := verb-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
                          COP +,
                          H-TENSE #tense,
                          VN -,
                          AUX aux_minus,
                          LIGHT -,
                          MODUS negative,
                          ADJ +],
		     VAL cop-stem_transitive & 
			  [COMPS #comps & [FIRST [LOCAL [CONT.HOOK [INDEX #ind,
								     LTOP #objhd],
							 CAT.HEAD.H-TENSE #tense]]]]],
		CONT [HOOK [LTOP #hand,
			    INDEX #ind],
		      RELS <! #key & neg-relation & 
			    [LBL #hand, 
			     PRED "neg_v_rel", 
			     ARG1 #arg ] !>,
		      HCONS <! qeq & [HARG #arg, LARG #objhd] !>],
		CTXT.BACKGROUND <! !>,
		ARG-S #comps],
	 LKEYS.KEYREL #key,
         NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].

; (MS 2003-06-23) ではない
; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.

; <type val="cop-neg-lex">
; <name-ja>承助詞助動詞否定
; <description>用言やpostp-lexの後につく助動詞で、否定の意を表す。i-adj-stem-lexと同じ活用をする。
; <ex>行く ほど で は ない
; <nex>
; <todo>
; </type>
cop-neg-lex := nonaux-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
			  J-POSTHEAD left,
                          MARK null,
                          SMOD unmarked,
			  MODUS negative,
                          COP +,
                          H-TENSE #tense],
                    VAL cop_transitive & [COMPS #comps & [FIRST [LOCAL [CONT [HOOK #hook & [INDEX #ind,
											    LTOP #objhd]],
								       CAT.HEAD.H-TENSE #tense,
								       NUCL not_fin_conj]]]]],
	       
	       CONT [HOOK #hook & [LTOP #hand,
				   INDEX #ind],
		     RELS <! #key & neg-relation & 
			   [PRED "neg_v_rel",
			    ARG1 #arg ]  !>,
		     HCONS <! qeq & [HARG #arg, LARG #objhd] !>],
	       CTXT.BACKGROUND <! !>,
	       ARG-S #comps,
	       BAR +],
	 LKEYS.KEYREL #key & [LBL #hand]],
 INFLECTED +,
 J-NEEDS-AFFIX -,
 STEMTYPE adj-stem].


; (ERB 2002-01-14) SMOD unmarked to constrain nonprop GA.

; (ERB 2002-01-28) To reduce ambiguity, disallow conjoined Ss as
; complement of copula, by requiring NUCL not_fin_conj.  (This isn't
; usually an issue because of the constraint on MAIN-PRD, but it
; seems to be coming up for DEKIRU at least.)

; (MS 2003-12-19) Matrix 0.6

; (MS 2004-08-25) I now call them cop-light-lex.
;
; (MS 2005-06-20) These should take their FORMAL information from their complements: yoroshii deshou.
; (MS 2005-12-22) No, this is not right for AHON: 食べるでしょう


cop-light-lex := nonaux-lex &
[SYNSEM [LOCAL [CAT [HEAD [COP-ARG -,
			   MARK null,
			   SMOD unmarked,
			   COP +,
			   H-TENSE #tense,
			   FORMAL.SHON #form],
                    VAL  cop_transitive & 
			  [COMPS #comps & 
				 [FIRST [LOCAL [CONT [HOOK #hook],
						CAT.HEAD [H-TENSE #tense,
							  FORMAL.SHON #form],
						NUCL not_fin_conj]]]]],
		CONT [HOOK #hook,
		      RELS <! !> ,
		      HCONS <! !>],
		CTXT.BACKGROUND <! !>,
		ARG-S #comps,
		BAR +]],
 INFLECTED +,
 J-NEEDS-AFFIX -].



; (ERB 2001-11-07) Types added strictly for ranking purposes.
; I want to be able to prefer the N/NO + cop entries, without having
; to list them all in japanese.set.  n-cop-lex is the type for these
; guys.  reg-cop-lex is the type for the other entries of the copula
; that (a) are not inflecting and (b) make no semantic contribution.

; (ERB 2002-02-12) n-cop-lex are (so far) all [C-MOD null], so put
; that constraint here.  (I think it used to be on cop-lex, but
; that doesn't work for deshitara.)  Also, all are MOD none and say
; the same thing about H-TENSE.

; <type val="n-cop-lex">
; <name-ja>承用言助動詞連語
; <description>用言の終止形や過去形などの後につく、「の+助動詞」あるいはその変形。
; <ex>行く の だ
; <ex>良い の だ
; <nex>先生 の だ
; <todo>(TK 07-05-08)「ん だろ う」など推測を表すものもこのtypeで良いかどうか。
; </type>
n-cop-lex := cop-light-lex &
[SYNSEM.LOCAL.CAT [HEAD [H-TENSE #tense,
                         MODUS #mood,
                         MOD null,
                         C-MOD null],
                   VAL.COMPS.FIRST.LOCAL.CAT.HEAD [H-TENSE #tense,
                                                  MODUS #mood]]].



;の です 
;の で す
;ん です
;; (TK 08-04-09)
; <type val="n-cop-ahon-lex">
; <name-ja>承用言助動詞連語尊敬
; <description>n-cop-lexを参照。このtypeは聞き手（読み手）への敬意を表す場合に使う。
; <ex>行く の です
; <ex>良い の です
; <nex>先生 の です
; <todo>
; </type>
n-cop-ahon-lex := n-cop-lex &
	       	  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].





reg-cop-lex := cop-light-lex.


; <type val="reg-cop-lex-indicative">
; <name-ja>承用言助動詞平叙
; <description>用言の終止形や過去形などの後につく助動詞で、平叙文に用いる。
; ただし実際には用言の直後につかずに「べき」や「ばかり」の後につくことが多いのではないか。
; <ex>行く べき だっ た
; <nex>
; <todo>(TK 07-03-27)「な」がこのtypeで登録されているのは正しいかどうか。
; もし(lkb::do-parse-tty "見る な よ")という用法のためなら、この「な」は禁止の意味を持つ
; type（やはり終助詞か？）で登録されるべき。
; </type>
reg-cop-lex-indicative := reg-cop-lex &
			  [SYNSEM.LOCAL.CAT.HEAD [MODUS indicative,
						   MOD null,
						  C-MOD null]].


reg-cop-lex-subjunctive := reg-cop-lex &
			  [SYNSEM.LOCAL [CONT.HOOK.INDEX.E.MOOD subjunctive,
					 CAT.HEAD [MOD null,
						   C-MOD null]]].

;でしょう
; <type val="reg-cop-lex-subjunctive-polite">
; <name-ja>承用言助動詞推定尊敬
; <description>reg-cop-lex-subjunctive-plainを参照。このtypeは聞き手（読み手）への敬意を表す場合に使う。
; <ex>良い でしょ う
; <ex>行く でしょ う
; <nex>犬 でしょ う
; <todo>
; </type>
reg-cop-lex-subjunctive-polite := reg-cop-lex-subjunctive &
				  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

;だろう
; <type val="reg-cop-lex-subjunctive-plain">
; <name-ja>承用言助動詞推定
; <description>用言の終止形や過去形の後につき、推定の意味を付加する助動詞。活用はしない。
; <ex>良い だろ う
; <ex>行く だろ う
; <nex>犬 だろ う
; <todo>
; </type>
reg-cop-lex-subjunctive-plain := reg-cop-lex-subjunctive &
				  [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON -].



; <type val="reg-cop-lex-indicative-nonfinite">
; <name-ja>承用言助動詞非定型
; <description>reg-cop-lex-indicative-finiteを参照。ただし現実的には、用言の終止形や過去形の後で使うことはなく、
; 接続助詞的に使う？
; <ex>泣く ばかり で 食べ ない
; <ex>食べ ない で 走る
; <nex>犬 で ある
; <todo>
; </type>
reg-cop-lex-indicative-nonfinite := reg-cop-lex &
				 [SYNSEM.LOCAL.CAT.HEAD [MODUS indicative,
							 MOD null,
							 FIN -,
							 MAIN-PRD -,
							 J-SPEC null,
							 VN -,
							 C-MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD +],
									 BAR +]]>]].

; <type val="reg-cop-lex-indicative-finite">
; <name-ja>承用言助動詞定型
; <description>用言の終止形や過去形の後だけでなく、「べき」「ばかり」「たい」などの後にもつく助動詞。
; 平叙文の際に用いる。活用はしない。
; <ex>良い です
; <ex>行く べき です
; <nex>犬 です
; <todo>
; </type>
reg-cop-lex-indicative-finite := reg-cop-lex-indicative &
				 [SYNSEM.LOCAL.CAT.HEAD.FIN +].


reg-cop-lex-indicative-plain := reg-cop-lex-indicative &
				[SYNSEM.LOCAL.CAT [HEAD.FORMAL.AHON -,
						   VAL.COMPS.FIRST [NON-LOCAL.QUE <! handle !>,
								    LOCAL.CAT.HEAD adv_head]]].

; (MS 2004-04-02): "もしそうなら修理にだした方がいいです"
; なら
; (FCB 2006-06-02) restricted the complement to be a noun_head
; e.g. don't appear in: (lkb::do-parse-tty "座る なら 寝る")
reg-cop-lex-conditional := reg-cop-lex &
 [SYNSEM.LOCAL [CAT [HEAD  [MAIN-PRD -,
			  MODUS conditional,
			  C-MOD < [LOCAL [CAT.HEAD verb_head & [MAIN-PRD +],
					  BAR +]] >,
			  J-SPEC null,
			  FIN -,
			  H-TENSE present,
			  VN -,
			   MOD null],
		     VAL.COMPS.FIRST.LOCAL.CAT.HEAD noun_head]]].


; (MS 2004-11-17) Not all auxiliaries have a key relation. That's why I took this
; out here.

aux-top-stem-lex := verb-stem-lex & lexical_sign-word &
              [SYNSEM [LOCAL [CAT [HEAD aux-stem_head &
                                        [H-TENSE #tense]],
                              CONT [HOOK.INDEX [E [TENSE #tense]]]],
                       NON-LOCAL.QUE <! !>,
		       MODIFIED.PERIPH bool]].

aux-arg123-stem-lex := aux-top-stem-lex &
 [SYNSEM [LOCAL [CAT.VAL [SPR.FIRST.LOCAL.CONT.HOOK.LTOP #ohand,
			  SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
			  COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #obj2ind],
		 CONT [RELS diff-list & <! #key & arg123-relation &
					 [ARG0 #event,
					  ARG1 #sbjind,
					  ARG2 #obj2ind,
					  ARG3 #chand] !>,
		       HOOK.INDEX #event,
		       HCONS <! qeq & [HARG #chand, LARG #ohand] !>]],
	  LKEYS.KEYREL #key]].


; (MS 2005-11-09) These all unify ARG1 with EMPEE.

aux-obj-id-stem-lex := aux-arg123-stem-lex &
 [SYNSEM.LOCAL [CAT [VAL aux_transitive &
			 [SUBJ.FIRST #sbj &[LOCAL.CONT.HOOK.INDEX #sbjind],
			  COMPS #comps],
		     HEAD.AUX complex_aux],
		CTXT.EMPATHY.EMPEE #sbjind,
		ARG-S < #sbj . #comps >]].

                                                  

aux-obj-id-v-stem-lex := aux-obj-id-stem-lex & [STEMTYPE v-stem].
; <type val="aux-obj-id-c-stem-lex">
; <name-ja>目的格補助動詞
; <description>日本語で一般的に補助動詞と呼ばれる。「動詞+て」の形の後につく。「が」格と「に」格と本動詞
; を格として取り、「が」格（行為を受けるもの）かこのtypeのARG1、「に」格（行為を行うもの）がARG2、
; 本動詞（行為そのもの）がARG3となる。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>弟 が 母 に 絵本 を 買っ て もらう
; <nex>絵本 を もらっ た
; <todo>
; </type>
aux-obj-id-c-stem-lex := aux-obj-id-stem-lex & [STEMTYPE c-stem].
aux-obj-id-c2-stem-lex := aux-obj-id-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-kurusuru-stem-lex := aux-obj-id-stem-lex & [STEMTYPE kurusuru-stem].


aux-obj-id-minus_shon-stem-lex := aux-obj-id-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                                              VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                                                      CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

aux-obj-id-minus_shon-v-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE v-stem].
; <type val="aux-obj-id-minus_shon-c-stem-lex">
; <name-ja>目的格補助動詞非尊敬
; <description>aux-obj-id-c-stem-lexを参照。このtypeは主語（「が」格）に対する敬意を表す場合には
; 使えない。
; <ex>私 が 先生 に 本 を 貸し て いただく
; <nex>味噌汁 を いただく
; <todo>
; </type>
aux-obj-id-minus_shon-c-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE c-stem].
aux-obj-id-minus_shon-c2-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-minus_shon-kurusuru-stem-lex := aux-obj-id-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

aux-obj-id-shon-stem-lex := aux-obj-id-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2 ]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

aux-obj-id-shon-v-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE v-stem].
aux-obj-id-shon-c-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE c-stem].
aux-obj-id-shon-c2-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE c2-stem].
aux-obj-id-shon-kurusuru-stem-lex := aux-obj-id-shon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-12-28) For VN + itadaku, etc.
light-obj-id-stem-lex := aux-arg123-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL light-aux_transitive &
			[SUBJ.FIRST #sbj,
			 COMPS #comps],
		ARG-S < #sbj . #comps >]].
                                                  

light-obj-id-v-stem-lex := light-obj-id-stem-lex & [STEMTYPE v-stem].
light-obj-id-c-stem-lex := light-obj-id-stem-lex & [STEMTYPE c-stem].
light-obj-id-c2-stem-lex := light-obj-id-stem-lex & [STEMTYPE c2-stem].
light-obj-id-kurusuru-stem-lex := light-obj-id-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-arg1emp-stem-lex := light-obj-id-stem-lex &
				 [SYNSEM [LKEYS.KEYREL [ARG1 #ind],
					  LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-obj-id-arg1emp-v-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE v-stem].
light-obj-id-arg1emp-c-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE c-stem].
light-obj-id-arg1emp-c2-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-obj-id-arg1emp-kurusuru-stem-lex := light-obj-id-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-minus_shon-stem-lex := light-obj-id-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

light-obj-id-minus_shon-v-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE v-stem].
light-obj-id-minus_shon-c-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE c-stem].
light-obj-id-minus_shon-c2-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE c2-stem].
light-obj-id-minus_shon-kurusuru-stem-lex := light-obj-id-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


light-obj-id-minus_shon-arg1emp-stem-lex := light-obj-id-minus_shon-stem-lex &
					 [SYNSEM [LKEYS.KEYREL [ARG1 #ind],
						   LOCAL.CTXT.EMPATHY.EMPEE #ind]].   

light-obj-id-minus_shon-arg1emp-v-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE v-stem].
; <type val="light-obj-id-minus_shon-arg1emp-c-stem-lex">
; <name-ja>承サ変補助動詞非尊敬五段
; <description>light-nohon-kurusuru-stem-lexを参照。このtypeは「が」格と「を」格と「に」格を取り、
; 「が」格（行為を受けるもの）がこのtypeのARG1、「に」格（行為を行うもの）がARG2、vn-lex（行われる行為）
; がARG3になる。実際の文章では「が」格が現れない場合が多い。もし現れた場合はargumentがうまく取れなくなる。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphology)。
; 現状では「を」格を取るvn-lexでしか使えなくなっている。
; <ex>皆様 に 商品 を ご 購入 いただく
; <nex>抹茶 を いただく
; <todo>(TK 07-03-27)「を」格を取らないvn-lexでも解析できるようにすべき。
; (lkb::do-parse-tty "皆様 に ご 起立 いただく")
; (TK 07-03-27)また、(lkb::do-parse-tty "弟子 が 師匠 に 芸 を ご 実演 いただく")も念のためきちんと解析
; できるようにしておいた方が良いかもしれない。
; (TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、敬語表現
; では(lkb::do-parse-tty "皆様 に 商品 を お 調べ いただく")と言える。
; </type>
light-obj-id-minus_shon-arg1emp-c-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-obj-id-minus_shon-arg1emp-c2-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-obj-id-minus_shon-arg1emp-kurusuru-stem-lex := light-obj-id-minus_shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].




light-obj-id-shon-stem-lex := light-obj-id-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

light-obj-id-shon-v-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE v-stem].
light-obj-id-shon-c-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE c-stem].
light-obj-id-shon-c2-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE c2-stem].
light-obj-id-shon-kurusuru-stem-lex := light-obj-id-shon-stem-lex & [STEMTYPE kurusuru-stem].



; (MS 2003-12-19) Matrix 0.6
; (MS 2004-11-17) Some aspect auxiliaries add a relation (見る, みせる)
; (MS 2005-11-08) The aspect is modal in all cases.
;  FIXME shouldn't come after te-adjunct

complex-aspect-stem-lex  := aux-top-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL aspect_transitive &
			  [ SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
			    SPR.FIRST.LOCAL [CAT.VAL.SUBJ.FIRST #sbj,
					     CONT.HOOK [LTOP #ohand]]],
		      HEAD.AUX aspect_aux],
		 CONT [ HOOK.INDEX #event & [E.ASPECT modal],
			RELS  <! #key & arg12-relation &
			       [ ARG0 #event,
				 ARG1 #sbjind,
				 ARG2 #aux-hand] !>,
			HCONS <! qeq & [ HARG #aux-hand, LARG #ohand] !> ],
	       ARG-S < #sbj >],
	  LKEYS.KEYREL #key ]].


; <type val="complex-aspect-v-stem-lex">
; <name-ja>相複合補助動詞一段
; <description>「動詞連用形+て（で）」の直後につく補助動詞。このtypeはpure-aspect-lexと違い、
; argumentを取り、MRSに現れることができる。その際、ARG1に「が」格（本動詞と同じもの）、ARG2に本動詞
; が入る。
; <ex>私 が 内容 を 説明 し て みる
; <ex>私 が 内容 を 説明 し て みせる
; <nex>私 が 内容 を みる
; <todo>(TK 07-04-17)「みせる」「見せる」は、（それを目撃する対象である）「に」格も取るのではないか
; 能動態(lkb::do-parse-tty "怪獣 が 人々 に ヒーロー を 倒し て みせる")
; 間接受身(lkb::do-parse-tty "人々 が 怪獣 に ヒーロー を 倒し て みせ られる")
; </type>
complex-aspect-v-stem-lex := complex-aspect-stem-lex & [STEMTYPE v-stem].
complex-aspect-c-stem-lex := complex-aspect-stem-lex & [STEMTYPE c-stem].
complex-aspect-c2-stem-lex := complex-aspect-stem-lex & [STEMTYPE c2-stem].
complex-aspect-kurusuru-stem-lex := complex-aspect-stem-lex & [STEMTYPE kurusuru-stem].

complex-aspect-minus_shon-stem-lex := complex-aspect-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
							       CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

complex-aspect-minus_shon-v-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE v-stem].
complex-aspect-minus_shon-c-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE c-stem].
complex-aspect-minus_shon-c2-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE c2-stem].
complex-aspect-minus_shon-kurusuru-stem-lex := complex-aspect-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

complex-aspect-shon-stem-lex := complex-aspect-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

complex-aspect-shon-v-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE v-stem].
complex-aspect-shon-c-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE c-stem].
complex-aspect-shon-c2-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE c2-stem].
complex-aspect-shon-kurusuru-stem-lex := complex-aspect-shon-stem-lex & [STEMTYPE kurusuru-stem].


; (MS 2004-11-17) This one now links the first complement of the verb to the ARG1 of the complex.
; (MS 2005-11-08) These seem all to have perfective aspect.

aspect-stem-lex  := aux-top-stem-lex &
[SYNSEM [LOCAL [CAT [VAL aspect_transitive &
                          [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
			   SPR.FIRST.LOCAL [CAT.VAL sbj-obj-arg & [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind],
					    CONT.HOOK [INDEX #event,
						       LTOP #ltop,
						       XARG zpro_ref-ind]]],
		     HEAD.AUX aspect_aux],
		CONT [HOOK [INDEX #event & [E.ASPECT perfective],
			    LTOP #ltop],
		      RELS <! !>,
		      HCONS <! !> ],
	       ARG-S < #sbj >]]].


aspect-v-stem-lex := aspect-stem-lex & [STEMTYPE v-stem].
; <type val="aspect-c-stem-lex">
; <name-ja>項逆転補助動詞五段
; <description>補助動詞の「ある」。「用言+て+ある」の形で使う。「が」格と「を」格を入れ替えてしまうので、
; 「本が買ってある」は正しく解析できるが、逆に「本を買ってある」が解析できない。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>本 が 買っ て ある
; <nex>本 が ある
; <todo>(07-03-27)(lkb::do-parse-tty "本 を 買っ て ある")も解析できるようにすべき。
; </type>
aspect-c-stem-lex := aspect-stem-lex & [STEMTYPE c-stem].
; <type val="aspect-c2-stem-lex">
; <name-ja>項逆転補助動詞五段変則
; <description>補助動詞の「ござる」。aspect-c-stem-lexを参照。ただし、「が」格と「を」格を入れ替えてしまうこのtype
; が適当かどうかは不明。また、pure-aspect-progressive-v-stemlex「いる」の尊敬語としては使えない。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; また、本来「ござる」は尊敬語であり、現代語としては「ござい ます」の形で使う。
; <ex>本 が 買っ て ござい ます
; <nex>ビール が ござい ます
; <todo>(07-03-27)aspect-c-stem-lexを参照。
; (07-03-27)「ござる」「御座る」はminus_shonのtypeにすべき。
; (07-03-27)「いる」の尊敬語としての「ござる」「御座る」のtypeも必要。
; </type>
aspect-c2-stem-lex := aspect-stem-lex & [STEMTYPE c2-stem].
aspect-kurusuru-stem-lex := aspect-stem-lex & [STEMTYPE kurusuru-stem].

aspect-minus_shon-stem-lex := aspect-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
							       CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

aspect-minus_shon-v-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE v-stem].
aspect-minus_shon-c-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE c-stem].
aspect-minus_shon-c2-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE c2-stem].
aspect-minus_shon-kurusuru-stem-lex := aspect-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

aspect-shon-stem-lex := aspect-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

aspect-shon-v-stem-lex := aspect-shon-stem-lex & [STEMTYPE v-stem].
aspect-shon-c-stem-lex := aspect-shon-stem-lex & [STEMTYPE c-stem].
aspect-shon-c2-stem-lex := aspect-shon-stem-lex & [STEMTYPE c2-stem].
aspect-shon-kurusuru-stem-lex := aspect-shon-stem-lex & [STEMTYPE kurusuru-stem].

; (ERB 2001-11-12) I think the real solution for the aspect auxiliaries
; (shimau, iru, aru, and maybe some others) is to make them contribute no
; relation but rather provide information about E.ASPECT of their specifier.
; This type is an interim solution to make them raising verbs -- that is, they
; contribute one place (arg4only) relations.

; (ERB 2001-11-12) This is a first pass at making "pure" aspect auxiliaries.
; The current motivation is "iru", which Monique has just come across, and
; which just looks silly right now with "iru_rel".  The idea here is that
; the pure aspect auxiliaries don't contribute a relation of their own but
; rather stamp some info into the E.ASPECT of the verb.  For now, they'll have
; underspecified KEY values, but we might find that we want them to raise
; the KEY of their SPR.  They certainly raise the handle & event.

; (ERB 2001-11-12) This idea requires more changes that I thought, because
; the te forms are currently [ TENSE te ] which doesn't unify with 
; [ TENSE present ].   Try making te form (as opposed to other [ TENSE te ]
; things) [ TENSE tensed ].  This will probably overgenerate.

; (ERB 2001-11-12) Don't want this inheriting from aux-top-stem-lex, 
; because that type puts the key on the liszt.  Adding the rest of the
; constraints directly in here.  Not making this lexical_sign-word, for
; now.  (No real KEY, don't need a WLINK.)

; (MS 2004-11-09) E.TENSE should come from the aspect auxiliary, other things in INDEX
; from the content verb: 食べなくている

; (MS 2004-12-01) Why do we need INSTLOC here? Take it out.
; (MS 2005-01-11) The XARG should be identified with the verb, otherwise
; we get a reading where the aspect verb undergoes zero pronominalization,
; while the main verb doesn't (友達を三人待っています)
; (FCB 2005-05-06) added restriction: SPR.FIRST.LOCAL.CAT.HEAD v-end_head 
; to stop overgeneration (勉強 し いる)


pure-aspect-stem-lex := verb-stem-lex &
 [SYNSEM [ LOCAL [CAT [ HEAD aux-stem_head & 
			     [ H-TENSE #tense,
			       AUX aspect_aux],
			VAL pure-aspect_transitive &
			     [SUBJ.FIRST #sbj,
			      SPR.FIRST.LOCAL [ CAT.HEAD v-end_head,
						CONT.HOOK [ LTOP #ohand,
							    INDEX #event & [SORT #sort,
									    E.MOOD #mood],
							    XARG #xarg]]]],
		  CONT [RELS <! !>,
			HOOK [INDEX [ E [TENSE #tense,
					MOOD #mood],
				     SORT #sort],
			     XARG #xarg,
			     LTOP #ohand],
                       HCONS <! !> ],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL [PRED "aspect",
			ARG0 #event],
	  MODIFIED.PERIPH bool,
	  NON-LOCAL.QUE <! !>]].

pure-aspect-perfprog-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT perfect_progressive ].

pure-aspect-inceptive-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT inceptive ].

pure-aspect-progressive-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT progressive ].

pure-aspect-terminative-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT terminative ].

pure-aspect-prospective-stem-lex := pure-aspect-stem-lex &
[ SYNSEM.LOCAL.CONT.HOOK.INDEX.E.ASPECT prospective ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-perfprog-v-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-c-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-c2-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE c2-stem].
; <type val="pure-aspect-perfprog-kurusuru-stem-lex">
; <name-ja>完了進行相補助動詞変格
; <description>「動詞連用形+て（で）」の直後につき、現在あるいは過去のある時点までその行為・状態が続いている
; という意味を添える補助動詞。「来る」「くる」がこのtypeに登録されている。
; カ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>７ 回 の 表 まで 投げ て 来 た
; <nex>７ 回 の 表 まで 来 た
; <todo>(TK 07-04-16)「来る」「くる」には完了進行以外にも用法がある。(lkb::do-parse-tty "向かっ て くる 敵 を 蹴散らす")
; </type>
pure-aspect-perfprog-kurusuru-stem-lex := pure-aspect-perfprog-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-perfprog-minus_shon-stem-lex := pure-aspect-perfprog-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-perfprog-minus_shon-v-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-minus_shon-c-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-minus_shon-c2-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-perfprog-minus_shon-kurusuru-stem-lex := pure-aspect-perfprog-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-perfprog-shon-stem-lex := pure-aspect-perfprog-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-perfprog-shon-v-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-perfprog-shon-c-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-perfprog-shon-c2-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-perfprog-shon-kurusuru-stem-lex := pure-aspect-perfprog-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-inceptive-v-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE v-stem].
pure-aspect-inceptive-c-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE c-stem].
; <type val="pure-aspect-inceptive-c2-stem-lex">
; <name-ja>起動相補助動詞五段変則
; <description>「動詞連用形+て（で）」の直後につき、現在あるいは過去・未来のある時点からその行為・状態が始まる
; という意味を添える補助動詞。「行く」「いく」がこのtypeに登録されている。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>消しゴム を 端 から 使っ て いく
; <nex>消しゴム を 買い に いく
; <todo>(TK 07-04-16)「行く」「いく」には起動相以外にも意味がある。(lkb::do-parse-tty "家 から 出 て いく")
; 「来る」なども起動相として使えるのではないか。「構想が固まりはじめる」→(lkb::do-parse-tty "構想 が 固まっ て くる")
; </type>
pure-aspect-inceptive-c2-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-kurusuru-stem-lex := pure-aspect-inceptive-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-inceptive-minus_shon-stem-lex := pure-aspect-inceptive-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-inceptive-minus_shon-v-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE v-stem].
; <type val="pure-aspect-inceptive-minus_shon-c-stem-lex">
; <name-ja>起動相補助動詞非尊敬五段
; <description>pure-aspect-inceptive-c2-stem-lexを参照。このtypeは主語（「が」格）に対する敬意を表す場合には
; 使えない。「参る」「まいる」がこのtypeに登録されている。五段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>太陽 が 上っ て 参り ます
; <nex>太陽 が 参り ます
; <todo>(TK 07-04-16)pure-aspect-inceptive-c2-stem-lexを参照。(lkb::do-parse-tty "来年 まで 続け て 参り ます")
; (TK 07-04-16)また、「参る」は「行く」「いく」のminus_shon版であると同時に、「来る」「くる」の
; minus_shon版でもある。(lkb::do-parse-tty "敵 が 向かっ て 参り ます")
; </type>
pure-aspect-inceptive-minus_shon-c-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-inceptive-minus_shon-c2-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-minus_shon-kurusuru-stem-lex := pure-aspect-inceptive-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-inceptive-shon-stem-lex := pure-aspect-inceptive-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-inceptive-shon-v-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-inceptive-shon-c-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-inceptive-shon-c2-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-inceptive-shon-kurusuru-stem-lex := pure-aspect-inceptive-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; <type val="pure-aspect-progressive-v-stem-lex">
; <name-ja>進行相補助動詞一段
; <description>「verbやlightverbの連用形+て」の形の直後にあってその行為や状態の中にある、という意を
; 添える補助動詞。一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>雨 が 降っ て いる
; <ex>絵 を 書い て いる
; <nex>雨 が いる
; <todo>
; </type>
pure-aspect-progressive-v-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE v-stem].
pure-aspect-progressive-c-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE c-stem].
pure-aspect-progressive-c2-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-kurusuru-stem-lex := pure-aspect-progressive-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-progressive-minus_shon-stem-lex := pure-aspect-progressive-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-progressive-minus_shon-v-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE v-stem].
; <type val="pure-aspect-progressive-minus_shon-c-stem-lex">
; <name-ja>進行相補助動詞非尊敬五段
; <description>pure-aspect-progressive-v-stem-lexを参照。このtypeは主語（「が」格）への敬意を表す
; 場合には使えない。五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>良品 を 揃え て おり ます
; <nex>犬 が おり ます
; <todo>
; </type>
pure-aspect-progressive-minus_shon-c-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-progressive-minus_shon-c2-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-minus_shon-kurusuru-stem-lex := pure-aspect-progressive-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-progressive-shon-stem-lex := pure-aspect-progressive-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-progressive-shon-v-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-progressive-shon-c-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE c-stem].
; <type val="pure-aspect-progressive-shon-c2-stem-lex">
; <name-ja>進行相補助動詞尊敬五段変則
; <description>「verbやlightverbの連用形+て」の形の直後にあってその行為や状態の中にある、という意を添え、
; 主語（「が」格）への尊敬の意を添える。
; 五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>先方 が 来 て いらっしゃる
; <nex>先方 が いらっしゃる
; <todo>
; </type>
pure-aspect-progressive-shon-c2-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-progressive-shon-kurusuru-stem-lex := pure-aspect-progressive-shon-stem-lex & [STEMTYPE kurusuru-stem].
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-terminative-v-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE v-stem].
; <type val="pure-aspect-terminative-c-stem-lex">
; <name-ja>補助動詞終結五段
; <description>「verbやlightverbの連用形+て」の形の直後にあって、その行為や状態が終わる（終える）意を
; 添える補助動詞。五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>宿題 を やっ て しまう
; <nex>食器 を しまう
; <todo>
; </type>
pure-aspect-terminative-c-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-c2-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-kurusuru-stem-lex := pure-aspect-terminative-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-terminative-minus_shon-stem-lex := pure-aspect-terminative-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-terminative-minus_shon-v-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-terminative-minus_shon-c-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-minus_shon-c2-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-minus_shon-kurusuru-stem-lex := pure-aspect-terminative-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-terminative-shon-stem-lex := pure-aspect-terminative-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-terminative-shon-v-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-terminative-shon-c-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-terminative-shon-c2-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-terminative-shon-kurusuru-stem-lex := pure-aspect-terminative-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

pure-aspect-prospective-v-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE v-stem].
pure-aspect-prospective-c-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE c-stem].
pure-aspect-prospective-c2-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE c2-stem].
pure-aspect-prospective-kurusuru-stem-lex := pure-aspect-prospective-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-prospective-minus_shon-stem-lex := pure-aspect-prospective-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                 [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

pure-aspect-prospective-minus_shon-v-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE v-stem].
; <type val="pure-aspect-prospective-minus_shon-c-stem-lex">
; <name-ja>前望相補助動詞非尊敬五段
; <description>「動詞連用形+て（で）」の直後につき、将来起こることに備えて何らかの行為・動作を完了させて
; しまう、という意を添える。このtypeには「置く」「おく」が登録されている。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>皿 を 洗っ て おく
; <nex>皿 を おく
; <todo>
; </type>
pure-aspect-prospective-minus_shon-c-stem-lex := pure-aspect-prospective-minus_shon-stem-lex &
 [STEMTYPE c-stem].

; pure-aspect-prospective-minus_shon-c2-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE c2-stem].
; pure-aspect-prospective-minus_shon-kurusuru-stem-lex := pure-aspect-prospective-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

pure-aspect-prospective-shon-stem-lex := pure-aspect-prospective-stem-lex &
			     [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
						 VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
								       CONT.HOOK.INDEX #2 ]],
					    CONT.HOOK.INDEX #3,
					    CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
										 [HONORED #2,
										  BEARER #3,
										  POLARITY +] !>]]].

pure-aspect-prospective-shon-v-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE v-stem].
pure-aspect-prospective-shon-c-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE c-stem].
pure-aspect-prospective-shon-c2-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE c2-stem].
pure-aspect-prospective-shon-kurusuru-stem-lex := pure-aspect-prospective-shon-stem-lex & [STEMTYPE kurusuru-stem].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



; (MS 2003-12-19) Matrix 0.6

perspective-stem-lex  := aux-arg123-stem-lex &
  [SYNSEM.LOCAL [CAT [VAL perspective_transitive & 
 			 [SUBJ.FIRST #sbj,
 			  COMPS #comps],
 		     HEAD.AUX complex_aux],
 		ARG-S < #sbj . #comps >]].


perspective-arg1emp-stem-lex := perspective-stem-lex &
 [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
	  LOCAL.CTXT.EMPATHY.EMPEE #ind]].

perspective-arg2emp-stem-lex := perspective-stem-lex &
 [SYNSEM [LKEYS.KEYREL.ARG2 #ind,
	  LOCAL.CTXT.EMPATHY.EMPEE #ind]].


perspective-arg1emp-v-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-c-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-c2-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-kurusuru-stem-lex := perspective-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].



perspective-arg1emp-minus_shon-stem-lex := perspective-arg1emp-stem-lex &
 [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
		     VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
					   CONT.HOOK.INDEX #2]],
		CONT.HOOK.INDEX #3,
		CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
						     [HONORED #2,
						      BEARER #3,
						      POLARITY -] !>]]].

; <type val="perspective-arg1emp-minus_shon-v-stem-lex">
; <name-ja>補助動詞非尊敬一段
; <description>「verb連用形+て」の直後に接続する補助動詞。「が」格（行為を行うもの）をARG1、「に」格（行為を受ける
; もの）をARG2、本動詞（行われる行為）をARG3に取る。このtypeは主語（「が」格）に対する敬意を表す場合には使えない。
; 一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>私 が お 年寄り に 本 を 取っ て さしあげる
; <nex>私 が お 年寄り に 本 を さしあげる
; <todo>
; </type>
perspective-arg1emp-minus_shon-v-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-minus_shon-c-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-minus_shon-c2-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-minus_shon-kurusuru-stem-lex := perspective-arg1emp-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


perspective-arg1emp-shon-stem-lex := perspective-arg1emp-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

perspective-arg1emp-shon-v-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE v-stem].
perspective-arg1emp-shon-c-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE c-stem].
perspective-arg1emp-shon-c2-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg1emp-shon-kurusuru-stem-lex := perspective-arg1emp-shon-stem-lex & [STEMTYPE kurusuru-stem].

perspective-arg2emp-v-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-c-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-c2-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-kurusuru-stem-lex := perspective-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].



perspective-arg2emp-minus_shon-stem-lex := perspective-arg2emp-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

perspective-arg2emp-minus_shon-v-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-minus_shon-c-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-minus_shon-c2-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-minus_shon-kurusuru-stem-lex := perspective-arg2emp-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].


perspective-arg2emp-shon-stem-lex := perspective-arg2emp-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

perspective-arg2emp-shon-v-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE v-stem].
perspective-arg2emp-shon-c-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE c-stem].
perspective-arg2emp-shon-c2-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE c2-stem].
perspective-arg2emp-shon-kurusuru-stem-lex := perspective-arg2emp-shon-stem-lex & [STEMTYPE kurusuru-stem].


; (ERB 2001-12-28) For VN + itadaku, etc.
; (MS 2003-12-19) Matrix 0.6
; (FCB 2005-06-27)  FIXME: should refactor with 3 others
light-perspective-stem-lex  := aux-arg123-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL light-perspective_transitive & 
 			[SUBJ.FIRST  #sbj,
 			 COMPS #comps],
 	       ARG-S < #sbj . #comps >]].

; (MS 2003-12-16) For more types in the lexicon

light-perspective-arg2emp-stem-lex := light-perspective-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG2 #obj2ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #obj2ind]].

light-perspective-arg1emp-stem-lex := light-perspective-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].


light-perspective-v-stem-lex := light-perspective-stem-lex & [STEMTYPE v-stem].
light-perspective-c-stem-lex := light-perspective-stem-lex & [STEMTYPE c-stem].
light-perspective-c2-stem-lex := light-perspective-stem-lex & [STEMTYPE c2-stem].
light-perspective-kurusuru-stem-lex := light-perspective-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-arg2emp-v-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE v-stem].
light-perspective-arg2emp-c-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE c-stem].
light-perspective-arg2emp-c2-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-arg2emp-kurusuru-stem-lex := light-perspective-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].
light-perspective-arg1emp-v-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-arg1emp-c-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-arg1emp-c2-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-arg1emp-kurusuru-stem-lex := light-perspective-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-minus_shon-stem-lex := light-perspective-stem-lex &
                           [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
					       VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
								     CONT.HOOK.INDEX #2]],
					  CONT.HOOK.INDEX #3,
					  CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].

light-perspective-minus_shon-arg1emp-stem-lex := light-perspective-minus_shon-stem-lex &
						 [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
							  LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-perspective-minus_shon-v-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE v-stem].
light-perspective-minus_shon-c-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE c-stem].
light-perspective-minus_shon-c2-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE c2-stem].
light-perspective-minus_shon-kurusuru-stem-lex := light-perspective-minus_shon-stem-lex & [STEMTYPE kurusuru-stem].

; <type val="light-perspective-minus_shon-arg1emp-v-stem-lex">
; <name-ja>承サ変補助動詞非尊敬一段
; <description>light-nohon-kurusuru-stem-lexを参照。このtypeは主語（「が」格）への尊敬を表す場合には使えない。
; 「が」格と「に」格とvn-lexを格として取り、「が」格（行為を行うもの）がARG1に、「に」格（行為を受けるもの）が
; ARG2に、vn-lex（行われる行為）がARG3になる。一段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>担当 が 鈴木 様 に ご 回答 さしあげ ます
; <nex>子犬 さしあげ ます
; <todo>(TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうので、このtypeにおいても
; (lkb::do-parse-tty "お 調べ さしあげる")が解析できてしまうが、日本語の表現として正しくないのではないか
; （「お 調べ 申し上げる」が正しいのではないか）。
; </type>
light-perspective-minus_shon-arg1emp-v-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-minus_shon-arg1emp-c-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-minus_shon-arg1emp-c2-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-minus_shon-arg1emp-kurusuru-stem-lex := light-perspective-minus_shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


light-perspective-shon-stem-lex := light-perspective-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

; (MS 2003-12-16) For more types in the lexicon

light-perspective-shon-arg2emp-stem-lex := light-perspective-shon-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG2 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].

light-perspective-shon-arg1emp-stem-lex := light-perspective-shon-stem-lex &
					   [SYNSEM [LKEYS.KEYREL.ARG1 #ind,
						    LOCAL.CTXT.EMPATHY.EMPEE #ind]].



light-perspective-shon-v-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-c-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE c-stem].
light-perspective-shon-c2-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-kurusuru-stem-lex := light-perspective-shon-stem-lex & [STEMTYPE kurusuru-stem].

light-perspective-shon-arg2emp-v-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-arg2emp-c-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE c-stem].
; <type val="light-perspective-shon-arg2emp-c2-stem-lex">
; <name-ja>承サ変補助動詞尊敬五段変則
; <description>light-nohon-kurusuru-stem-lexを参照。このtypeは主語（「が」格）への尊敬を表す場合に使う。
; 「が」格（行為を行うもの）がARG1、「に」格（行為を受けるもの）がARG2、vn-lex（行われる行為）がARG3
; になる。五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>お客様 が 私 に 内容 を ご 質問 くださる
; <nex>賞状 を くださる
; <todo>(TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、
; (lkb::do-parse-tty "先生 が 私 に お 答え くださる")という表現も使える。
; </type>
light-perspective-shon-arg2emp-c2-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-arg2emp-kurusuru-stem-lex := light-perspective-shon-arg2emp-stem-lex & [STEMTYPE kurusuru-stem].
light-perspective-shon-arg1emp-v-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE v-stem].
light-perspective-shon-arg1emp-c-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE c-stem].
light-perspective-shon-arg1emp-c2-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE c2-stem].
light-perspective-shon-arg1emp-kurusuru-stem-lex := light-perspective-shon-arg1emp-stem-lex & [STEMTYPE kurusuru-stem].


base-adj-stem-lex := verb-stem-lex-base &
[SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
                          [H-TENSE #tense]],
                CONT [HOOK.INDEX event &
                            [E [TENSE #tense]]]],
         NON-LOCAL.QUE <! !>],
 STEMTYPE adj-stem].

; (ERB 2001-11-12) When I removed lexical_sign-word from v-lex to
; preserve no+dop types from the [WLINK nelist] constraint, i adjectives
; got left with no labels.  Trying this type as a place to put them
; back in.  (one type up --- base-adj-stem-lex --- would also include
; nai-adj).
; (MS 2005-05-11) This should combine HEAD.KEYS.KEYREL with PRED, shouldn't it?
; Otherwise we get garu-sbj-change-rule for i-adj.

adj-stem-lex := base-adj-stem-lex & lexical_sign-word &
[SYNSEM [LOCAL [CONT simple-verb-sem-type &
		     [RELS <! #key !>,
		      HCONS <! !>,
		      HOOK [INDEX #ind,
			 LTOP #top]],
		CAT.HEAD.KEYS.KEY #keyrel],
	 LKEYS.KEYREL #key & [ ARG0 #ind,
			       PRED #keyrel,
				 LBL #top]],
 STEMTYPE adj-stem].

; (ERB 2001-11-12) Replacing PRED 'aru with exist_rel.
; (MS 2001-11-19) Making the SUBJ optional. It has to be tested, whether this leads to spurious ambiguities.
; (ERB 2002-01-10) Trying to cut back on ambiguity in ではない sentences.
; Two different でs are modifying ない because it is MAIN-PRD bool.
; Try MAIN-PRD +.  ... That doesn't work because のです requires
; MAIN-PRD - on its OBJ.  But, I've required that the MOD.MAIN-PRD
; of pobj は and the MOD.MAIN-PRD of its object be the same, and this
; might do the trick since は only wants to modify MAIN-PRD + things.

; (MS 2004-07-09) neg-relation should use ARG1 instead of ARG3.
; (MS 2004-12-21) these are for nai that takes ga  and nai that 
; takes ga - n : 花子は問題がない、問題ない

base-i-adj-neg-stem-lex := base-adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD [ MODUS negative ],
		     VAL [SUBJ.FIRST [OPT + ,
				       LOCAL [CAT.HEAD case-p_head & [CASE ga],
					      CONT.HOOK.INDEX #inst]]]],
		CONT [HOOK [INDEX #event,
			    XARG #inst,
			   LTOP #top],
		      RELS <! neg-relation & #key &
			    [ARG1 #arghd, 
			     LBL #top],
			    [PRED "_exist_v_rel",
			     LBL #aru_hd,
			     ARG0 #event,
			     ARG1 #inst]!>,
		      HCONS <! qeq & [HARG #arghd,
				      LARG #aru_hd] !>]],
	 LKEYS.KEYREL #key]].


; <type val="i-adj-neg-stem-lex">
; <name-ja>ナイ形容詞
; <description>日本語以外では否定と捉えられる場合が多い、形容詞の「ない」。i-adj-stem-lexを参照。
; <ex>金 が ない
; <nex>人 が い ない
; <todo>
; </type>
i-adj-neg-stem-lex := base-i-adj-neg-stem-lex &
		      [SYNSEM.LOCAL.CAT.VAL sbj-arg].

; <type val="i-adj-nocase-neg-stem-lex">
; <name-ja>格省略ナイ形容詞
; <description>名詞の直後について（＝名詞と「ない」の間にあるはずの「が」がない）、その名詞が
; 存在しないという意味の形容詞を作る。i-adj-stem-lexを参照。
; 実際の意味の上ではi-adj-neg-stem-lexとあまり差がないと思われるが、MRSでは大きく違っている。
; (lkb::do-parse-tty "私 が 関係 ない")の場合、「私」と「関係」を結び付けるMRSになっているが、
; (lkb::do-parse-tty "私 が 関係 が ない")の場合はそれができない。
; <ex>私 が 関係 ない
; <nex>私 が 関係 が ない
; <todo>
; </type>
i-adj-nocase-neg-stem-lex := base-i-adj-neg-stem-lex &
 [SYNSEM.LOCAL [CAT.VAL sbj-obj-arg & 
			[COMPS.FIRST [OPT - ,
				      LOCAL [CAT [HEAD ordinary_noun_head,
						  VAL saturated],
					     CONT.HOOK.INDEX #compsind]]],
		CONT.RELS.LIST.REST.FIRST.ARG2 #compsind]].


; <type val="i-adj-stem-lex">
; <name-ja>普通形容詞
; <description>日本で一般的に形容詞と呼ばれているもの。格は主格（「が」格）のみ取れる。活用あり。
; <ex>桜 が 美しい
; <nex>桜 を 美しい
; <todo>
; </type>
i-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
                    VAL adj_sc &
                         [SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #inst]]],
		CONT.HOOK.XARG #inst],
	 LKEYS [KEYREL arg1-relation &
			 [ARG1 #inst]]]].

; (MS 2005-06-20) For honorific adjectives like yoroshii.

; <type val="i-adj-hon-stem-lex">
; <name-ja>形容詞丁寧
; <description>形容詞のうち、丁寧あるいは尊敬を表すもの。i-adj-stem-lexを参照。
; <ex>成績 が よろしい
; <nex>
; <todo>
; </type>
i-adj-hon-stem-lex := i-adj-stem-lex &
		      [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

; (MS 2005-11-09) To get rid of skip files.

; <type val="i-adj-minusshon-stem-lex">
; <name-ja>形容詞非丁寧
; <description>主語（「が」格）への尊敬や丁寧を表す場合に使えない形容詞。i-adj-stem-lexを参照。
; また、「いい」のみがこのtypeに登録されているが、「いい」は終止形と連体形でしか使われないが、
; 他の活用形でも解析できるようになっている（ex.「頭 が いかっ た」）。
; <ex>夕食 は さんま が いい
; <nex>御社 の 商品 は 質 が いい
; <todo>FIXME: is this really shon -? (TK: 2007-03-14)
; </type>
i-adj-minusshon-stem-lex := i-adj-stem-lex &
		      [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON -].

eval-i-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL.CAT [HEAD.MODUS indicative,
                    VAL eval-adj_sc &
                         [COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #inst]],
               LKEYS [KEYREL arg1-relation &
                         [ARG1 #inst]]]].

;for rashii, in e.g. 食べるらしい

eval-obl-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & [FIRST.LOCAL.CAT.HEAD verb_head]].

; for ii, in e.g. 食べていい

; <type val="eval-opt-i-adj-stem-lex">
; <name-ja>補助形容詞
; <description>「用言の連用形+て(v-te-end-lex?)」の形の後について、その用言で表される行為・状態などについて
; 何らかの感情を表す場合に使う。
; <ex>食べ て 良い
; <nex>味 が 良い
; <todo>
; </type>
eval-opt-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS opt-1-arg & 
						       [FIRST.LOCAL.CAT.HEAD verb_head & [H-TENSE te, FIN -]]].

; (MS 2005-11-09) Subtype to get rid of skip files

; <type val="eval-opt-i-adj-minusshon-stem-lex">
; <name-ja>補助形容詞非尊敬
; <description>eval-opt-i-adj-stem-lexを参照。このtypeは主語への敬意を表す場合には使えない。
; <ex>食べ て いい
; <nex>なさっ て いい
; <todo>
; </type>
eval-opt-i-adj-minusshon-stem-lex := eval-opt-i-adj-stem-lex &
				     [SYNSEM.LOCAL.CAT.HEAD.FORMAL.SHON - ].



;for rashii, in e.g. 静からしい

naarg-obl-i-adj-stem-lex := eval-i-adj-stem-lex &
			   [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & [FIRST.LOCAL.CAT.HEAD na-adj_head]].


;;; (FCB 2004-06-25) new type for 子供らしい 子供っぽい


cop-adj-stem-lex := adj-stem-lex &
[SYNSEM [LOCAL [CAT [HEAD.MODUS indicative,
		     VAL cop-id_transitive &
				[SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbj,
				 COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #nom]],
		CONT.HOOK.XARG #sbj],
	 LKEYS [KEYREL arg1-relation &
		       [ARG1 #sbj,
			ARG2 #nom]]]].

n-obl-i-adj-stem-lex := cop-adj-stem-lex &
 [SYNSEM.LOCAL.CAT.VAL.COMPS obl-1-arg & 
       [FIRST.LOCAL.CAT.HEAD noun_head]].


;;; adjective type for two place predicates like 欲しい

; <type val="i-adj-go-stem-lex">
; <name-ja>ヲ目的格形容詞
; <description>格は主格（「が」格）目的格（「を」格）が取れる。活用あり。
; <ex>犬 が 餌 を 欲しい
; <nex>犬 が 餌 に 欲しい
; <todo> LR for i-adj-gg-stem-lex subcat
; </type>
i-adj-go-stem-lex := adj-stem-lex &
  [SYNSEM [LKEYS.KEYREL arg12-relation & [ARG1 #sbjind,
 			ARG2 #objind],
 	  LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ga-wo_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
 		 CONT [HOOK.XARG #sbjind]]]].

; <type val="i-adj-gg-stem-lex">
; <name-ja>ガ目的格形容詞
; <description>格は主格（「が」格）目的格（「が」格）が取れる。活用あり。
; 目的格の欠けている文では出現しない。格が２つとも「は」の場合（例えば「犬 は 餌 は 欲しい」）
; はこのtypeでなくi-adj-go-stem-lexを選択すべき。
; <ex>犬 が 餌 が 欲しい
; <nex>犬 が 餌 に 欲しい
; <todo>
; </type>
i-adj-gg-stem-lex := adj-stem-lex &
  [SYNSEM [LKEYS.KEYREL arg12-relation & [ARG1 #sbjind,
 			ARG2 #objind],
 	  LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ga-ga_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
 		 CONT [HOOK.XARG #sbjind]]]].

; <type val="i-adj-ng-stem-lex">
; <name-ja>ニ主格ガ目的格形容詞
; <description>格は主格（「に」格）目的格（「が」格）が取れる。活用あり。
; 主格（「に」格）の現れない文では出現しない。
; <ex>私 に 勇気 が 欲しい
; <ex>勇気 が 私 に 欲しい
; <nex>勇気 が 欲しい
; <todo>「に」格がobligatoryになっていない（主格をobligatoryにできない）
; </type>
i-adj-ng-stem-lex := adj-stem-lex &
  [SYNSEM [LKEYS.KEYREL arg12-relation & [ARG1 #sbjind,
 			ARG2 #objind],
 	  LOCAL [CAT [HEAD.MODUS indicative,
 		      VAL ni-ga_transitive &
 			   [SUBJ.FIRST.LOCAL.CONT.HOOK.INDEX #sbjind,
 			    COMPS.FIRST.LOCAL.CONT.HOOK.INDEX #objind]],
 		 CONT [HOOK.XARG #sbjind]]]].


;generic types for CHASEN connection

; (ERB 2001-10-23) This type had an unbound HCONS value.  Adding
; that constraint.

generic-i-adj-lex := v-lex & lexical_sign-word & 
             [SYNSEM [LOCAL [CAT [HEAD i-adj_head &
                                      [H-TENSE #tense],
                                 VAL adj_sc &
				       [SUBJ.FIRST [LOCAL.CONT.HOOK [INDEX #inst,
								     LTOP #handle]]]],
                            CONT simple-verb-sem-type &
                                [HOOK [INDEX event & #ind & 
					     [E [TENSE #tense]],
				       XARG #inst,
				       LTOP #handle],
				 RELS <! #relation !>,
				 HCONS <! !>],
                            BAR -],
		      LKEYS.KEYREL arg1-relation & #relation &
                                       [ARG1 #inst,
					ARG0 #ind,
                                        LBL #handle],
                      NON-LOCAL [QUE <! !>]],
              INFLECTED +].



generic_adj_te_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE t-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.H-TENSE te] > ],
 J-NEEDS-AFFIX +].

generic_adj_past_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE t-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.H-TENSE past] > ],
 J-NEEDS-AFFIX +].

generic_adj_a_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE a-morph,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head,
 J-NEEDS-AFFIX +].


; (ERB 2001-10-23) This type had an unbound HCONS value.  Adding
; that constraint.

; (ERB 2002-01-15) I don't see why this type should have adj_rel...
; assuming that's reserved for attributive adjectives and that the
; generic entry should be predicative.  Changing to arg1-relation.

; (FCB 2006-01-26) added BAR - and INFLECTED + to reduce ambiguity a little
; also MODUS.indicative
; FIXME: propogate these changes to the other adjective types, and maybe refactor
; need to copy from i-adj-stem-lex to link the semantics 
; - can't inherit because of verb-stem-lex-base being INFLECTED -

generic_adj_i_infl-lex  :=  v-lex & lexical_sign-word &
 [RMORPH-BIND-TYPE u-morph,
 SYNSEM [LOCAL [CAT [HEAD i-adj-stem_head &
                          [H-TENSE #tense & present,
			   MODUS indicative,
                           MOD < [LOCAL [CAT.HEAD noun_head,
                                         BAR +],
                                  MODIFIED.PERIPH -] >,
                           MARK null,
                           J-SPEC.FIRST.LOCAL.CAT.HEAD noun_head,
                           FIN +,
                           FORMAL.AHON -],
                     VAL adj_sc &
                          [SUBJ.FIRST [LOCAL.CONT.HOOK [INDEX #inst,
                                                        LTOP #handle]]]],
                CONT simple-verb-sem-type &
                    [HOOK [INDEX event & #ind &
                                 [E [TENSE #tense]],
                           LTOP #handle],
		          RELS  <! #key !>,
			  HCONS <! !>],
                BAR -],
         LKEYS.KEYREL #key & arg1-relation &
               [ARG0 #ind,
                ARG1 #inst,
                LBL #handle],
         NON-LOCAL.QUE <! !>],
 J-NEEDS-AFFIX -,
 INFLECTED +].





generic_adj_kere_infl-lex := generic-i-adj-lex &
[RMORPH-BIND-TYPE cond-morph,
 J-NEEDS-AFFIX +,
 SYNSEM.LOCAL.CAT.HEAD i-adj_head & [MARK < [LOCAL.CAT.HEAD.MODUS conditional] > ]].


generic_adj_short_infl-lex  := generic-i-adj-lex &
[RMORPH-BIND-TYPE shortadj-morph,
 J-NEEDS-AFFIX -,
 SYNSEM.LOCAL [CAT.HEAD i-adj_head],
 INFLECTED +].



; (ERB 2001-09-19) I want the verbal nouns to all be [H-TENSE no_tense]
; so I can keep them from being the complement of nspec-no-3.  This
; means they can't share H-TENSE with the light verbs.  I'm going to
; try breaking that identity here.

; (MS 2001-09-20) There is a much easier solution to that: see the no-nspec-3 lexical entry.

; (ERB 2001-12-28) True light verbs raise content and therefore should
; have empty WLINKs.  So, this should be a subtype of lexical_sign and
; not lexical_sign-word.  Move that to appropriate subtypes.  (It already
; is a subtype of lexical_sign, via ancestors.)

; (ERB 2002-01-11) Changed supertype here from verb-stem-lex to
; verb-stem-lex-base because some subtypes don't want the identification
; of MOD-IND & INDEX and MOD-HAND & LTOP supplied by simple-verb-sem-type.
; ... added in verb-stem-lex-super to keep contrast with other subtypes
; of verb-stem-lex-base (in potential rule, and maybe some other
; inflectional rules) while not inheriting this constraint.

; (ERB 2002-01-11) quasi-light-verbs shouldn't identify INDEX and
; SPR.INDEX.  This constraint is already repeated on light-stem-lex,
; and we don't need it here.  Still presumably want the E.TENSE value
; to come from the SPR's INDEX, though.

; (MS 2004-12-14) The light verb needs to copy the VN's ARG-S, such
; that this can be accessed by, e.g., passive.

light-stem-base-lex := verb-stem-lex-super &
[SYNSEM [LOCAL [CAT [HEAD light-verb_head &
                          [H-TENSE #tense,
                           MODUS #mood],
                     VAL light_transitive & 
                          [SPR.FIRST.LOCAL [ CAT.HEAD.MODUS #mood,
					     CONT.HOOK.INDEX.E.TENSE #tense,
					     ARG-S #arg-s]]],
                CONT pred-sem-type & [HOOK.INDEX [E.TENSE #tense]],
		ARG-S #arg-s],
         NON-LOCAL.QUE <! !>,
	 MODIFIED.PERIPH bool]].

; (ERB 2001-12-28) The passive suffix looks in the KEY to get the
; right value for the new SUBJ.  This means that unless light verbs share
; the KEY of their SPR, the SUBJ in a passive sentence won't get
; linked to any role of the verb.  Also, grab LTOP, not KEY.LBL.
; (Remember: Content raising words should have empty WLINKs.)



light-stem-lex := light-stem-base-lex &
[ SYNSEM [LOCAL [CAT.VAL.SPR.FIRST [LOCAL.CONT simple-verb-sem-type &
                                              [HOOK #hook]],
                CONT [HOOK #hook,
                      RELS <! !>,
                      HCONS <! !>]]]].


; (ERB 2001-12-28) We don't use all of these types, since the
; space of light verbs isn't that big.  Commenting out the unused ones.


light-nohon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="light-nohon-kurusuru-stem-lex">
; <name-ja>承サ変補助動詞
; <description>「vn-lex+light-nohon-kurusuru-stem-lex」の形で動詞として働く。どんな格を取るかはvn-lexに依存する。
; サ行変格活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>車 が 故障 する
; <ex>父 が 友人 を 招待 する
; <nex>掃除 を する
; <todo>(TK 07-04-04)現状では、全てのlightverbがverbstemがvn化したものの直後にもついてしまうが、vn化したverbstem
; の直後について良いのは「お 送り する」などの敬語？（丁寧？）表現の場合のみ。
; ただし、例外として「数値 を 打ち込み する」のような使い方ができるものもあるかもしれない。
; </type>
light-nohon-kurusuru-stem-lex := light-nohon-stem-lex & [STEMTYPE kurusuru-stem].

; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-21) It is not right to say something about the subject of the spr. 
; it can be already bound by a zpro. taking that out (勉強になる)

light-shon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL [SPR.FIRST [LOCAL [CONT.HOOK [INDEX #3,
						     XARG #2]]]]],
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

; <type val="light-shon-c-stem-lex">
; <name-ja>承サ変補助動詞尊敬五段
; <description>light-shon-c2-stem-lexを参照。ただしこのtypeは五段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>ご 出発 に なる
; <nex>犬 に なる
; <todo>(TK 07-05-08)「hon-prefix『ご（御）』+vn-lex+light-shon-c-stem-lex」の形でしか使わないのに、
; hon-prefixがつくと解析できなくなってしまう。
; (TK 07-05-08)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、
; (lkb::do-parse-tty "車 を お 停め に なる")という表現は可能。
; </type>
light-shon-c-stem-lex := light-shon-stem-lex & [STEMTYPE c-stem].

; (MS 2005-06-20) nasaru.

; <type val="light-shon-c2-stem-lex">
; <name-ja>承サ変補助動詞尊敬五段変則
; <description>vn-lexやverb連用形の直後にあって１つの動詞のような働きを持たせる。
; 主格（「が」格）への敬意を表す場合に使う。五段変則活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>出発 なさい ます か
; <nex>何 に なさい ます か
; <todo>(TK 07-04-04)日本語として正しいかどうかの議論はあるが、(lkb::do-parse-tty "ご 出発 なさい ます か")のような
; 使い方がされる場合もあるので、「hon-prefix+vn(or verb連用形)+light-shon-c2-stem-lex」も解析できるようにすべき
; かもしれない。
; (TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、
; (lkb::do-parse-tty "車 を お 停め なさる")という表現も、古風ではあるが可能。
; </type>
light-shon-c2-stem-lex := light-shon-stem-lex & [STEMTYPE c2-stem].


; (MS 2003-12-19) Matrix 0.6
; (MS 2005-06-21) It is not right to say something about the subject of the spr. 
; it can be already bound by a zpro. taking that out (勉強いたす) and binding the
; honorification to XARG.

light-minus_shon-stem-lex := light-stem-lex &
[SYNSEM.LOCAL [CAT.HEAD.FORMAL.SHON -,
               CONT.HOOK [INDEX #3,
			  XARG #2],
               CTXT  subj-honor-ctxt & [BACKGROUND <! subj-honor_rel &
						    [HONORED #2,
						     BEARER #3,
						     POLARITY -] !>]]].

; <type val="light-minus_shon-v-stem-lex">
; <name-ja>承サ変補助動詞非尊敬一段
; <description>light-minus_shon-c-stem-lexを参照。ただしこちらは一段活用をする
; (http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>私 が 報告 申し上げ ます
; <nex>先方 の 役員 が 報告 申し上げ た
; <todo>(TK 07-03-28)light-minus_shon-c-stem-lexを参照。
; (TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、
; (lkb::do-parse-tty "お 答え 申し上げる")という表現は可能。
; </type>
light-minus_shon-v-stem-lex := light-minus_shon-stem-lex & [STEMTYPE v-stem].
; <type val="light-minus_shon-c-stem-lex">
; <name-ja>承サ変補助動詞非尊敬五段
; <description>light-nohon-kurusuru-stem-lexを参照。ただしこちらは主語（「が」格）への敬意を表す場合には使えない。
; 本来は「hon-prefix+vn」の直後にもつくべきだが、現状では解析ができない。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>弊社 が 参加 いたし ます
; <nex>国王 が 来社 いたし ます
; <todo>(TK 07-03-28)「hon-prefix+vn-lex+light-minus_shon-c-stem-lex」の形でも解析できるようにすべき。
; (lkb::do-parse-tty "ご 案内 いたし ます")
; (TK 07-04-04)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべきだが、
; (lkb::do-parse-tty "お 答え いたし ます")という表現は可能。
; </type>
light-minus_shon-c-stem-lex := light-minus_shon-stem-lex & [STEMTYPE c-stem].

; (ERB 2001-08-30) Fixing dekiru so that it has some semantic effect 
; in combination with vns.  Giving it the same semantic effect of rareru.

; (ERB 2001-08-30) Want two subtypes of dekiru --- one that is ga_wo_trans
; and one that has a ga marked object and a suppressed subject (zpro).

; (MS 2001-09-14) Changed that again. There is only one type of dekiru 
; that undergoes the objchange rule.

; (ERB 2001-12-28) Replacing this with a slightly more general type
; that allows for all of the quasi-light-verbs.

quasi-light-lex :=  light-stem-base-lex & lexical_sign-word &
[SYNSEM [LOCAL [CAT.VAL.SPR.FIRST [LOCAL.CONT [ HOOK.LTOP #ohand ]],
		CONT [RELS <! #key & arg12-ev-relation & 
			    [LBL #top,
			     ARG0 #event,
			     ARG2 #chand] !>,
		      HOOK [INDEX #event,
			    LTOP #top],
		      HCONS <! qeq & [HARG #chand, LARG #ohand] !>]],
	 LKEYS.KEYREL #key]].  


; (ERB 2001-12-28) Once again, the space of quasi light verbs isn't
; that big, so we're not using many of these.  Commenting out those
; that aren't in use.


quasi-light-nohon-stem-lex := quasi-light-lex &
[SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

quasi-light-nohon-v-stem-lex := quasi-light-nohon-stem-lex & [STEMTYPE v-stem].
; <type val="quasi-light-nohon-c-stem-lex">
; <name-ja>準補助動詞五段
; <description>vn-lexの直後について、vn-lexの行為にそれぞれ独自の意味を付加する補助動詞。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>退場 願う
; <nex>成功 を 願う
; <todo>(TK 07-04-09)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべき
; だが、(lkb::do-parse-tty "お 引き取り ねがう")のような敬語表現は可能。
; </type>
quasi-light-nohon-c-stem-lex := quasi-light-nohon-stem-lex & [STEMTYPE c-stem].

; (MS 2005-11-09) Subtypes to get rid of skip files.

; <type val="quasi-light-nohon-v-stem-rareru-lex">
; <name-ja>準補助動詞可能一段
; <description>quasi-light-nohon-c-stem-lexを参照。
; このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>私 が 機械 を 操作 できる
; <nex>私 に 操作 が できる
; <todo>(TK 07-04-09)全てのlightverbがverbstemがvn化したものの直後にもついてしまうのは修正すべき
; だが、(lkb::do-parse-tty "お 作り でき ます")のような敬語表現は可能。
; (TK 07-04-09)可能表現に必須の「に」格が主格で「が」格が目的格となる構文が解析できない。
; (lkb::do-parse-tty "私 に 機械 が 操作 できる")。rareru-end-imorph-lexも参照。
; </type>
quasi-light-nohon-v-stem-rareru-lex := quasi-light-nohon-v-stem-lex &
				       [SYNSEM.LKEYS.KEYREL rareru-relation ].

; (MS 2003-12-17) We cannot safely switch to the Matrix 0.6 definition of lexeme. 
; This needs some fundamental adaptations of the word and lexeme concepts.

lexeme := lexical_sign.



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  VP embedding Syntactic V-Vs
;;
;; (cf. syntactic-vv-stem_head in lex-types.tdl
;;      syn-vv-vp-stem_head in lex-types.tdl
;;      syntactic-vv-vp-stem-lex in lex-types.tdl
;;      syn-vv-raising-stem-lex in lex-types.tdl
;;      syn-vv-raising-{v/c/c2/kurusuru}-stem-lex in lex-types.tdl
;;      syn-vv-control-stem-lex in lex-types.tdl
;;      syn-vv-control-{v/c/c2/kurusuru}-stem-lex in lex-types.tdl
;;      infinitive-infl-rule-for-syntactic-VV in infl.tdl)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(CH 2005-04-09)
; v-stem_head と同じ
; 統語的複合動詞の V2 のためのタイプ
syntactic-vv-stem_head  := other-verb-stem_head &
			   [AUX aux_minus,
			    LIGHT -,
			    ADJ -,
			    COP -].

;(CH 2005-04-09)
; head for VP embedding V-Vs
syn-vv-vp-stem_head := syntactic-vv-stem_head &
		       [MODUS nonpassive].

;(CH 2005-04-09)
; Raising V-V と Control V-V の上位タイプ
; restricted the VP's COMPS to be <> (SPR should be a VP),
; and added the identities between SUBJs and COMPSs.
; syntactic-vv-vp-stem-lex := verb-stem-lex & lexical_sign-word &
;  [SYNSEM [LOCAL [CAT [HEAD syn-vv-vp-stem_head & [H-TENSE #tense],
; 		      VAL aspect_transitive &
; 			   [SUBJ < #sbj >,
; 			    COMPS #obj & <>,
; 			    SPR < [LOCAL [CONT.HOOK.LTOP #ohand,
; 					  CAT [VAL [SUBJ < #sbj >,
; 						    COMPS #obj ]]]] > ]],
; 		 CONT [HOOK.INDEX #event & [E [TENSE #tense]],
; 		       HCONS <! qeq & [LARG #ohand,
; 				       HARG #soa] !>,
; 		       RELS diff-list & <! #key,
; 					 message &
; 					 [PRED proposition_m_rel,
; 					  MARG #soa] !>],
; 		 ARG-S < #sbj >],
; 	  LKEYS.KEYREL #key & 
; 		[ARG0 #event],
; 	  NON-LOCAL.QUE <! !>,
; 	  MODIFIED.PERIPH bool]].

;(CH 2005-04-09) [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.CAT.HEAD.FIN -]
;(CH 2005-04-09) [SYNSEM.LOCAL.CAT.VAL.SPR.FIRST.LOCAL.BAR +]
;(CH 2005-04-09) verb-stem_head --> ordinary-verb-stem_head
syntactic-vv-vp-stem-lex := verb-stem-lex & lexical_sign-word &
 [SYNSEM [LOCAL [CAT [HEAD syn-vv-vp-stem_head & [H-TENSE #tense],
		      VAL aspect_transitive &
			   [SUBJ < #sbj >,
			    COMPS #obj & <>,
			    SPR < [LOCAL [CONT.HOOK [ LTOP #ohand ],
					  CAT [HEAD ordinary-verb-stem_head & [FIN -],
					       VAL [SUBJ < #sbj >,
						    COMPS #obj ]],
					  BAR +]] > ]],
		 CONT [HOOK.INDEX #event & [E [TENSE #tense]],
		       HCONS <! qeq & [ LARG #ohand] !>,
		       RELS diff-list & <! #key !>],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL #key & 
		[ARG0 #event],
	  NON-LOCAL.QUE <! !>,
	  MODIFIED.PERIPH bool]].

;(CH 2005-04-09)
; Raising 版の統語的複合
syn-vv-raising-stem-lex := syntactic-vv-vp-stem-lex &
 [SYNSEM [ LOCAL.CONT.HCONS <! [ HARG #chand ] !>,
	   LKEYS.KEYREL  arg1-relation & [ ARG1 #chand ]]].

; <type val="syn-vv-raising-v-stem-lex">
; <name-ja>統語的複合動詞繰り上げ型一段
; <description>syn-vv-raising-c-stem-lexを参照。
; このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>雨 が 降り はじめる
; <nex>授業 を はじめる
; <todo>
; </type>
syn-vv-raising-v-stem-lex := syn-vv-raising-stem-lex & [STEMTYPE v-stem].
; <type val="syn-vv-raising-c-stem-lex">
; <name-ja>統語的複合動詞繰り上げ型五段
; <description>統語的複合動詞V1-V2のうち、V2に使われるもの。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>雨 が 降り だす
; <nex>本 を だす
; <todo>
; </type>
syn-vv-raising-c-stem-lex := syn-vv-raising-stem-lex & [STEMTYPE c-stem].
;syn-vv-raising-c2-stem-lex := syn-vv-raising-non-aa-stem-lex & [STEMTYPE c2-stem].
;syn-vv-raising-kurusuru-stem-lex := syn-vv-raising-non-aa-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; Control 版の統語的複合
syn-vv-control-stem-lex := syntactic-vv-vp-stem-lex &
 [SYNSEM [ LOCAL [ CAT.VAL.SUBJ < [ LOCAL.CONT.HOOK.INDEX #sbjind ] >,
                   CONT.HCONS <! [ HARG #chand ] !>],
           LKEYS.KEYREL  arg12-relation & 
                 [ ARG1 #sbjind, ARG2 #chand ]]].

; <type val="syn-vv-control-v-stem-lex">
; <name-ja>統語的複合動詞コントロール型一段
; <description>syn-vv-control-c-stem-lexを参照。
; このtypeは一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>米 を 食べ 飽きる
; <nex>食べる こと に 飽きる
; <todo>
; </type>
syn-vv-control-v-stem-lex := syn-vv-control-stem-lex & [STEMTYPE v-stem].
; <type val="syn-vv-control-c-stem-lex">
; <name-ja>統語的複合動詞コントロール型五段
; <description>統語的複合動詞V1-V2のうち、V2に使われるもの。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>御飯 を 食べ 損なう
; <nex>景観 を 損なう
; <todo>
; </type>
syn-vv-control-c-stem-lex := syn-vv-control-stem-lex & [STEMTYPE c-stem].
;syn-vv-control-c2-stem-lex := syn-vv-control-stem-lex & [STEMTYPE c2-stem].
;syn-vv-control-kurusuru-stem-lex := syn-vv-control-stem-lex & [STEMTYPE kurusuru-stem].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  V embedding Syntactic V-Vs  ( Kageyama's (1993) V' complement type )
;;
;; (cf. syn-vv-vbar-stem_head in lex-types.tdl
;;      syn-vv-vbar-stem_transitive in lex-types.tdl
;;      syntactic-vv-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-intrans-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-monotrans-vbar-stem-lex in lex-types.tdl
;;      syntactic-vv-ditrans-vbar-stem-lex in lex-types.tdl
;;      vbar-monotransitivization-lrules in infl.tdl
;;      vbar-ditransitivization-lrules in infl.tdl)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;(CH 2005-04-09)
; head for V embedding V-Vs
syn-vv-vbar-stem_head := syntactic-vv-stem_head.

;(CH 2005-04-09)
; based on light_transitive
;(CH 2005-04-09)
; verb-stem_head --> ordinary-verb-stem_head
syn-vv-vbar-stem_transitive := valence &
 [SPR  obl-1-arg &
       < [LOCAL [CAT [HEAD ordinary-verb-stem_head & [MAIN-PRD -],
		      VAL [SUBJ #sbj,
			   COMPS #comps]],
		 BAR +],
	  LEX +] >,
  SUBJ #sbj,
  COMPS #comps].

;(CH 2005-04-09)
; added [SYNSEM.LOCAL.CONT.HOOK.XARG #sbjind] so that XARG is linked to ARG1.
; (FCB 2005-06-27) Added ARG0 to message

syntactic-vv-vbar-stem-lex := verb-stem-lex & lexical_sign-word &
 [SYNSEM [LOCAL [CAT [HEAD syn-vv-vbar-stem_head & [H-TENSE #tense],
		      VAL syn-vv-vbar-stem_transitive &
			   [SUBJ.FIRST #sbj & 
				       [LOCAL [CAT.HEAD case-p_head &
							[CASE ni-or-ga],
					       CONT.HOOK.INDEX #sbjind]],
			    SPR.FIRST.LOCAL.CONT.HOOK.LTOP #ohand ]],
		 CONT [HOOK [INDEX #event & [E.TENSE #tense],
			     XARG #sbjind],
		       RELS  <! #key !>,
		       HCONS <! qeq & [ LARG #ohand ] !>],
		 ARG-S < #sbj >],
	  LKEYS.KEYREL #key & arg1-relation &
		[ARG1 #sbjind,
		 ARG0 #event],
	  NON-LOCAL.QUE <! !>,
	  MODIFIED.PERIPH bool]].

;(CH 2005-04-09)
; for an intransitive V1
syntactic-vv-intrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CONT.HCONS <! [ HARG #chand] !>,
		 CAT.VAL.SPR <[LOCAL.CAT.VAL [COMPS null]]>],
	  LKEYS.KEYREL arg12-relation &
		[ARG2 #chand]]].

; <type val="syn-vv-intrans-vbar-v-stem-lex">
; <name-ja>統語的複合動詞補語型五段
; <description>syn-vv-intrans-vbar-c-stem-lexを参照。
; 一段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>本 を 読み はじめる
; <nex>授業 を はじめる
; <todo>
; </type>
syn-vv-intrans-vbar-v-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE v-stem].
; <type val="syn-vv-intrans-vbar-c-stem-lex">
; <name-ja>統語的複合動詞補語型五段
; <description>統語的複合動詞V1-V2のうち、V2に使われるもの。
; 五段活用をする(http://wiki.delph-in.net/moin/JacyMorphologyを参照)。
; <ex>電話 を 掛け 直す
; <nex>電話 を 直す
; <todo>
; </type>
syn-vv-intrans-vbar-c-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-intrans-vbar-c2-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-intrans-vbar-kurusuru-stem-lex := syntactic-vv-intrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; for a monotransitive V1
syntactic-vv-monotrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL [COMPS <[LOCAL.CONT.HOOK.INDEX #objind]>,
			   SPR.FIRST.LOCAL.CAT.VAL.COMPS 1-list]],
		 CONT.HCONS <! [ HARG #chand] !>],
	  LKEYS.KEYREL arg123-relation &
		[ARG2 #objind,
		 ARG3 #chand]]].

syn-vv-monotrans-vbar-v-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE v-stem].
syn-vv-monotrans-vbar-c-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-monotrans-vbar-c2-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-monotrans-vbar-kurusuru-stem-lex := syntactic-vv-monotrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].

;(CH 2005-04-09)
; for a ditransitive V1
syntactic-vv-ditrans-vbar-stem-lex := syntactic-vv-vbar-stem-lex &
 [SYNSEM [LOCAL [CAT [VAL [COMPS <[LOCAL.CONT.HOOK.INDEX #objind],
				  [LOCAL.CONT.HOOK.INDEX #obj2ind]>,
			   SPR.FIRST.LOCAL.CAT.VAL.COMPS 2-comps-list]],
		 CONT.HCONS <! [ HARG  #chand] !>],
	  LKEYS.KEYREL arg1234-relation &
		[ARG2 #objind,
		 ARG3 #obj2ind,
		 ARG4 #chand]]].

syn-vv-ditrans-vbar-v-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE v-stem].
syn-vv-ditrans-vbar-c-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE c-stem].
;syn-vv-ditrans-vbar-c2-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE c2-stem].
;syn-vv-ditrans-vbar-kurusuru-stem-lex := syntactic-vv-ditrans-vbar-stem-lex & [STEMTYPE kurusuru-stem].

;;;
;;; Information from v-lex-types.tdl (merged 2009-07-05)
;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;        file: %Z% %M%
;;;      module:
;;;     version: %I%
;;;  written by: Melanie Siegel
;;; last update: %G% --- %U%
;;;  updated by: 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; author            | date        | modification
;;; ------------------|-------------|------------------------------------------
;;;Melanie Siegel (MS)|             |Emily Bender (ERB), Francis Bond (FCB)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;LEXICAL TYPES -- verbs;;;;;;;;;;;

; (ERB 2001-10-17) Added subtypes of lexical_sign.  See notes in
; fundamentals.tdl.

; (ERB 2001-11-07) Certain entries for the (non-id) copula inherit
; from this type and shouldn't have interesting WLINKs.  So, v-lex
; is now just lexical_sign and some, but not all, of its subtypes
; are lexical_sign-word.

v-lex := lexical_sign & 
         [SYNSEM [LOCAL [CAT [HEAD verb_head,
                              VAL valence],
                         NUCL nucl_plus],
                  NON-LOCAL [AFFIX <! !>]]].



nonaux-lex := v-lex & 
           [SYNSEM [LOCAL.CAT.HEAD verb-noninfl_head-avm,
                    NON-LOCAL.QUE <! !>]].


generic-verb-lex := v-lex & lexical_sign-word &
                    [SYNSEM [LOCAL [CAT [HEAD verb_head-avm & [COP -,
                                                               AUX aux_minus,
                                                               VN -,
                                                               H-TENSE #tense,
                                                               MODUS #modus],
                                         VAL ga-wo_transitive &
                                              [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
					       COMPS #comps & [FIRST.LOCAL.CONT.HOOK.INDEX #objind]]],
                                    CONT simple-verb-sem-type &
                                        [HOOK.INDEX event & [E [TENSE #tense,
                                                           MOOD #modus]],
                                         RELS <!  #key !>,
                                         HCONS <! !>],
				    ARG-S < #sbj . #comps >],
			     LKEYS.KEYREL #key & arg12-ev-relation & arg12-relation & [ARG1 #sbjind,
									       ARG2 #objind],
                             NON-LOCAL.QUE <! !>],
                     INFLECTED +].


generic_verb_ru_infl-lex := generic-verb-lex &
                            [SYNSEM.LOCAL [CAT [HEAD [MOD < [LOCAL [CAT.HEAD noun_head,
								    BAR +],
							     MODIFIED.PERIPH -] >,
                                                      MODUS indicative,
                                                      H-TENSE present,
                                                      MARK < >,
                                                      J-SPEC < [LOCAL.CAT.HEAD noun_head] >,
                                                      FIN +,
                                                      FORMAL.AHON +]],
                                           BAR +],
                             J-NEEDS-AFFIX -].

generic_verb_i_infl-lex := generic-verb-lex &
                           [RMORPH-BIND-TYPE i-morph,
                            J-NEEDS-AFFIX +].


generic_verb_morphbind_infl-lex := generic-verb-lex &
                           [RMORPH-BIND-TYPE morphbind,
                            J-NEEDS-AFFIX +].


generic_verb_a_infl-lex := generic-verb-lex &
                           [RMORPH-BIND-TYPE a-morph,
                            J-NEEDS-AFFIX +].

generic_verb_t_infl-lex  := generic-verb-lex &
                           [RMORPH-BIND-TYPE t-morph,
                            J-NEEDS-AFFIX +].


generic_verb_cond_infl-lex  := generic-verb-lex &
                           [RMORPH-BIND-TYPE cond-morph,
                            J-NEEDS-AFFIX +].

generic_verb_o_infl-lex  := generic-verb-lex &
                           [RMORPH-BIND-TYPE o-morph,
                            J-NEEDS-AFFIX +].

generic_verb_vstem_infl-lex := generic-verb-lex &
                           [RMORPH-BIND-TYPE vstem-morph,
                            J-NEEDS-AFFIX +].

; (ERB 2002-01-14) [SMOD unmarked] to restrain utterance-rule2e.
; (FCB 2003-12-04) Hooked up ARG0

vn-lex  := nonaux-lex & lexical_sign-word & 
           [SYNSEM [LOCAL [CAT [HEAD vn_head-avm & [MAIN-PRD -,
                                                    SMOD unmarked,
						    KEYS.KEY #keypred]],
			   CONT simple-verb-sem-type & [HOOK [INDEX #ind,
							     LTOP #top],
						       RELS <! #key !>,
						       HCONS <! !>]],
		    LKEYS.KEYREL #key & [ ARG0 #ind,
					  PRED #keypred,
					  LBL #top]],
            INFLECTED +].

vn-sbj-comps-lex := vn-lex &
		    [SYNSEM.LOCAL [CAT.VAL [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind],
					    COMPS #comps],
				   CONT.HOOK.XARG #sbjind,
				   ARG-S < #sbj . #comps >]].

vn-trans1-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-wo_transitive &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				    ARG2 #objind]]]].



vn-trans2-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-ni_transitive &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				      ARG2 #objind]]]].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (TK 07-07-04)
;; We have "v3(and v5a)-stem-lex" as "ga-to_transitive1" ,
;; and have "v5-stem-lex" as "ga-to_transitive2".
;; Despite this , we had used "vn-trans3-lex" as "ga-to_transitive2".
;; And we didn't have "ga-to_transitive1" in vn-lex.
;; I had felt confusing . 
;; So I redefined "vn-trans3-lex" as "ga-to_transitive1",and
;; defined "vn-trans5-lex" as "ga-to_transitive2".
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vn-trans5-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-to_transitive2 &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				    ARG2 #objind]]]].

; <type val="vn-trans5-lex">
; <name-ja>サ変ト他動詞
; <description>主格（「が」格）と目的格（「と」）格を取るサ変動詞。Jacy Valenceのga-to_transitive2
; を参照(http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、
; 後にlightverbを伴って動詞として働くことができる。日本語では一般的に自動詞と呼ばれる。
; vn-trans3-lexとの違いは、文中に「と」格にあたるものが無くても出現する点である。
; <ex>兄 が 弟 と 喧嘩 する
; <ex>喧嘩 を やめる
; <nex>
; <todo>
; </type>
vn-trans5-lex := vn-trans5-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

vn-trans5-hhon-lex := vn-trans5-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

vn-trans5-minus_shon-lex  := vn-trans5-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans5-hhon-minus_shon-lex  := vn-trans5-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans5-shon-lex := vn-trans5-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans5-hhon-shon-lex := vn-trans5-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


vn-trans3-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-to_transitive1 &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				    ARG2 #objind]]]].

vn-trans8-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL sbj-narg_transitive &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				      ARG2 #objind]],
		     NON-LOCAL.ROBUST +]].

vn-ditrans-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ditransitive &
                                      [COMPS [FIRST.LOCAL.CONT [HOOK.INDEX #objind],
					      REST.FIRST.LOCAL.CONT [HOOK.INDEX #obj2ind]],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				      ARG2 #objind,
                                      ARG3 #obj2ind]]]].

vn-intrans-super-lex := vn-lex &
            [SYNSEM [LOCAL [CAT.VAL intransitive &
                                      [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind]],
			    ARG-S < #sbj >,
			    CONT.HOOK.XARG #sbjind],
		     LKEYS [KEYREL.ARG1 #sbjind]]].



vn-ditrans-toni-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-wo-toni-ditransitive &
                                      [COMPS [FIRST.LOCAL.CONT [HOOK.INDEX #objind],
					      REST.FIRST.LOCAL.CONT [HOOK.INDEX #obj2ind]],
				       SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				      ARG2 #objind,
                                      ARG3 #obj2ind]]]].


; (ERB 2001-10-24) I need these verbs to have a special KEY type
; so that the k2y machinery can recognize them.  Currently, they
; are getting arg3_rel-super by type inference, and this isn't specific
; enough.


;vn-intransarg2-lex := vn-lex &
;            [SYNSEM.LOCAL [CAT.VAL intransitive &
;                                      [SUBJ.FIRST #sbj & [LOCAL.CONT.HOOK.INDEX #sbjind]],
;                           CONT [KEY arg2only_rel &
;                                     [ARG2 #sbjind]],
;			   ARG-S < #sbj >]].



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;VNs;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vn-ditrans-hhon-lex := vn-ditrans-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].
vn-intrans-hhon-lex := vn-intrans-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].
vn-trans3-hhon-lex := vn-trans3-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].
vn-trans2-hhon-lex := vn-trans2-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].
; <type val="vn-trans1-hhon-lex">
; <name-ja>サ変ヲ他動詞尊敬
; <description>vn-trans1-lexを参照。このtypeは聞き手（読み手）に対する敬意を表す場合に使う。
; <ex>彼 が 理由 を 存知 する
; <nex>ご 存知 です か
; <todo>(TK 07-04-09)このtypeには「存知」のみが登録されているが、「存知」には本来honorification
; に関わる意味は含まれない。
; また、もし「ご存知」として使うのであれば、それは「存じる」の名詞化（vn化？）であり、「ご存じ」
; という表記が正しい。（間違えて「ご存知」と表記する場合もあるが」）
; </type>
vn-trans1-hhon-lex := vn-trans1-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vn-ditrans-minus_shon-lex := vn-ditrans-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
								  VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
											CONT.HOOK.INDEX #2]],
							     CONT.HOOK.INDEX #3,
							     CTXT [BACKGROUND <! subj-honor_rel &
									       [HONORED #2,
										BEARER #3,
										POLARITY -] !>]]].


vn-intrans-minus_shon-lex  := vn-intrans-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                   VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans3-minus_shon-lex  := vn-trans3-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans2-minus_shon-lex  := vn-trans2-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans1-minus_shon-lex  := vn-trans1-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
vn-ditrans-hhon-minus_shon-lex := vn-ditrans-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-intrans-hhon-minus_shon-lex  := vn-intrans-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans3-hhon-minus_shon-lex  := vn-trans3-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans2-hhon-minus_shon-lex  := vn-trans2-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

vn-trans1-hhon-minus_shon-lex  := vn-trans1-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vn-ditrans-shon-lex := vn-ditrans-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].


vn-intrans-shon-lex := vn-intrans-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans3-shon-lex := vn-trans3-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans2-shon-lex := vn-trans2-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans1-shon-lex := vn-trans1-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

vn-ditrans-hhon-shon-lex := vn-ditrans-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].


vn-intrans-hhon-shon-lex := vn-intrans-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans3-hhon-shon-lex := vn-trans3-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans2-hhon-shon-lex := vn-trans2-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

vn-trans1-hhon-shon-lex := vn-trans1-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

; <type val="vn-trans1-minusbar-lex">
; <name-ja>サ変ヲ他動詞化接尾辞
; <description>名詞（vn-lexを含む）の直後について、１つのvn-trans1-lexのような働きのものを作る接尾辞。
; しかし今のところ全く機能していない。このtypeが単独でtransitiveのvn-lexと同じ働きをしてしまっている。
; <ex>書類 を 電子 化 する
; <nex>回路 が 小型 化 する
; <todo>(TK 07-03-20)descriptionを参照。また、nexに挙げた例文を解析するために、vn-intrans-lex化させる
; typeも必要。
; </type>
vn-trans1-minusbar-lex := vn-trans1-lex &
			  [SYNSEM.LOCAL.BAR -].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; no honorification needs an empty background. so, I've inserted
;; the vn-trans1-super-lex types.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; <type val="vn-trans1-lex">
; <name-ja>サ変ヲ他動詞
; <description>主格（「が」格）と目的格（「を」）格を取るサ変動詞。Jacy Valenceのga-wo_transitive
; を参照(http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、
; 後にlightverbを伴って動詞として働くことができる。日本語では一般的に他動詞と呼ばれる。
; <ex>スパイ が 暗号 を 解読 する
; <ex>解読 が 進む
; <nex>
; <todo>(TK 07-03-20)名詞単独でもそのまま目的格補語として取ってしまう。(lkb::do-parse-tty "犬 飼育 する")
; </type>
vn-trans1-lex := vn-trans1-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="vn-trans2-lex">
; <name-ja>サ変ニ他動詞
; <description>主格（「が」格）と目的格（「に」）格を取るサ変動詞。Jacy Valenceのga-ni_transitive
; を参照(http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、
; 後にlightverbを伴って動詞として働くことができる。日本語では一般的に自動詞と呼ばれる。
; <ex>社員 が サーバー に ログイン する
; <ex>ログイン が 出来 ない
; <nex>
; <todo>vn-trans1-lexを参照。
; </type>
vn-trans2-lex := vn-trans2-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].


; <type val="vn-trans3-lex">
; <name-ja>サ変ト必須他動詞
; <description>主格（「が」格）と目的格（「と」）格を取るサ変動詞。Jacy Valenceのga-to_transitive1
; を参照(http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、
; 後にlightverbを伴って動詞として働くことができるが、このtypeは文中に「と」格にあたるものが無いと
; 出現しない。
; <ex>必ず 行く と 約束 する
; <nex>親 と 喧嘩 する
; <todo>
; </type>
vn-trans3-lex := vn-trans3-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="vn-trans8-lex">
; <name-ja>サ変特殊ヲ他動詞
; <description>主格（「が」格）と目的格（「を」）格を取るサ変動詞という意味ではvn-trans1-super-lexと同じ。
; ただしこのtypeは「を」が現れていなくても名詞を目的格補語として取る。Jacy Valenceのsbj-narg_transitiveを参照
; (http://wiki.delph-in.net/moin/JacyValence)。
; <ex>チェック よろしく お願い し ます
; <nex>チェック を よろしく お願い し ます
; <todo>(TK 07-05-08)v-present-tense-end-lexを参照。
; </type>
vn-trans8-lex := vn-trans8-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="vn-ditrans-lex">
; <name-ja>サ変二重目的他動詞
; <description>主格（「が」格）と２つの目的格（「を」格と「に」格）を取るサ変動詞。Jacy Valenceのditransitive
; を参照(http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、
; 後にlightverbを伴って動詞として働くことができる。日本語では一般的に他動詞と呼ばれる。
; <ex>妻 が 探偵 に 調査 を 依頼 する
; <ex>依頼 を 断る
; <nex>
; <todo>(TK 07-03-22)「を」とこのtypeの間にある「に」が、必ずcaseになってしまうのは改善すべき
; (lkb::do-parse-tty "調査 を ３ 時 に 依頼 する")。v4-c-stem-lexも参照。
; </type>
vn-ditrans-lex := vn-ditrans-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="vn-ditrans-toni-lex">
; <name-ja>ヲニト二重目的サ変他動詞
; <description>主格（「が」格）と２つの目的格（「を」格と「に」or「と」格）を取るサ変動詞。Jacy Valenceの
; ga-wo-toni-ditransitiveを参照(http://wiki.delph-in.net/moin/JacyValence)。
; 日本語では一般的に他動詞と呼ばれる。
; <ex>日本国 を 日 と 略 する
; <ex>日本国 の 略 は 日 だ
; <ex>日本国 を １ 文字 に 略 する
; <nex>
; <todo>vn-trans1-lexを参照。
; </type>
vn-ditrans-toni-lex := vn-ditrans-toni-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

; <type val="vn-intrans-lex">
; <name-ja>サ変自動詞
; <description>主格（「が」格）を取るサ変動詞。Jacy Valenceのditransitiveを参照
; (http://wiki.delph-in.net/moin/JacyValence)。名詞として働くことができる他、 後にlightverbを伴って動詞
; として働くことができる。日本語では一般的に自動詞と呼ばれる。
; <ex>両親 が 旅行 する
; <ex>旅行 が 楽しい
; <nex>
; <todo>
; </type>
vn-intrans-lex := vn-intrans-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].

;;; (TK 07-07-05)
;;; We didin't have "ga-to-ni_transitive1" , So I defined "vn-trans6-lex" .
;;; I used "vn-trans2-lex" & "v6-stem-lex" as reference.

vn-trans6-super-lex := vn-sbj-comps-lex &
            [SYNSEM [LOCAL.CAT.VAL ga-to-ni_transitive1 &
				   [COMPS.FIRST.LOCAL.CONT [HOOK.INDEX #objind],
				    SUBJ.FIRST.LOCAL.CONT [HOOK.INDEX #sbjind]],
		     LKEYS [KEYREL [ARG1 #sbjind,
				      ARG2 #objind]]]].


vn-trans6-hhon-lex := vn-trans6-super-lex & [SYNSEM.LOCAL.CAT.HEAD.FORMAL.AHON +].

vn-trans6-minus_shon-lex  := vn-trans6-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].


vn-trans6-hhon-minus_shon-lex  := vn-trans6-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON -,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON -,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY -] !>]]].


vn-trans6-shon-lex := vn-trans6-super-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].


vn-trans6-hhon-shon-lex := vn-trans6-hhon-lex & [SYNSEM.LOCAL [CAT [HEAD.FORMAL.SHON +,
                    VAL.SUBJ.FIRST.LOCAL [CAT.HEAD.FORMAL.SHON +,
                                           CONT.HOOK.INDEX #2]],
               CONT.HOOK.INDEX #3,
               CTXT [BACKGROUND <! subj-honor_rel &
                                   [HONORED #2,
                                    BEARER #3,
                                    POLARITY +] !>]]].

; <type val="vn-trans6-lex">
; <name-ja>サ変ニト他動詞
; <description>主格（「が」格）と目的格（「に」格or「と」格）を取るサ変動詞。
; Jacy Valenceのga-ni_transitiveを参照(http://wiki.delph-in.net/moin/JacyValence)。
; 名詞として働くことができる他、後にlightverbを伴って動詞として働くことができる。
; <ex>隕石 に 衝突 する
; <ex>隕石 と 衝突 する
; <nex>
; <todo>vn-trans1-lexを参照。
; </type>
vn-trans6-lex := vn-trans6-super-lex &
		 [SYNSEM.LOCAL.CTXT.BACKGROUND <! !>].


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
